#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DonkehFramework

#include "Basic.hpp"

#include "DonkehFramework_classes.hpp"
#include "DonkehFramework_parameters.hpp"


namespace SDK
{

// Function DonkehFramework.DFGunRecoilHandler.GetConeOfFireOffset
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDFGunRecoilHandler::GetConeOfFireOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "GetConeOfFireOffset");

	Params::DFGunRecoilHandler_GetConeOfFireOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFGunRecoilHandler.OnTick
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGunRecoilHandler::OnTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "OnTick");

	Params::DFGunRecoilHandler_OnTick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGunRecoilHandler.OnWeaponFire
// (Native, Event, Public, BlueprintEvent)

void UDFGunRecoilHandler::OnWeaponFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "OnWeaponFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGunRecoilHandler.OnWeaponStartFire
// (Native, Event, Public, BlueprintEvent)

void UDFGunRecoilHandler::OnWeaponStartFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "OnWeaponStartFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGunRecoilHandler.OnWeaponStopFire
// (Native, Event, Public, BlueprintEvent)

void UDFGunRecoilHandler::OnWeaponStopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "OnWeaponStopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGunRecoilHandler.GetOwningGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseGun*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseGun* UDFGunRecoilHandler::GetOwningGun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "GetOwningGun");

	Params::DFGunRecoilHandler_GetOwningGun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFGunRecoilHandler.GetOwningPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UDFGunRecoilHandler::GetOwningPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "GetOwningPawn");

	Params::DFGunRecoilHandler_GetOwningPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFGunRecoilHandler.IsFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFGunRecoilHandler::IsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGunRecoilHandler", "IsFiring");

	Params::DFGunRecoilHandler_IsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFHandlerInterface.EventInit
// (Event, Protected, BlueprintEvent)

void IDFHandlerInterface::EventInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFHandlerInterface", "EventInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFHandlerInterface.EventOnNewPawn
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            PreviousPawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDFHandlerInterface::EventOnNewPawn(class APawn* NewPawn, class APawn* PreviousPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFHandlerInterface", "EventOnNewPawn");

	Params::DFHandlerInterface_EventOnNewPawn Parms{};

	Parms.NewPawn = NewPawn;
	Parms.PreviousPawn = PreviousPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFHandlerInterface.EventReset
// (Event, Protected, BlueprintEvent)

void IDFHandlerInterface::EventReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFHandlerInterface", "EventReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFHandlerInterface.EventRespawn
// (Event, Protected, BlueprintEvent)

void IDFHandlerInterface::EventRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFHandlerInterface", "EventRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFHandlerInterface.EventShouldUpdateThisFrame
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActiveAndSpawnedInWorld                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDFHandlerInterface::EventShouldUpdateThisFrame(float DeltaTime, bool bActiveAndSpawnedInWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFHandlerInterface", "EventShouldUpdateThisFrame");

	Params::DFHandlerInterface_EventShouldUpdateThisFrame Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.bActiveAndSpawnedInWorld = bActiveAndSpawnedInWorld;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFHandlerInterface.EventUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMakeDecision                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDFHandlerInterface::EventUpdate(float DeltaTime, bool bMakeDecision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFHandlerInterface", "EventUpdate");

	Params::DFHandlerInterface_EventUpdate Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.bMakeDecision = bMakeDecision;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseAIController.CanRestartPlayer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseAIController::CanRestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAIController", "CanRestartPlayer");

	Params::DFBaseAIController_CanRestartPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.ForceStopFiring
// (Native, Public, BlueprintCallable)

void ADFBaseItem::ForceStopFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ForceStopFiring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.OnEnterInventory
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseCharacter*                 NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseCharacter*                 LastOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::OnEnterInventory(class ADFBaseCharacter* NewOwner, class ADFBaseCharacter* LastOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OnEnterInventory");

	Params::DFBaseItem_OnEnterInventory Parms{};

	Parms.NewOwner = NewOwner;
	Parms.LastOwner = LastOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.OnEquip
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseItem*                      LastItem                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::OnEquip(class ADFBaseItem* LastItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OnEquip");

	Params::DFBaseItem_OnEquip Parms{};

	Parms.LastItem = LastItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.OnLeaveInventory
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseCharacter*                 LastOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::OnLeaveInventory(class ADFBaseCharacter* LastOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OnLeaveInventory");

	Params::DFBaseItem_OnLeaveInventory Parms{};

	Parms.LastOwner = LastOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.OnRep_PawnOwner
// (Final, Native, Protected)
// Parameters:
// class ADFBaseCharacter*                 LastOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::OnRep_PawnOwner(class ADFBaseCharacter* LastOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OnRep_PawnOwner");

	Params::DFBaseItem_OnRep_PawnOwner Parms{};

	Parms.LastOwner = LastOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.OnTurnOff
// (Native, Public, BlueprintCallable)

void ADFBaseItem::OnTurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OnTurnOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.OnUnEquip
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPlayAnimAndWait                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeavingPawnInventory                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::OnUnEquip(bool bPlayAnimAndWait, bool bLeavingPawnInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OnUnEquip");

	Params::DFBaseItem_OnUnEquip Parms{};

	Parms.bPlayAnimAndWait = bPlayAnimAndWait;
	Parms.bLeavingPawnInventory = bLeavingPawnInventory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.ReceiveOnEnterInventory
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADFBaseCharacter*                 NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseCharacter*                 LastOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ReceiveOnEnterInventory(class ADFBaseCharacter* NewOwner, class ADFBaseCharacter* LastOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnEnterInventory");

	Params::DFBaseItem_ReceiveOnEnterInventory Parms{};

	Parms.NewOwner = NewOwner;
	Parms.LastOwner = LastOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseItem.ReceiveOnEquip
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADFBaseItem*                      LastItem                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ReceiveOnEquip(class ADFBaseItem* LastItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnEquip");

	Params::DFBaseItem_ReceiveOnEquip Parms{};

	Parms.LastItem = LastItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseItem.ReceiveOnEquipFinished
// (Event, Protected, BlueprintEvent)

void ADFBaseItem::ReceiveOnEquipFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnEquipFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseItem.ReceiveOnLeaveInventory
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADFBaseCharacter*                 LastOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ReceiveOnLeaveInventory(class ADFBaseCharacter* LastOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnLeaveInventory");

	Params::DFBaseItem_ReceiveOnLeaveInventory Parms{};

	Parms.LastOwner = LastOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseItem.ReceiveOnTurnOff
// (Event, Protected, BlueprintEvent)

void ADFBaseItem::ReceiveOnTurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnTurnOff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseItem.ReceiveOnUnEquip
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPlayAnimAndWait                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeavingPawnInventory                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ReceiveOnUnEquip(bool bPlayAnimAndWait, bool bLeavingPawnInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnUnEquip");

	Params::DFBaseItem_ReceiveOnUnEquip Parms{};

	Parms.bPlayAnimAndWait = bPlayAnimAndWait;
	Parms.bLeavingPawnInventory = bLeavingPawnInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseItem.ReceiveOnUnEquipFinished
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bLeavingPawnInventory                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ReceiveOnUnEquipFinished(bool bLeavingPawnInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveOnUnEquipFinished");

	Params::DFBaseItem_ReceiveOnUnEquipFinished Parms{};

	Parms.bLeavingPawnInventory = bLeavingPawnInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseItem.ReceiveStartFire
// (Event, Protected, BlueprintEvent)

void ADFBaseItem::ReceiveStartFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveStartFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseItem.ReceiveStopFire
// (Event, Protected, BlueprintEvent)

void ADFBaseItem::ReceiveStopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveStopFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseItem.ReceiveVisibilityChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ReceiveVisibilityChanged(bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ReceiveVisibilityChanged");

	Params::DFBaseItem_ReceiveVisibilityChanged Parms{};

	Parms.bFirstPerson = bFirstPerson;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseItem.RemoveLegacyLocomotionAnims
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bFPP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::RemoveLegacyLocomotionAnims(bool bFPP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "RemoveLegacyLocomotionAnims");

	Params::DFBaseItem_RemoveLegacyLocomotionAnims Parms{};

	Parms.bFPP = bFPP;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.ServerStartFire
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              Origin                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ShootDir                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ShotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::ServerStartFire(struct FVector_NetQuantize& Origin, struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float Timestamp, int32 ShotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ServerStartFire");

	Params::DFBaseItem_ServerStartFire Parms{};

	Parms.Origin = std::move(Origin);
	Parms.ShootDir = std::move(ShootDir);
	Parms.RandomSeed = RandomSeed;
	Parms.Timestamp = Timestamp;
	Parms.ShotID = ShotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.ServerStopFire
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ADFBaseItem::ServerStopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "ServerStopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.SetMeshVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFirstPerson                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::SetMeshVisibility(bool bFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "SetMeshVisibility");

	Params::DFBaseItem_SetMeshVisibility Parms{};

	Parms.bFirstPerson = bFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.SetOwningPawn
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseCharacter*                 NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseItem::SetOwningPawn(class ADFBaseCharacter* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "SetOwningPawn");

	Params::DFBaseItem_SetOwningPawn Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.StartFire
// (Native, Public, BlueprintCallable)

void ADFBaseItem::StartFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "StartFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.StopFire
// (Native, Public, BlueprintCallable)

void ADFBaseItem::StopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "StopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseItem.CanAimWhileEquipped
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::CanAimWhileEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "CanAimWhileEquipped");

	Params::DFBaseItem_CanAimWhileEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.CanEquip
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::CanEquip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "CanEquip");

	Params::DFBaseItem_CanEquip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.CanFire
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::CanFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "CanFire");

	Params::DFBaseItem_CanFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.CanSprintWhileEquipped
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::CanSprintWhileEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "CanSprintWhileEquipped");

	Params::DFBaseItem_CanSprintWhileEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.CanStartFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::CanStartFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "CanStartFire");

	Params::DFBaseItem_CanStartFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.CanTriggerFire
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::CanTriggerFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "CanTriggerFire");

	Params::DFBaseItem_CanTriggerFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetAdjustedAimDirection
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADFBaseItem::GetAdjustedAimDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetAdjustedAimDirection");

	Params::DFBaseItem_GetAdjustedAimDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetItemMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ADFBaseItem::GetItemMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetItemMesh");

	Params::DFBaseItem_GetItemMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetItemMesh1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ADFBaseItem::GetItemMesh1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetItemMesh1P");

	Params::DFBaseItem_GetItemMesh1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetItemMeshToUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreLocalControlOnServer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ADFBaseItem::GetItemMeshToUse(bool bIgnoreLocalControlOnServer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetItemMeshToUse");

	Params::DFBaseItem_GetItemMeshToUse Parms{};

	Parms.bIgnoreLocalControlOnServer = bIgnoreLocalControlOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetItemType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemType ADFBaseItem::GetItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetItemType");

	Params::DFBaseItem_GetItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetLegacyLocomotionAnims
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bFPP                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, class UAnimSequenceBase*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, class UAnimSequenceBase*> ADFBaseItem::GetLegacyLocomotionAnims(bool bFPP) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetLegacyLocomotionAnims");

	Params::DFBaseItem_GetLegacyLocomotionAnims Parms{};

	Parms.bFPP = bFPP;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetOwnerViewLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADFBaseItem::GetOwnerViewLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetOwnerViewLocation");

	Params::DFBaseItem_GetOwnerViewLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetOwnerViewPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutViewLoc                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutViewRot                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::GetOwnerViewPoint(struct FVector* OutViewLoc, struct FRotator* OutViewRot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetOwnerViewPoint");

	Params::DFBaseItem_GetOwnerViewPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutViewLoc != nullptr)
		*OutViewLoc = std::move(Parms.OutViewLoc);

	if (OutViewRot != nullptr)
		*OutViewRot = std::move(Parms.OutViewRot);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetOwnerViewRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ADFBaseItem::GetOwnerViewRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetOwnerViewRotation");

	Params::DFBaseItem_GetOwnerViewRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetPawnInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDFInventoryComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFInventoryComponent* ADFBaseItem::GetPawnInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetPawnInventory");

	Params::DFBaseItem_GetPawnInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseCharacter*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseCharacter* ADFBaseItem::GetPawnOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetPawnOwner");

	Params::DFBaseItem_GetPawnOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.GetSpecificItemType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESpecificItemType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpecificItemType ADFBaseItem::GetSpecificItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "GetSpecificItemType");

	Params::DFBaseItem_GetSpecificItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.IsClientSimulated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::IsClientSimulated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "IsClientSimulated");

	Params::DFBaseItem_IsClientSimulated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::IsEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "IsEquipped");

	Params::DFBaseItem_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.IsEquipping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::IsEquipping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "IsEquipping");

	Params::DFBaseItem_IsEquipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "IsLocallyControlled");

	Params::DFBaseItem_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.IsUnEquipping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::IsUnEquipping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "IsUnEquipping");

	Params::DFBaseItem_IsUnEquipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.OwnerIsAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::OwnerIsAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OwnerIsAiming");

	Params::DFBaseItem_OwnerIsAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseItem.OwnerIsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseItem::OwnerIsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseItem", "OwnerIsSprinting");

	Params::DFBaseItem_OwnerIsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFIntrinsicCharAnimInstInterface.PlayDeathMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFIntrinsicCharAnimInstInterface::PlayDeathMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFIntrinsicCharAnimInstInterface", "PlayDeathMontage");

	Params::DFIntrinsicCharAnimInstInterface_PlayDeathMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFIntrinsicWeapAnimInstInterface.PlayEquipMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFIntrinsicWeapAnimInstInterface::PlayEquipMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFIntrinsicWeapAnimInstInterface", "PlayEquipMontage");

	Params::DFIntrinsicWeapAnimInstInterface_PlayEquipMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFIntrinsicWeapAnimInstInterface.PlayFireMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireLast                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAiming                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFIntrinsicWeapAnimInstInterface::PlayFireMontage(class UAnimMontage* MontageToPlay, bool bFireLast, bool bAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFIntrinsicWeapAnimInstInterface", "PlayFireMontage");

	Params::DFIntrinsicWeapAnimInstInterface_PlayFireMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.bFireLast = bFireLast;
	Parms.bAiming = bAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFIntrinsicWeapAnimInstInterface.PlayReloadMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFullReload                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFIntrinsicWeapAnimInstInterface::PlayReloadMontage(class UAnimMontage* MontageToPlay, bool bFullReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFIntrinsicWeapAnimInstInterface", "PlayReloadMontage");

	Params::DFIntrinsicWeapAnimInstInterface_PlayReloadMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.bFullReload = bFullReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFIntrinsicWeapAnimInstInterface.PlayUnEquipMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFIntrinsicWeapAnimInstInterface::PlayUnEquipMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFIntrinsicWeapAnimInstInterface", "PlayUnEquipMontage");

	Params::DFIntrinsicWeapAnimInstInterface_PlayUnEquipMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseAmmoClip.StoreAmmoInInventory
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDFInventoryComponent*            AmmoStore                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmmoAmt                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADFBaseAmmoClip>      AmmoType                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseAmmoClip::StoreAmmoInInventory(class UDFInventoryComponent* AmmoStore, int32 AmmoAmt, TSubclassOf<class ADFBaseAmmoClip>& AmmoType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBaseAmmoClip", "StoreAmmoInInventory");

	Params::DFBaseAmmoClip_StoreAmmoInInventory Parms{};

	Parms.AmmoStore = AmmoStore;
	Parms.AmmoAmt = AmmoAmt;
	Parms.AmmoType = AmmoType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseAmmoClip.ConsumeAmmo
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AmmoToConsume                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseAmmoClip::ConsumeAmmo(int32 AmmoToConsume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "ConsumeAmmo");

	Params::DFBaseAmmoClip_ConsumeAmmo Parms{};

	Parms.AmmoToConsume = AmmoToConsume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseAmmoClip.OnRep_CurrentClipAmmo
// (Native, Protected)

void ADFBaseAmmoClip::OnRep_CurrentClipAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "OnRep_CurrentClipAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseAmmoClip.OnRep_ReloadCounter
// (Native, Protected)

void ADFBaseAmmoClip::OnRep_ReloadCounter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "OnRep_ReloadCounter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseAmmoClip.SetCurrentClipAmmo
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewClipAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseAmmoClip::SetCurrentClipAmmo(int32 NewClipAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "SetCurrentClipAmmo");

	Params::DFBaseAmmoClip_SetCurrentClipAmmo Parms{};

	Parms.NewClipAmmo = NewClipAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseAmmoClip.SetOwningGun
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseGun*                       NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseAmmoClip::SetOwningGun(class ADFBaseGun* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "SetOwningGun");

	Params::DFBaseAmmoClip_SetOwningGun Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseAmmoClip.StoreAmmo
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AmmoToStore                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseAmmoClip::StoreAmmo(int32 AmmoToStore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "StoreAmmo");

	Params::DFBaseAmmoClip_StoreAmmo Parms{};

	Parms.AmmoToStore = AmmoToStore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseAmmoClip.GetCurrentClipAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseAmmoClip::GetCurrentClipAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "GetCurrentClipAmmo");

	Params::DFBaseAmmoClip_GetCurrentClipAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseAmmoClip.GetGunOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseGun*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseGun* ADFBaseAmmoClip::GetGunOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "GetGunOwner");

	Params::DFBaseAmmoClip_GetGunOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseAmmoClip.GetMaxClipAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseAmmoClip::GetMaxClipAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "GetMaxClipAmmo");

	Params::DFBaseAmmoClip_GetMaxClipAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseAmmoClip.GetStartingClipAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseAmmoClip::GetStartingClipAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "GetStartingClipAmmo");

	Params::DFBaseAmmoClip_GetStartingClipAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseAmmoClip.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseAmmoClip::IsLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseAmmoClip", "IsLoaded");

	Params::DFBaseAmmoClip_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.Aim
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::Aim(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Aim");

	Params::DFBaseCharacter_Aim Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.AimToggle
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::AimToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "AimToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ClearCharacterAnimInstances
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPerspectiveMeshOnly                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ClearCharacterAnimInstances(bool bPerspectiveMeshOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ClearCharacterAnimInstances");

	Params::DFBaseCharacter_ClearCharacterAnimInstances Parms{};

	Parms.bPerspectiveMeshOnly = bPerspectiveMeshOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ClientAdjustPosition_CustomStamina
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLoc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBaseBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerSprintStamina                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ClientAdjustPosition_CustomStamina(float Timestamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ClientAdjustPosition_CustomStamina");

	Params::DFBaseCharacter_ClientAdjustPosition_CustomStamina Parms{};

	Parms.Timestamp = Timestamp;
	Parms.NewLoc = std::move(NewLoc);
	Parms.NewVel = std::move(NewVel);
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;
	Parms.ServerSprintStamina = ServerSprintStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ClientAdjustRootMotionPosition_CustomStamina
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerMontageTrackPosition                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerLoc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ServerRotation                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerVelZ                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ServerBase                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ServerBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerSprintStamina                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ClientAdjustRootMotionPosition_CustomStamina(float Timestamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ClientAdjustRootMotionPosition_CustomStamina");

	Params::DFBaseCharacter_ClientAdjustRootMotionPosition_CustomStamina Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	Parms.ServerLoc = std::move(ServerLoc);
	Parms.ServerRotation = std::move(ServerRotation);
	Parms.ServerVelZ = ServerVelZ;
	Parms.ServerBase = ServerBase;
	Parms.ServerBoneName = ServerBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;
	Parms.ServerSprintStamina = ServerSprintStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ClientAdjustRootMotionSourcePosition_CustomStamina
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRootMotionSourceGroup           ServerRootMotion                                       (Parm, NativeAccessSpecifierPublic)
// bool                                    bHasAnimRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerMontageTrackPosition                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerLoc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ServerRotation                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerVelZ                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ServerBase                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ServerBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerSprintStamina                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ClientAdjustRootMotionSourcePosition_CustomStamina(float Timestamp, const struct FRootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ClientAdjustRootMotionSourcePosition_CustomStamina");

	Params::DFBaseCharacter_ClientAdjustRootMotionSourcePosition_CustomStamina Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerRootMotion = std::move(ServerRootMotion);
	Parms.bHasAnimRootMotion = bHasAnimRootMotion;
	Parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	Parms.ServerLoc = std::move(ServerLoc);
	Parms.ServerRotation = std::move(ServerRotation);
	Parms.ServerVelZ = ServerVelZ;
	Parms.ServerBase = ServerBase;
	Parms.ServerBoneName = ServerBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;
	Parms.ServerSprintStamina = ServerSprintStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ClientVeryShortAdjustPosition_CustomStamina
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLoc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBaseBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerSprintStamina                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ClientVeryShortAdjustPosition_CustomStamina(float Timestamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode, float ServerSprintStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ClientVeryShortAdjustPosition_CustomStamina");

	Params::DFBaseCharacter_ClientVeryShortAdjustPosition_CustomStamina Parms{};

	Parms.Timestamp = Timestamp;
	Parms.NewLoc = std::move(NewLoc);
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;
	Parms.ServerSprintStamina = ServerSprintStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.CrouchToggle
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::CrouchToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CrouchToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.Die
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   KillingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::Die(float KillingDamage, struct FDamageEvent& DamageEvent, class AController* Killer, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Die");

	Params::DFBaseCharacter_Die Parms{};

	Parms.KillingDamage = KillingDamage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.EquipItem
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseItem*                      ItemToEquip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::EquipItem(class ADFBaseItem* ItemToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "EquipItem");

	Params::DFBaseCharacter_EquipItem Parms{};

	Parms.ItemToEquip = ItemToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.EquipNextItem
// (Native, Public, BlueprintCallable)

void ADFBaseCharacter::EquipNextItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "EquipNextItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.EquipNextItemByType
// (Native, Public, BlueprintCallable)
// Parameters:
// EItemType                               ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::EquipNextItemByType(EItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "EquipNextItemByType");

	Params::DFBaseCharacter_EquipNextItemByType Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.EquipPreviousItem
// (Native, Public, BlueprintCallable)

void ADFBaseCharacter::EquipPreviousItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "EquipPreviousItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.GetNextInventoryItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEquippable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseItem*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseItem* ADFBaseCharacter::GetNextInventoryItem(bool bEquippable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetNextInventoryItem");

	Params::DFBaseCharacter_GetNextInventoryItem Parms{};

	Parms.bEquippable = bEquippable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetPreviousInventoryItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEquippable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseItem*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseItem* ADFBaseCharacter::GetPreviousInventoryItem(bool bEquippable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetPreviousInventoryItem");

	Params::DFBaseCharacter_GetPreviousInventoryItem Parms{};

	Parms.bEquippable = bEquippable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GiveLoadout
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UDFLoadout*                       Loadout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEquipFirstItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::GiveLoadout(class UDFLoadout* Loadout, bool bEquipFirstItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GiveLoadout");

	Params::DFBaseCharacter_GiveLoadout Parms{};

	Parms.Loadout = Loadout;
	Parms.bEquipFirstItem = bEquipFirstItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.GoProne
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::GoProne(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GoProne");

	Params::DFBaseCharacter_GoProne Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ItemEnabledModeChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDFItemEnabledMode                      PreviousItemEnabledMode                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ItemEnabledModeChanged(EDFItemEnabledMode PreviousItemEnabledMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ItemEnabledModeChanged");

	Params::DFBaseCharacter_ItemEnabledModeChanged Parms{};

	Parms.PreviousItemEnabledMode = PreviousItemEnabledMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.Lean
// (Native, Public, BlueprintCallable)
// Parameters:
// ELeanDirection                          DesiredLeanDir                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::Lean(ELeanDirection DesiredLeanDir, bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Lean");

	Params::DFBaseCharacter_Lean Parms{};

	Parms.DesiredLeanDir = DesiredLeanDir;
	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.LeanToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELeanDirection                          LeanDir                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::LeanToggle(ELeanDirection LeanDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "LeanToggle");

	Params::DFBaseCharacter_LeanToggle Parms{};

	Parms.LeanDir = LeanDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.LeaveProne
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::LeaveProne(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "LeaveProne");

	Params::DFBaseCharacter_LeaveProne Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.NextShotID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseCharacter::NextShotID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "NextShotID");

	Params::DFBaseCharacter_NextShotID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.OnDeath
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   KillingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APawn*                            InstigatingPawn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnDeath(float KillingDamage, struct FDamageEvent& DamageEvent, class APawn* InstigatingPawn, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnDeath");

	Params::DFBaseCharacter_OnDeath Parms{};

	Parms.KillingDamage = KillingDamage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.InstigatingPawn = InstigatingPawn;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_bAiming
// (Native, Protected)

void ADFBaseCharacter::OnRep_bAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_bAiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_bSprinting
// (Native, Protected)

void ADFBaseCharacter::OnRep_bSprinting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_bSprinting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_EquippedItem
// (Final, Native, Protected)
// Parameters:
// class ADFBaseItem*                      LastItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnRep_EquippedItem(class ADFBaseItem* LastItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_EquippedItem");

	Params::DFBaseCharacter_OnRep_EquippedItem Parms{};

	Parms.LastItem = LastItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_Health
// (Final, Native, Private)
// Parameters:
// float                                   PreviousValue                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnRep_Health(float PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_Health");

	Params::DFBaseCharacter_OnRep_Health Parms{};

	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_IsProne
// (Native, Protected)

void ADFBaseCharacter::OnRep_IsProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_IsProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_ItemEnabledMode
// (Native, Protected)
// Parameters:
// EDFItemEnabledMode                      PreviousItemEnabledMode                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnRep_ItemEnabledMode(EDFItemEnabledMode PreviousItemEnabledMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_ItemEnabledMode");

	Params::DFBaseCharacter_OnRep_ItemEnabledMode Parms{};

	Parms.PreviousItemEnabledMode = PreviousItemEnabledMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_LastTakeHitInfo
// (Final, Native, Protected)

void ADFBaseCharacter::OnRep_LastTakeHitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_LastTakeHitInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_ReplicatedLeanAmount
// (Native, Protected)
// Parameters:
// float                                   LastReplicatedLeanAmount                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnRep_ReplicatedLeanAmount(float LastReplicatedLeanAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_ReplicatedLeanAmount");

	Params::DFBaseCharacter_OnRep_ReplicatedLeanAmount Parms{};

	Parms.LastReplicatedLeanAmount = LastReplicatedLeanAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_ReplicatedStance
// (Native, Protected)

void ADFBaseCharacter::OnRep_ReplicatedStance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_ReplicatedStance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_TeamNum
// (Native, Protected)
// Parameters:
// uint8                                   LastTeamNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnRep_TeamNum(uint8 LastTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_TeamNum");

	Params::DFBaseCharacter_OnRep_TeamNum Parms{};

	Parms.LastTeamNum = LastTeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.OnRep_TeamState
// (Final, Native, Private)
// Parameters:
// class ADFTeamState*                     TeamStateBeforeUpdate                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::OnRep_TeamState(class ADFTeamState* TeamStateBeforeUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "OnRep_TeamState");

	Params::DFBaseCharacter_OnRep_TeamState Parms{};

	Parms.TeamStateBeforeUpdate = TeamStateBeforeUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterActionMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ActionMontageToPlay                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterActionMontage(class UAnimMontage* ActionMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterActionMontage");

	Params::DFBaseCharacter_PlayCharacterActionMontage Parms{};

	Parms.ActionMontageToPlay = ActionMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterCockMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     CockMontageToPlay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterCockMontage(class UAnimMontage* CockMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterCockMontage");

	Params::DFBaseCharacter_PlayCharacterCockMontage Parms{};

	Parms.CockMontageToPlay = CockMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterDeathMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterDeathMontage(bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterDeathMontage");

	Params::DFBaseCharacter_PlayCharacterDeathMontage Parms{};

	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterEndReloadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     EndReloadMontageToPlay                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterEndReloadMontage(class UAnimMontage* EndReloadMontageToPlay, bool bDryReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterEndReloadMontage");

	Params::DFBaseCharacter_PlayCharacterEndReloadMontage Parms{};

	Parms.EndReloadMontageToPlay = EndReloadMontageToPlay;
	Parms.bDryReload = bDryReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterEquipMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterEquipMontage(bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterEquipMontage");

	Params::DFBaseCharacter_PlayCharacterEquipMontage Parms{};

	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterFireMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     FireMontageToPlay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireLast                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireADS                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterFireMontage(class UAnimMontage* FireMontageToPlay, bool bFireLast, bool bFireADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterFireMontage");

	Params::DFBaseCharacter_PlayCharacterFireMontage Parms{};

	Parms.FireMontageToPlay = FireMontageToPlay;
	Parms.bFireLast = bFireLast;
	Parms.bFireADS = bFireADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     CharMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceDisableAutoBlendOut                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterMontage(class UAnimMontage* CharMontage, bool bForceDisableAutoBlendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterMontage");

	Params::DFBaseCharacter_PlayCharacterMontage Parms{};

	Parms.CharMontage = CharMontage;
	Parms.bForceDisableAutoBlendOut = bForceDisableAutoBlendOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterPerspectiveAnimation
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerspectiveAnim                 CharAnim                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceDisableAutoBlendOut                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterPerspectiveAnimation(struct FPerspectiveAnim& CharAnim, bool bForceDisableAutoBlendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterPerspectiveAnimation");

	Params::DFBaseCharacter_PlayCharacterPerspectiveAnimation Parms{};

	Parms.CharAnim = std::move(CharAnim);
	Parms.bForceDisableAutoBlendOut = bForceDisableAutoBlendOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterReloadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterReloadMontage(bool bDryReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterReloadMontage");

	Params::DFBaseCharacter_PlayCharacterReloadMontage Parms{};

	Parms.bDryReload = bDryReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterSound
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerspectiveSound                Sound                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ADFBaseCharacter::PlayCharacterSound(struct FPerspectiveSound& Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterSound");

	Params::DFBaseCharacter_PlayCharacterSound Parms{};

	Parms.Sound = std::move(Sound);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterStartReloadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     StartReloadMontageToPlay                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterStartReloadMontage(class UAnimMontage* StartReloadMontageToPlay, bool bDryReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterStartReloadMontage");

	Params::DFBaseCharacter_PlayCharacterStartReloadMontage Parms{};

	Parms.StartReloadMontageToPlay = StartReloadMontageToPlay;
	Parms.bDryReload = bDryReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterThrowOverhandMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ThrowOverhandMontageToPlay                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterThrowOverhandMontage(class UAnimMontage* ThrowOverhandMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterThrowOverhandMontage");

	Params::DFBaseCharacter_PlayCharacterThrowOverhandMontage Parms{};

	Parms.ThrowOverhandMontageToPlay = ThrowOverhandMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterThrowUnderhandMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ThrowUnderhandMontageToPlay                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterThrowUnderhandMontage(class UAnimMontage* ThrowUnderhandMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterThrowUnderhandMontage");

	Params::DFBaseCharacter_PlayCharacterThrowUnderhandMontage Parms{};

	Parms.ThrowUnderhandMontageToPlay = ThrowUnderhandMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.PlayCharacterUnEquipMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     UnEquipMontageToPlay                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseCharacter::PlayCharacterUnEquipMontage(class UAnimMontage* UnEquipMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "PlayCharacterUnEquipMontage");

	Params::DFBaseCharacter_PlayCharacterUnEquipMontage Parms{};

	Parms.UnEquipMontageToPlay = UnEquipMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.ProneToggle
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::ProneToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ProneToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ReceiveEquippedItemChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADFBaseItem*                      NewEquippedItem                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseItem*                      PrevEquippedItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceiveEquippedItemChanged(class ADFBaseItem* NewEquippedItem, class ADFBaseItem* PrevEquippedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveEquippedItemChanged");

	Params::DFBaseCharacter_ReceiveEquippedItemChanged Parms{};

	Parms.NewEquippedItem = NewEquippedItem;
	Parms.PrevEquippedItem = PrevEquippedItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveHealthChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewHealthTotal                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrevHealthTotal                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceiveHealthChanged(float NewHealthTotal, float PrevHealthTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveHealthChanged");

	Params::DFBaseCharacter_ReceiveHealthChanged Parms{};

	Parms.NewHealthTotal = NewHealthTotal;
	Parms.PrevHealthTotal = PrevHealthTotal;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnEndAim
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnEndAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnEndAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnEndLean
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnEndLean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnEndLean");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnEndProne
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   HalfHeightAdjust                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaledHalfHeightAdjust                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceiveOnEndProne(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnEndProne");

	Params::DFBaseCharacter_ReceiveOnEndProne Parms{};

	Parms.HalfHeightAdjust = HalfHeightAdjust;
	Parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnEndSprint
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnEndSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnEndSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnEndVault
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnEndVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnEndVault");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnRepPlayerState
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnRepPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnRepPlayerState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnStartAim
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnStartAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnStartAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnStartLean
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnStartLean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnStartLean");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnStartProne
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   HalfHeightAdjust                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaledHalfHeightAdjust                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceiveOnStartProne(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnStartProne");

	Params::DFBaseCharacter_ReceiveOnStartProne Parms{};

	Parms.HalfHeightAdjust = HalfHeightAdjust;
	Parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnStartSprint
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnStartSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnStartSprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveOnStartVault
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveOnStartVault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveOnStartVault");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.ReceivePawnTeamNumUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// uint8                                   LastTeamNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeamNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceivePawnTeamNumUpdated(uint8 LastTeamNum, uint8 NewTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceivePawnTeamNumUpdated");

	Params::DFBaseCharacter_ReceivePawnTeamNumUpdated Parms{};

	Parms.LastTeamNum = LastTeamNum;
	Parms.NewTeamNum = NewTeamNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceivePawnTeamStateUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADFTeamState*                     TeamStateBeforeUpdate                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFTeamState*                     NewTeamState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewTeamStateInit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceivePawnTeamStateUpdated(class ADFTeamState* TeamStateBeforeUpdate, class ADFTeamState* NewTeamState, bool bNewTeamStateInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceivePawnTeamStateUpdated");

	Params::DFBaseCharacter_ReceivePawnTeamStateUpdated Parms{};

	Parms.TeamStateBeforeUpdate = TeamStateBeforeUpdate;
	Parms.NewTeamState = NewTeamState;
	Parms.bNewTeamStateInit = bNewTeamStateInit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceivePlayHit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageTaken                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APawn*                            PawnInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKilled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ReceivePlayHit(float DamageTaken, struct FDamageEvent& DamageEvent, class APawn* PawnInstigator, class AActor* DamageCauser, bool bKilled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceivePlayHit");

	Params::DFBaseCharacter_ReceivePlayHit Parms{};

	Parms.DamageTaken = DamageTaken;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.PawnInstigator = PawnInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.bKilled = bKilled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseCharacter.ReceiveRestart
// (Event, Protected, BlueprintEvent)

void ADFBaseCharacter::ReceiveRestart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ReceiveRestart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseCharacter.Reload
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::Reload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Reload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ServerDoVault
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FDFVaultTraceData                VaultStartParams                                       (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ServerDoVault(struct FDFVaultTraceData& VaultStartParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ServerDoVault");

	Params::DFBaseCharacter_ServerDoVault Parms{};

	Parms.VaultStartParams = std::move(VaultStartParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ServerEquipItem
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class ADFBaseItem*                      ItemToEquip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::ServerEquipItem(class ADFBaseItem* ItemToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ServerEquipItem");

	Params::DFBaseCharacter_ServerEquipItem Parms{};

	Parms.ItemToEquip = ItemToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.ServerSuicide
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ADFBaseCharacter::ServerSuicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "ServerSuicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.SetHealth
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHealth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::SetHealth(float InHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "SetHealth");

	Params::DFBaseCharacter_SetHealth Parms{};

	Parms.InHealth = InHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.SetItemEnabledMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EDFItemEnabledMode                      ItemMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::SetItemEnabledMode(EDFItemEnabledMode ItemMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "SetItemEnabledMode");

	Params::DFBaseCharacter_SetItemEnabledMode Parms{};

	Parms.ItemMode = ItemMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.SetRagdollPhysics
// (Final, Native, Protected, BlueprintCallable)

void ADFBaseCharacter::SetRagdollPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "SetRagdollPhysics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.SpawnHitImpactFX
// (Final, BlueprintCosmetic, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DamageTaken                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APawn*                            PawnInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::SpawnHitImpactFX(float DamageTaken, struct FDamageEvent& DamageEvent, class APawn* PawnInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "SpawnHitImpactFX");

	Params::DFBaseCharacter_SpawnHitImpactFX Parms{};

	Parms.DamageTaken = DamageTaken;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.PawnInstigator = PawnInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.Sprint
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::Sprint(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Sprint");

	Params::DFBaseCharacter_Sprint Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.SprintToggle
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::SprintToggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "SprintToggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.StartFire
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::StartFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "StartFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.StopAllAnimMontages
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPerspectiveMeshOnly                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::StopAllAnimMontages(bool bPerspectiveMeshOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "StopAllAnimMontages");

	Params::DFBaseCharacter_StopAllAnimMontages Parms{};

	Parms.bPerspectiveMeshOnly = bPerspectiveMeshOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.StopCharacterMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     CharMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::StopCharacterMontage(class UAnimMontage* CharMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "StopCharacterMontage");

	Params::DFBaseCharacter_StopCharacterMontage Parms{};

	Parms.CharMontage = CharMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.StopCharacterPerspectiveAnimation
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerspectiveAnim                 CharAnim                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::StopCharacterPerspectiveAnimation(struct FPerspectiveAnim& CharAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "StopCharacterPerspectiveAnimation");

	Params::DFBaseCharacter_StopCharacterPerspectiveAnimation Parms{};

	Parms.CharAnim = std::move(CharAnim);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.StopFire
// (Final, Native, Public, BlueprintCallable)

void ADFBaseCharacter::StopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "StopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.StopVaulting
// (Native, Public, BlueprintCallable)

void ADFBaseCharacter::StopVaulting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "StopVaulting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.Suicide
// (Exec, Native, Public, BlueprintCallable)

void ADFBaseCharacter::Suicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Suicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.UnAim
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::UnAim(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "UnAim");

	Params::DFBaseCharacter_UnAim Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.UnLean
// (Native, Public, BlueprintCallable)
// Parameters:
// ELeanDirection                          UnDesiredLeanDir                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::UnLean(ELeanDirection UnDesiredLeanDir, bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "UnLean");

	Params::DFBaseCharacter_UnLean Parms{};

	Parms.UnDesiredLeanDir = UnDesiredLeanDir;
	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.UnSprint
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseCharacter::UnSprint(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "UnSprint");

	Params::DFBaseCharacter_UnSprint Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.Vault
// (Native, Public, BlueprintCallable)

void ADFBaseCharacter::Vault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "Vault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseCharacter.AllowsWeaponFire
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::AllowsWeaponFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "AllowsWeaponFire");

	Params::DFBaseCharacter_AllowsWeaponFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.CanAim
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::CanAim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CanAim");

	Params::DFBaseCharacter_CanAim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.CanDie
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   KillingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::CanDie(float KillingDamage, struct FDamageEvent& DamageEvent, class AController* Killer, class AActor* DamageCauser) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CanDie");

	Params::DFBaseCharacter_CanDie Parms{};

	Parms.KillingDamage = KillingDamage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.Killer = Killer;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.CanGoProne
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::CanGoProne() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CanGoProne");

	Params::DFBaseCharacter_CanGoProne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.CanLean
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanDirection                          DesiredLeanDir                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::CanLean(ELeanDirection DesiredLeanDir) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CanLean");

	Params::DFBaseCharacter_CanLean Parms{};

	Parms.DesiredLeanDir = DesiredLeanDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.CanSprint
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::CanSprint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CanSprint");

	Params::DFBaseCharacter_CanSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.CanVault
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::CanVault() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "CanVault");

	Params::DFBaseCharacter_CanVault Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetAimOffsets
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ADFBaseCharacter::GetAimOffsets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetAimOffsets");

	Params::DFBaseCharacter_GetAimOffsets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetAnimToUseFromPerspectiveAnimPair
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPerspectiveAnim                 AnimationPair                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* ADFBaseCharacter::GetAnimToUseFromPerspectiveAnimPair(struct FPerspectiveAnim& AnimationPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetAnimToUseFromPerspectiveAnimPair");

	Params::DFBaseCharacter_GetAnimToUseFromPerspectiveAnimPair Parms{};

	Parms.AnimationPair = std::move(AnimationPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetCharacterAnimTickOptionToUse
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bVisibleMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVisibilityBasedAnimTickOption          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVisibilityBasedAnimTickOption ADFBaseCharacter::GetCharacterAnimTickOptionToUse(bool bVisibleMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetCharacterAnimTickOptionToUse");

	Params::DFBaseCharacter_GetCharacterAnimTickOptionToUse Parms{};

	Parms.bVisibleMesh = bVisibleMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetCharacterDeathMontageToUse
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     OutCharDeathMontage                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::GetCharacterDeathMontageToUse(class UAnimMontage** OutCharDeathMontage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetCharacterDeathMontageToUse");

	Params::DFBaseCharacter_GetCharacterDeathMontageToUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCharDeathMontage != nullptr)
		*OutCharDeathMontage = Parms.OutCharDeathMontage;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetCharacterMeshToUse
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreLocalControlOnServer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADFBaseCharacter::GetCharacterMeshToUse(bool bIgnoreLocalControlOnServer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetCharacterMeshToUse");

	Params::DFBaseCharacter_GetCharacterMeshToUse Parms{};

	Parms.bIgnoreLocalControlOnServer = bIgnoreLocalControlOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetDamageMultiplierByBoneName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageMultiplier                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::GetDamageMultiplierByBoneName(class FName& BoneName, float* DamageMultiplier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetDamageMultiplierByBoneName");

	Params::DFBaseCharacter_GetDamageMultiplierByBoneName Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DamageMultiplier != nullptr)
		*DamageMultiplier = Parms.DamageMultiplier;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetEquippedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseItem*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseItem* ADFBaseCharacter::GetEquippedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetEquippedItem");

	Params::DFBaseCharacter_GetEquippedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDFInventoryComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFInventoryComponent* ADFBaseCharacter::GetInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetInventory");

	Params::DFBaseCharacter_GetInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetItemAttachPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADFBaseCharacter::GetItemAttachPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetItemAttachPoint");

	Params::DFBaseCharacter_GetItemAttachPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetItemEnabledMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDFItemEnabledMode                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDFItemEnabledMode ADFBaseCharacter::GetItemEnabledMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetItemEnabledMode");

	Params::DFBaseCharacter_GetItemEnabledMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetMontageToUseFromPerspectiveAnimPair
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPerspectiveAnim                 AnimationPair                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ADFBaseCharacter::GetMontageToUseFromPerspectiveAnimPair(struct FPerspectiveAnim& AnimationPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetMontageToUseFromPerspectiveAnimPair");

	Params::DFBaseCharacter_GetMontageToUseFromPerspectiveAnimPair Parms{};

	Parms.AnimationPair = std::move(AnimationPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.GetRelevantEquippedItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseItem*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseItem* ADFBaseCharacter::GetRelevantEquippedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "GetRelevantEquippedItem");

	Params::DFBaseCharacter_GetRelevantEquippedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsAlive");

	Params::DFBaseCharacter_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsEquipped");

	Params::DFBaseCharacter_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsFiring
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsFiring");

	Params::DFBaseCharacter_IsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsLeaning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsLeaning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsLeaning");

	Params::DFBaseCharacter_IsLeaning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsPerspectiveMesh
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshCompToCheck                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsPerspectiveMesh(class USkeletalMeshComponent* MeshCompToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsPerspectiveMesh");

	Params::DFBaseCharacter_IsPerspectiveMesh Parms{};

	Parms.MeshCompToCheck = MeshCompToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsPlayer
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsPlayer");

	Params::DFBaseCharacter_IsPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseCharacter.IsPrefiring
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseCharacter::IsPrefiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseCharacter", "IsPrefiring");

	Params::DFBaseCharacter_IsPrefiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.AddBot
// (Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   PlayerTeamID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* ADFBaseGameMode::AddBot(uint8 PlayerTeamID, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "AddBot");

	Params::DFBaseGameMode_AddBot Parms{};

	Parms.PlayerTeamID = PlayerTeamID;
	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.AddBots
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::AddBots(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "AddBots");

	Params::DFBaseGameMode_AddBots Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.AddNamedBot
// (Exec, Native, Public)
// Parameters:
// class FString                           BotName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::AddNamedBot(const class FString& BotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "AddNamedBot");

	Params::DFBaseGameMode_AddNamedBot Parms{};

	Parms.BotName = std::move(BotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.AddTeamBots
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::AddTeamBots(uint8 TeamId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "AddTeamBots");

	Params::DFBaseGameMode_AddTeamBots Parms{};

	Parms.TeamId = TeamId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.AssignTeam
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      ForController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   AssignedTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::AssignTeam(class AController* ForController, uint8 AssignedTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "AssignTeam");

	Params::DFBaseGameMode_AssignTeam Parms{};

	Parms.ForController = ForController;
	Parms.AssignedTeam = AssignedTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.AutofillWithBots
// (Native, Public, BlueprintCallable)

void ADFBaseGameMode::AutofillWithBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "AutofillWithBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.BanPlayerById
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   BannedPlayerId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             BanReason                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   BanDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::BanPlayerById(int32 BannedPlayerId, class FText& BanReason, float BanDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "BanPlayerById");

	Params::DFBaseGameMode_BanPlayerById Parms{};

	Parms.BannedPlayerId = BannedPlayerId;
	Parms.BanReason = BanReason;
	Parms.BanDuration = BanDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.BanPlayerByName
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           BannedPlayerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             BanReason                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   BanDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::BanPlayerByName(const class FString& BannedPlayerName, class FText& BanReason, float BanDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "BanPlayerByName");

	Params::DFBaseGameMode_BanPlayerByName Parms{};

	Parms.BannedPlayerName = std::move(BannedPlayerName);
	Parms.BanReason = BanReason;
	Parms.BanDuration = BanDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.CheckRulesetWinConditions
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::CheckRulesetWinConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "CheckRulesetWinConditions");

	Params::DFBaseGameMode_CheckRulesetWinConditions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.CheckWinConditions
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::CheckWinConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "CheckWinConditions");

	Params::DFBaseGameMode_CheckWinConditions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ChooseSpawnPointFromPlayerStart
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           StartSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnPointDef                   OutChosenSpawnPoint                                    (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      OutCollisionHandlingMethod                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::ChooseSpawnPointFromPlayerStart(class AController* Player, class AActor* StartSpot, struct FSpawnPointDef* OutChosenSpawnPoint, ESpawnActorCollisionHandlingMethod* OutCollisionHandlingMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ChooseSpawnPointFromPlayerStart");

	Params::DFBaseGameMode_ChooseSpawnPointFromPlayerStart Parms{};

	Parms.Player = Player;
	Parms.StartSpot = StartSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutChosenSpawnPoint != nullptr)
		*OutChosenSpawnPoint = std::move(Parms.OutChosenSpawnPoint);

	if (OutCollisionHandlingMethod != nullptr)
		*OutCollisionHandlingMethod = Parms.OutCollisionHandlingMethod;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.CreateTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDFTeamDefinition*                NewTeamDef                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeamIdToUse                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFTeamState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFTeamState* ADFBaseGameMode::CreateTeam(class UDFTeamDefinition* NewTeamDef, uint8 NewTeamIdToUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "CreateTeam");

	Params::DFBaseGameMode_CreateTeam Parms{};

	Parms.NewTeamDef = NewTeamDef;
	Parms.NewTeamIdToUse = NewTeamIdToUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.DetermineMatchWinner
// (Native, Event, Protected, BlueprintEvent)

void ADFBaseGameMode::DetermineMatchWinner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "DetermineMatchWinner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.DumpActiveRulesets
// (Final, Exec, Native, Public, BlueprintCallable)

void ADFBaseGameMode::DumpActiveRulesets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "DumpActiveRulesets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.FindPlayerStartTransform
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutFoundSpawnTransform                                 (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           IncomingName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::FindPlayerStartTransform(class AController* Player, struct FTransform* OutFoundSpawnTransform, const class FString& IncomingName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "FindPlayerStartTransform");

	Params::DFBaseGameMode_FindPlayerStartTransform Parms{};

	Parms.Player = Player;
	Parms.IncomingName = std::move(IncomingName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFoundSpawnTransform != nullptr)
		*OutFoundSpawnTransform = std::move(Parms.OutFoundSpawnTransform);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ForceTeam
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SwitchedPlayerName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamIdToAssign                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::ForceTeam(const class FString& SwitchedPlayerName, uint8 TeamIdToAssign)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ForceTeam");

	Params::DFBaseGameMode_ForceTeam Parms{};

	Parms.SwitchedPlayerName = std::move(SwitchedPlayerName);
	Parms.TeamIdToAssign = TeamIdToAssign;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ForceTeamId
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SwitchedPlayerId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamIdToAssign                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::ForceTeamId(int32 SwitchedPlayerId, uint8 TeamIdToAssign)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ForceTeamId");

	Params::DFBaseGameMode_ForceTeamId Parms{};

	Parms.SwitchedPlayerId = SwitchedPlayerId;
	Parms.TeamIdToAssign = TeamIdToAssign;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.GetTotalNumPlayers
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIncludeTravellingPlayers                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseGameMode::GetTotalNumPlayers(bool bIncludeTravellingPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "GetTotalNumPlayers");

	Params::DFBaseGameMode_GetTotalNumPlayers Parms{};

	Parms.bIncludeTravellingPlayers = bIncludeTravellingPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.KickPlayerById
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   KickedPlayerId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             KickReason                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::KickPlayerById(int32 KickedPlayerId, class FText& KickReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "KickPlayerById");

	Params::DFBaseGameMode_KickPlayerById Parms{};

	Parms.KickedPlayerId = KickedPlayerId;
	Parms.KickReason = KickReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.KickPlayerByName
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           KickedPlayerName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             KickReason                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::KickPlayerByName(const class FString& KickedPlayerName, class FText& KickReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "KickPlayerByName");

	Params::DFBaseGameMode_KickPlayerByName Parms{};

	Parms.KickedPlayerName = std::move(KickedPlayerName);
	Parms.KickReason = KickReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.NextMap
// (Final, Exec, Native, Public)

void ADFBaseGameMode::NextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "NextMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.PlayerBotCanRestart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAIController*                    Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::PlayerBotCanRestart(class AAIController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "PlayerBotCanRestart");

	Params::DFBaseGameMode_PlayerBotCanRestart Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.PlayerCanRestartGeneric
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::PlayerCanRestartGeneric(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "PlayerCanRestartGeneric");

	Params::DFBaseGameMode_PlayerCanRestartGeneric Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ReceiveOnLeavingMap
// (Event, Protected, BlueprintEvent)

void ADFBaseGameMode::ReceiveOnLeavingMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ReceiveOnLeavingMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGameMode.ReceiveOnMatchAborted
// (Event, Protected, BlueprintEvent)

void ADFBaseGameMode::ReceiveOnMatchAborted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ReceiveOnMatchAborted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGameMode.ReceiveOnMatchHasEnded
// (Event, Protected, BlueprintEvent)

void ADFBaseGameMode::ReceiveOnMatchHasEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ReceiveOnMatchHasEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGameMode.ReceiveOnMatchHasStarted
// (Event, Protected, BlueprintEvent)

void ADFBaseGameMode::ReceiveOnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ReceiveOnMatchHasStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGameMode.ReceiveOnMatchIsWaitingToStart
// (Event, Protected, BlueprintEvent)

void ADFBaseGameMode::ReceiveOnMatchIsWaitingToStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ReceiveOnMatchIsWaitingToStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGameMode.ReceiveOnSwapAIControllers
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AAIController*                    OldAIC                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    NewAIC                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::ReceiveOnSwapAIControllers(class AAIController* OldAIC, class AAIController* NewAIC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ReceiveOnSwapAIControllers");

	Params::DFBaseGameMode_ReceiveOnSwapAIControllers Parms{};

	Parms.OldAIC = OldAIC;
	Parms.NewAIC = NewAIC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseGameMode.RegisterSignificantActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToRegister                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::RegisterSignificantActor(class AActor* ActorToRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RegisterSignificantActor");

	Params::DFBaseGameMode_RegisterSignificantActor Parms{};

	Parms.ActorToRegister = ActorToRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemoveAllBots
// (Exec, Native, Public, BlueprintCallable)

void ADFBaseGameMode::RemoveAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveAllBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemoveBot
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     BotPS                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::RemoveBot(class APlayerState* BotPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveBot");

	Params::DFBaseGameMode_RemoveBot Parms{};

	Parms.BotPS = BotPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.RemoveBotByName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::RemoveBotByName(const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveBotByName");

	Params::DFBaseGameMode_RemoveBotByName Parms{};

	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.RemoveNewestBot
// (Final, Native, Public, BlueprintCallable)

void ADFBaseGameMode::RemoveNewestBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveNewestBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemoveNewestPlayer
// (Final, Native, Public, BlueprintCallable)

void ADFBaseGameMode::RemoveNewestPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveNewestPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemoveOldestBot
// (Final, Native, Public, BlueprintCallable)

void ADFBaseGameMode::RemoveOldestBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveOldestBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemoveOldestPlayer
// (Final, Native, Public, BlueprintCallable)

void ADFBaseGameMode::RemoveOldestPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveOldestPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemovePlayerByAge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewest                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExcludeBots                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExcludeHumans                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::RemovePlayerByAge(bool bNewest, bool bExcludeBots, bool bExcludeHumans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemovePlayerByAge");

	Params::DFBaseGameMode_RemovePlayerByAge Parms{};

	Parms.bNewest = bNewest;
	Parms.bExcludeBots = bExcludeBots;
	Parms.bExcludeHumans = bExcludeHumans;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.RemoveTeamBots
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::RemoveTeamBots(uint8 TeamId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "RemoveTeamBots");

	Params::DFBaseGameMode_RemoveTeamBots Parms{};

	Parms.TeamId = TeamId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.SignificantActorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           RemovedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::SignificantActorEndPlay(class AActor* RemovedActor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "SignificantActorEndPlay");

	Params::DFBaseGameMode_SignificantActorEndPlay Parms{};

	Parms.RemovedActor = RemovedActor;
	Parms.EndPlayReason = EndPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.SwitchToNextMap
// (Native, Public, BlueprintCallable)

void ADFBaseGameMode::SwitchToNextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "SwitchToNextMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.UnregisterSignificantActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToRemove                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::UnregisterSignificantActor(class AActor* ActorToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "UnregisterSignificantActor");

	Params::DFBaseGameMode_UnregisterSignificantActor Parms{};

	Parms.ActorToRemove = ActorToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.UpdatePlayerGameplayMuteStates
// (Native, Protected, BlueprintCallable)
// Parameters:
// class ADFBasePlayerController*          ForPlayerController                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameMode::UpdatePlayerGameplayMuteStates(class ADFBasePlayerController* ForPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "UpdatePlayerGameplayMuteStates");

	Params::DFBaseGameMode_UpdatePlayerGameplayMuteStates Parms{};

	Parms.ForPlayerController = ForPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameMode.CanAddRuleset
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TSubclassOf<class UDFGameRulesetBase>   RulesetClassToAdd                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RulesetDenialReason                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::CanAddRuleset(TSubclassOf<class UDFGameRulesetBase>* RulesetClassToAdd, class FString* RulesetDenialReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "CanAddRuleset");

	Params::DFBaseGameMode_CanAddRuleset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RulesetClassToAdd != nullptr)
		*RulesetClassToAdd = Parms.RulesetClassToAdd;

	if (RulesetDenialReason != nullptr)
		*RulesetDenialReason = std::move(Parms.RulesetDenialReason);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.CanDealDamage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ADFBasePlayerState*               DamageInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBasePlayerState*               DamagedPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::CanDealDamage(class ADFBasePlayerState* DamageInstigator, class ADFBasePlayerState* DamagedPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "CanDealDamage");

	Params::DFBaseGameMode_CanDealDamage Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.DamagedPlayer = DamagedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.CanRegisterSignificantActor
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           ActorToRegister                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActorDenialReason                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::CanRegisterSignificantActor(class AActor* ActorToRegister, class FString* ActorDenialReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "CanRegisterSignificantActor");

	Params::DFBaseGameMode_CanRegisterSignificantActor Parms{};

	Parms.ActorToRegister = ActorToRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActorDenialReason != nullptr)
		*ActorDenialReason = std::move(Parms.ActorDenialReason);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ChooseTeam
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ADFBasePlayerState*               ForPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ADFBaseGameMode::ChooseTeam(class ADFBasePlayerState* ForPlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ChooseTeam");

	Params::DFBaseGameMode_ChooseTeam Parms{};

	Parms.ForPlayerState = ForPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.GetAutoAssignHumanTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ADFBaseGameMode::GetAutoAssignHumanTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "GetAutoAssignHumanTeam");

	Params::DFBaseGameMode_GetAutoAssignHumanTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.GetNextGameName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADFBaseGameMode::GetNextGameName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "GetNextGameName");

	Params::DFBaseGameMode_GetNextGameName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.GetNextMapName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADFBaseGameMode::GetNextMapName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "GetNextMapName");

	Params::DFBaseGameMode_GetNextMapName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.GetNumPlayersOnTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerKind                             PlayerType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseGameMode::GetNumPlayersOnTeam(uint8 TeamId, EPlayerKind PlayerType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "GetNumPlayersOnTeam");

	Params::DFBaseGameMode_GetNumPlayersOnTeam Parms{};

	Parms.TeamId = TeamId;
	Parms.PlayerType = PlayerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.IsFriendlyFireEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::IsFriendlyFireEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "IsFriendlyFireEnabled");

	Params::DFBaseGameMode_IsFriendlyFireEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.IsHibernating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::IsHibernating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "IsHibernating");

	Params::DFBaseGameMode_IsHibernating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.IsMatchWinner
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class ADFBasePlayerState*               PlayerStateToCheck                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::IsMatchWinner(class ADFBasePlayerState* PlayerStateToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "IsMatchWinner");

	Params::DFBaseGameMode_IsMatchWinner Parms{};

	Parms.PlayerStateToCheck = PlayerStateToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.IsValidTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::IsValidTeamId(uint8 TeamId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "IsValidTeamId");

	Params::DFBaseGameMode_IsValidTeamId Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ModifyDamage
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseGameMode::ModifyDamage(float Damage, class AActor* DamagedActor, struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ModifyDamage");

	Params::DFBaseGameMode_ModifyDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamagedActor = DamagedActor;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ShouldBotAutofill
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::ShouldBotAutofill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ShouldBotAutofill");

	Params::DFBaseGameMode_ShouldBotAutofill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ShouldGameplayMuteRemotePlayer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ADFBasePlayerController*          ForPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBasePlayerController*          PlayerToCheck                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::ShouldGameplayMuteRemotePlayer(class ADFBasePlayerController* ForPlayer, class ADFBasePlayerController* PlayerToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ShouldGameplayMuteRemotePlayer");

	Params::DFBaseGameMode_ShouldGameplayMuteRemotePlayer Parms{};

	Parms.ForPlayer = ForPlayer;
	Parms.PlayerToCheck = PlayerToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameMode.ShouldHibernate
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameMode::ShouldHibernate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameMode", "ShouldHibernate");

	Params::DFBaseGameMode_ShouldHibernate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFNetworkEventSubsystem.Get
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFNetworkEventSubsystem*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFNetworkEventSubsystem* UDFNetworkEventSubsystem::Get(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFNetworkEventSubsystem", "Get");

	Params::DFNetworkEventSubsystem_Get Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DonkehFramework.DFNetworkEventSubsystem.OnGameStateEventDynamic__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AGameStateBase*                   GameState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFNetworkEventSubsystem::OnGameStateEventDynamic__DelegateSignature(class AGameStateBase* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFNetworkEventSubsystem", "OnGameStateEventDynamic__DelegateSignature");

	Params::DFNetworkEventSubsystem_OnGameStateEventDynamic__DelegateSignature Parms{};

	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseGameInstance.DumpOnlineSessionState
// (Final, Exec, Native, Private)

void UDFBaseGameInstance::DumpOnlineSessionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "DumpOnlineSessionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.FindGames
// (Native, Public, BlueprintCallable)
// Parameters:
// ESessionSearchPresenceType              SearchPresenceType                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::FindGames(ESessionSearchPresenceType SearchPresenceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "FindGames");

	Params::DFBaseGameInstance_FindGames Parms{};

	Parms.SearchPresenceType = SearchPresenceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.ForceUpdateSession
// (Final, Exec, Native, Private)

void UDFBaseGameInstance::ForceUpdateSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "ForceUpdateSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.HostGame
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TravelURL                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLANGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPlayers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HostName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::HostGame(const class FString& TravelURL, bool bLANGame, int32 MaxPlayers, const class FString& HostName, const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "HostGame");

	Params::DFBaseGameInstance_HostGame Parms{};

	Parms.TravelURL = std::move(TravelURL);
	Parms.bLANGame = bLANGame;
	Parms.MaxPlayers = MaxPlayers;
	Parms.HostName = std::move(HostName);
	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.JoinGame
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SearchResultIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           JoinPassword                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::JoinGame(int32 SearchResultIndex, const class FString& JoinPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "JoinGame");

	Params::DFBaseGameInstance_JoinGame Parms{};

	Parms.SearchResultIndex = SearchResultIndex;
	Parms.JoinPassword = std::move(JoinPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.JoinGameByIP
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           IPAddress                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           JoinPassword                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::JoinGameByIP(const class FString& IPAddress, const class FString& JoinPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "JoinGameByIP");

	Params::DFBaseGameInstance_JoinGameByIP Parms{};

	Parms.IPAddress = std::move(IPAddress);
	Parms.JoinPassword = std::move(JoinPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.OnNetworkFailure
// (Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNetDriver*                       NetDriver                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::OnNetworkFailure(class UWorld* World, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "OnNetworkFailure");

	Params::DFBaseGameInstance_OnNetworkFailure Parms{};

	Parms.World = World;
	Parms.NetDriver = NetDriver;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.OnNetworkLagStateChanged
// (Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNetDriver*                       NetDriver                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetworkLagState                        LagType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::OnNetworkLagStateChanged(class UWorld* World, class UNetDriver* NetDriver, ENetworkLagState LagType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "OnNetworkLagStateChanged");

	Params::DFBaseGameInstance_OnNetworkLagStateChanged Parms{};

	Parms.World = World;
	Parms.NetDriver = NetDriver;
	Parms.LagType = LagType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.OnTravelFailure
// (Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelFailure                          FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBaseGameInstance::OnTravelFailure(class UWorld* World, ETravelFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "OnTravelFailure");

	Params::DFBaseGameInstance_OnTravelFailure Parms{};

	Parms.World = World;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameInstance.IsHibernating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBaseGameInstance::IsHibernating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "IsHibernating");

	Params::DFBaseGameInstance_IsHibernating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameInstance.ProjectVersion
// (Final, Exec, Native, Private, Const)

void UDFBaseGameInstance::ProjectVersion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameInstance", "ProjectVersion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameState.OnRep_NumTeams
// (Final, Native, Private)

void ADFBaseGameState::OnRep_NumTeams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "OnRep_NumTeams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameState.OnRep_ReplicatedRemainingTime
// (Native, Protected)

void ADFBaseGameState::OnRep_ReplicatedRemainingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "OnRep_ReplicatedRemainingTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameState.SetRemainingTime
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewRemainingTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameState::SetRemainingTime(int32 NewRemainingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "SetRemainingTime");

	Params::DFBaseGameState_SetRemainingTime Parms{};

	Parms.NewRemainingTime = NewRemainingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameState.SetTimerPauseState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewPauseState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGameState::SetTimerPauseState(bool bNewPauseState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "SetTimerPauseState");

	Params::DFBaseGameState_SetTimerPauseState Parms{};

	Parms.bNewPauseState = bNewPauseState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGameState.GetGameStateVotingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDFVotingComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFVotingComponent* ADFBaseGameState::GetGameStateVotingComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "GetGameStateVotingComponent");

	Params::DFBaseGameState_GetGameStateVotingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameState.GetTeamStateById
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   TeamIdNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFTeamState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFTeamState* ADFBaseGameState::GetTeamStateById(uint8 TeamIdNum) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "GetTeamStateById");

	Params::DFBaseGameState_GetTeamStateById Parms{};

	Parms.TeamIdNum = TeamIdNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGameState.IsValidTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGameState::IsValidTeamId(uint8 TeamId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGameState", "IsValidTeamId");

	Params::DFBaseGameState_IsValidTeamId Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.HandleFire
// (Native, Protected, BlueprintCallable)

void ADFBaseWeapon::HandleFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "HandleFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.OnRep_bPrefiring
// (Final, Native, Protected)

void ADFBaseWeapon::OnRep_bPrefiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "OnRep_bPrefiring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.OnRep_FireCounter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FRepShotInfo                     PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADFBaseWeapon::OnRep_FireCounter(struct FRepShotInfo& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "OnRep_FireCounter");

	Params::DFBaseWeapon_OnRep_FireCounter Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.OnStartFiring
// (Native, Protected, BlueprintCallable)

void ADFBaseWeapon::OnStartFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "OnStartFiring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.OnStopFiring
// (Native, Protected, BlueprintCallable)

void ADFBaseWeapon::OnStopFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "OnStopFiring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.PlayActionAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseWeapon::PlayActionAnimations(bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayActionAnimations");

	Params::DFBaseWeapon_PlayActionAnimations Parms{};

	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.PlayCockAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayCockAnimations(bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayCockAnimations");

	Params::DFBaseWeapon_PlayCockAnimations Parms{};

	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayThrowAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOverhandThrow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayThrowAnimations(bool bOverhandThrow, bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayThrowAnimations");

	Params::DFBaseWeapon_PlayThrowAnimations Parms{};

	Parms.bOverhandThrow = bOverhandThrow;
	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponActionMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ActionMontageToPlay                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponActionMontage(class UAnimMontage* ActionMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponActionMontage");

	Params::DFBaseWeapon_PlayWeaponActionMontage Parms{};

	Parms.ActionMontageToPlay = ActionMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponCockMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     CockMontageToPlay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponCockMontage(class UAnimMontage* CockMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponCockMontage");

	Params::DFBaseWeapon_PlayWeaponCockMontage Parms{};

	Parms.CockMontageToPlay = CockMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponEquipMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     EquipMontageToPlay                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponEquipMontage(class UAnimMontage* EquipMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponEquipMontage");

	Params::DFBaseWeapon_PlayWeaponEquipMontage Parms{};

	Parms.EquipMontageToPlay = EquipMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponFireMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     FireMontageToPlay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireLast                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireADS                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponFireMontage(class UAnimMontage* FireMontageToPlay, bool bFireLast, bool bFireADS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponFireMontage");

	Params::DFBaseWeapon_PlayWeaponFireMontage Parms{};

	Parms.FireMontageToPlay = FireMontageToPlay;
	Parms.bFireLast = bFireLast;
	Parms.bFireADS = bFireADS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     WeapMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceDisableAutoBlendOut                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponMontage(class UAnimMontage* WeapMontage, bool bForceDisableAutoBlendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponMontage");

	Params::DFBaseWeapon_PlayWeaponMontage Parms{};

	Parms.WeapMontage = WeapMontage;
	Parms.bForceDisableAutoBlendOut = bForceDisableAutoBlendOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponPerspectiveAnimation
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerspectiveAnim                 WeapAnim                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponPerspectiveAnimation(struct FPerspectiveAnim& WeapAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponPerspectiveAnimation");

	Params::DFBaseWeapon_PlayWeaponPerspectiveAnimation Parms{};

	Parms.WeapAnim = std::move(WeapAnim);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponSound
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerspectiveSound                Sound                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ADFBaseWeapon::PlayWeaponSound(struct FPerspectiveSound& Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponSound");

	Params::DFBaseWeapon_PlayWeaponSound Parms{};

	Parms.Sound = std::move(Sound);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponThrowOverhandMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ThrowOverhandMontageToPlay                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponThrowOverhandMontage(class UAnimMontage* ThrowOverhandMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponThrowOverhandMontage");

	Params::DFBaseWeapon_PlayWeaponThrowOverhandMontage Parms{};

	Parms.ThrowOverhandMontageToPlay = ThrowOverhandMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponThrowUnderhandMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     ThrowUnderhandMontageToPlay                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponThrowUnderhandMontage(class UAnimMontage* ThrowUnderhandMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponThrowUnderhandMontage");

	Params::DFBaseWeapon_PlayWeaponThrowUnderhandMontage Parms{};

	Parms.ThrowUnderhandMontageToPlay = ThrowUnderhandMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PlayWeaponUnEquipMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     UnEquipMontageToPlay                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::PlayWeaponUnEquipMontage(class UAnimMontage* UnEquipMontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PlayWeaponUnEquipMontage");

	Params::DFBaseWeapon_PlayWeaponUnEquipMontage Parms{};

	Parms.UnEquipMontageToPlay = UnEquipMontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.PrefireDelayElapsed
// (Native, Protected)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseWeapon::PrefireDelayElapsed(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "PrefireDelayElapsed");

	Params::DFBaseWeapon_PrefireDelayElapsed Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.ReceiveFire
// (Event, Protected, BlueprintEvent)

void ADFBaseWeapon::ReceiveFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ReceiveFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseWeapon.ReceiveOnStartFiring
// (Event, Protected, BlueprintEvent)

void ADFBaseWeapon::ReceiveOnStartFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ReceiveOnStartFiring");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseWeapon.ReceiveOnStopFiring
// (Event, Protected, BlueprintEvent)

void ADFBaseWeapon::ReceiveOnStopFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ReceiveOnStopFiring");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseWeapon.ReceiveSimulateWeaponFire
// (Event, Protected, BlueprintEvent)

void ADFBaseWeapon::ReceiveSimulateWeaponFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ReceiveSimulateWeaponFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseWeapon.ReceiveStopSimulatingWeaponFire
// (Event, Protected, BlueprintEvent)

void ADFBaseWeapon::ReceiveStopSimulatingWeaponFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ReceiveStopSimulatingWeaponFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseWeapon.ServerFireShot
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              Origin                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ShootDir                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandomSeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ShotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseWeapon::ServerFireShot(struct FVector_NetQuantize& Origin, struct FVector_NetQuantizeNormal& ShootDir, int32 RandomSeed, float Timestamp, int32 ShotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ServerFireShot");

	Params::DFBaseWeapon_ServerFireShot Parms{};

	Parms.Origin = std::move(Origin);
	Parms.ShootDir = std::move(ShootDir);
	Parms.RandomSeed = RandomSeed;
	Parms.Timestamp = Timestamp;
	Parms.ShotID = ShotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.ServerPreFire
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADFBaseWeapon::ServerPreFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ServerPreFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.SimulateWeaponFire
// (Native, Protected, BlueprintCallable)

void ADFBaseWeapon::SimulateWeaponFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "SimulateWeaponFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.StopSimulatingWeaponFire
// (Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bForceStopAll                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseWeapon::StopSimulatingWeaponFire(bool bForceStopAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "StopSimulatingWeaponFire");

	Params::DFBaseWeapon_StopSimulatingWeaponFire Parms{};

	Parms.bForceStopAll = bForceStopAll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.StopWeaponMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     WeapMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseWeapon::StopWeaponMontage(class UAnimMontage* WeapMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "StopWeaponMontage");

	Params::DFBaseWeapon_StopWeaponMontage Parms{};

	Parms.WeapMontage = WeapMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.StopWeaponPerspectiveAnimation
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPerspectiveAnim                 WeapAnim                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseWeapon::StopWeaponPerspectiveAnimation(struct FPerspectiveAnim& WeapAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "StopWeaponPerspectiveAnimation");

	Params::DFBaseWeapon_StopWeaponPerspectiveAnimation Parms{};

	Parms.WeapAnim = std::move(WeapAnim);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseWeapon.GetAnimPlayLengthToUseFromPerspectiveAnimPair
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPerspectiveAnim                 AnimationPair                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::GetAnimPlayLengthToUseFromPerspectiveAnimPair(struct FPerspectiveAnim& AnimationPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetAnimPlayLengthToUseFromPerspectiveAnimPair");

	Params::DFBaseWeapon_GetAnimPlayLengthToUseFromPerspectiveAnimPair Parms{};

	Parms.AnimationPair = std::move(AnimationPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.GetAnimToUseFromPerspectiveAnimPair
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPerspectiveAnim                 AnimationPair                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* ADFBaseWeapon::GetAnimToUseFromPerspectiveAnimPair(struct FPerspectiveAnim& AnimationPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetAnimToUseFromPerspectiveAnimPair");

	Params::DFBaseWeapon_GetAnimToUseFromPerspectiveAnimPair Parms{};

	Parms.AnimationPair = std::move(AnimationPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.GetMontagePlayLengthToUseFromPerspectiveAnimPair
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPerspectiveAnim                 AnimationPair                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseWeapon::GetMontagePlayLengthToUseFromPerspectiveAnimPair(struct FPerspectiveAnim& AnimationPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetMontagePlayLengthToUseFromPerspectiveAnimPair");

	Params::DFBaseWeapon_GetMontagePlayLengthToUseFromPerspectiveAnimPair Parms{};

	Parms.AnimationPair = std::move(AnimationPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.GetMontageToUseFromPerspectiveAnimPair
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPerspectiveAnim                 AnimationPair                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ADFBaseWeapon::GetMontageToUseFromPerspectiveAnimPair(struct FPerspectiveAnim& AnimationPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetMontageToUseFromPerspectiveAnimPair");

	Params::DFBaseWeapon_GetMontageToUseFromPerspectiveAnimPair Parms{};

	Parms.AnimationPair = std::move(AnimationPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.GetWeaponMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADFBaseWeapon::GetWeaponMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetWeaponMesh");

	Params::DFBaseWeapon_GetWeaponMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.GetWeaponMesh1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADFBaseWeapon::GetWeaponMesh1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetWeaponMesh1P");

	Params::DFBaseWeapon_GetWeaponMesh1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.GetWeaponMeshToUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreLocalControlOnServer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADFBaseWeapon::GetWeaponMeshToUse(bool bIgnoreLocalControlOnServer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "GetWeaponMeshToUse");

	Params::DFBaseWeapon_GetWeaponMeshToUse Parms{};

	Parms.bIgnoreLocalControlOnServer = bIgnoreLocalControlOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.IsFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseWeapon::IsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "IsFiring");

	Params::DFBaseWeapon_IsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseWeapon.ShouldSimulateWeaponFire
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseWeapon::ShouldSimulateWeaponFire() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseWeapon", "ShouldSimulateWeaponFire");

	Params::DFBaseWeapon_ShouldSimulateWeaponFire Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.ClientRejectFiredShot
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                                   ShotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseAmmoClip*                  ShotAmmoClip                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ServerClipAmmo                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::ClientRejectFiredShot(int32 ShotID, class ADFBaseAmmoClip* ShotAmmoClip, int32 ServerClipAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ClientRejectFiredShot");

	Params::DFBaseGun_ClientRejectFiredShot Parms{};

	Parms.ShotID = ShotID;
	Parms.ShotAmmoClip = ShotAmmoClip;
	Parms.ServerClipAmmo = ServerClipAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.LoadAmmoClip
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseAmmoClip*                  ClipToLoad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::LoadAmmoClip(class ADFBaseAmmoClip* ClipToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "LoadAmmoClip");

	Params::DFBaseGun_LoadAmmoClip Parms{};

	Parms.ClipToLoad = ClipToLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.LoadNextAmmoClip
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ADFBaseGun::LoadNextAmmoClip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "LoadNextAmmoClip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.LoadPreviousAmmoClip
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ADFBaseGun::LoadPreviousAmmoClip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "LoadPreviousAmmoClip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.OnReload
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::OnReload(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "OnReload");

	Params::DFBaseGun_OnReload Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.OnRep_CurrentAmmoClip
// (Native, Public)
// Parameters:
// class ADFBaseAmmoClip*                  PrevAmmoClip                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::OnRep_CurrentAmmoClip(class ADFBaseAmmoClip* PrevAmmoClip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "OnRep_CurrentAmmoClip");

	Params::DFBaseGun_OnRep_CurrentAmmoClip Parms{};

	Parms.PrevAmmoClip = PrevAmmoClip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.OnRep_PendingReloadState
// (Native, Public)
// Parameters:
// EGunReloadState                         PrevReloadState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::OnRep_PendingReloadState(EGunReloadState PrevReloadState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "OnRep_PendingReloadState");

	Params::DFBaseGun_OnRep_PendingReloadState Parms{};

	Parms.PrevReloadState = PrevReloadState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.OnRep_SelectedFireMode
// (Native, Protected)
// Parameters:
// EFireMode                               PrevSelectedFireMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::OnRep_SelectedFireMode(EFireMode PrevSelectedFireMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "OnRep_SelectedFireMode");

	Params::DFBaseGun_OnRep_SelectedFireMode Parms{};

	Parms.PrevSelectedFireMode = PrevSelectedFireMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.PlayReloadAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseGun::PlayReloadAnimations(bool bDryReload, bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "PlayReloadAnimations");

	Params::DFBaseGun_PlayReloadAnimations Parms{};

	Parms.bDryReload = bDryReload;
	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.PlayReloadTransitionAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStartReload                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDontPlayAndReturnDominantPlayLengthOnly               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseGun::PlayReloadTransitionAnimations(bool bStartReload, bool bDontPlayAndReturnDominantPlayLengthOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "PlayReloadTransitionAnimations");

	Params::DFBaseGun_PlayReloadTransitionAnimations Parms{};

	Parms.bStartReload = bStartReload;
	Parms.bDontPlayAndReturnDominantPlayLengthOnly = bDontPlayAndReturnDominantPlayLengthOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.PlayWeaponEndReloadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     EndReloadMontageToPlay                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseGun::PlayWeaponEndReloadMontage(class UAnimMontage* EndReloadMontageToPlay, bool bDryReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "PlayWeaponEndReloadMontage");

	Params::DFBaseGun_PlayWeaponEndReloadMontage Parms{};

	Parms.EndReloadMontageToPlay = EndReloadMontageToPlay;
	Parms.bDryReload = bDryReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.PlayWeaponReloadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseGun::PlayWeaponReloadMontage(bool bDryReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "PlayWeaponReloadMontage");

	Params::DFBaseGun_PlayWeaponReloadMontage Parms{};

	Parms.bDryReload = bDryReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.PlayWeaponStartReloadMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     StartReloadMontageToPlay                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDryReload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseGun::PlayWeaponStartReloadMontage(class UAnimMontage* StartReloadMontageToPlay, bool bDryReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "PlayWeaponStartReloadMontage");

	Params::DFBaseGun_PlayWeaponStartReloadMontage Parms{};

	Parms.StartReloadMontageToPlay = StartReloadMontageToPlay;
	Parms.bDryReload = bDryReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.ReceiveAmmoExhausted
// (Event, Protected, BlueprintEvent)

void ADFBaseGun::ReceiveAmmoExhausted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ReceiveAmmoExhausted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGun.ReceiveFireModeChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EFireMode                               NewFireMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFireMode                               PrevFireMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromPlayerInput                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::ReceiveFireModeChanged(EFireMode NewFireMode, EFireMode PrevFireMode, bool bFromPlayerInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ReceiveFireModeChanged");

	Params::DFBaseGun_ReceiveFireModeChanged Parms{};

	Parms.NewFireMode = NewFireMode;
	Parms.PrevFireMode = PrevFireMode;
	Parms.bFromPlayerInput = bFromPlayerInput;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseGun.ReceiveReloadFinished
// (Event, Public, BlueprintEvent)

void ADFBaseGun::ReceiveReloadFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ReceiveReloadFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGun.ReceiveReloadStarted
// (Event, Public, BlueprintEvent)

void ADFBaseGun::ReceiveReloadStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ReceiveReloadStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseGun.ServerSetFireMode
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// EFireMode                               NewFireMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::ServerSetFireMode(EFireMode NewFireMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ServerSetFireMode");

	Params::DFBaseGun_ServerSetFireMode Parms{};

	Parms.NewFireMode = NewFireMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.ServerStartReload
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ADFBaseGun::ServerStartReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ServerStartReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.SetFireMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EFireMode                               NewFireMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromPlayerInput                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::SetFireMode(EFireMode NewFireMode, bool bFromPlayerInput, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "SetFireMode");

	Params::DFBaseGun_SetFireMode Parms{};

	Parms.NewFireMode = NewFireMode;
	Parms.bFromPlayerInput = bFromPlayerInput;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.SetFireModeBP
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EFireMode                               NewFireMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::SetFireModeBP(EFireMode NewFireMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "SetFireModeBP");

	Params::DFBaseGun_SetFireModeBP Parms{};

	Parms.NewFireMode = NewFireMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.SetReloadState
// (Native, Protected, BlueprintCallable)
// Parameters:
// EGunReloadState                         NewReloadState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::SetReloadState(EGunReloadState NewReloadState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "SetReloadState");

	Params::DFBaseGun_SetReloadState Parms{};

	Parms.NewReloadState = NewReloadState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.SimulateGunReload
// (Native, Public, BlueprintCallable)

void ADFBaseGun::SimulateGunReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "SimulateGunReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.StartReload
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun::StartReload(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "StartReload");

	Params::DFBaseGun_StartReload Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.StopSimulatingGunReload
// (Native, Public, BlueprintCallable)

void ADFBaseGun::StopSimulatingGunReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "StopSimulatingGunReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.UnloadCurrentAmmoClip
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ADFBaseGun::UnloadCurrentAmmoClip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "UnloadCurrentAmmoClip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun.CanReload
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::CanReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "CanReload");

	Params::DFBaseGun_CanReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetClipAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseGun::GetClipAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetClipAmmo");

	Params::DFBaseGun_GetClipAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetMuzzleAttachComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreLocalControlOnServer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ADFBaseGun::GetMuzzleAttachComponent(bool bIgnoreLocalControlOnServer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetMuzzleAttachComponent");

	Params::DFBaseGun_GetMuzzleAttachComponent Parms{};

	Parms.bIgnoreLocalControlOnServer = bIgnoreLocalControlOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetMuzzleAttachPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADFBaseGun::GetMuzzleAttachPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetMuzzleAttachPoint");

	Params::DFBaseGun_GetMuzzleAttachPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetMuzzleDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreLocalControlOnServer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADFBaseGun::GetMuzzleDirection(bool bIgnoreLocalControlOnServer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetMuzzleDirection");

	Params::DFBaseGun_GetMuzzleDirection Parms{};

	Parms.bIgnoreLocalControlOnServer = bIgnoreLocalControlOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetMuzzleLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreLocalControlOnServer                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADFBaseGun::GetMuzzleLocation(bool bIgnoreLocalControlOnServer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetMuzzleLocation");

	Params::DFBaseGun_GetMuzzleLocation Parms{};

	Parms.bIgnoreLocalControlOnServer = bIgnoreLocalControlOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetNumFreeAmmoClips
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeEmptyMags                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeCurrentMag                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseGun::GetNumFreeAmmoClips(bool bIncludeEmptyMags, bool bIncludeCurrentMag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetNumFreeAmmoClips");

	Params::DFBaseGun_GetNumFreeAmmoClips Parms{};

	Parms.bIncludeEmptyMags = bIncludeEmptyMags;
	Parms.bIncludeCurrentMag = bIncludeCurrentMag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetPostReloadClipAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseGun::GetPostReloadClipAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetPostReloadClipAmmo");

	Params::DFBaseGun_GetPostReloadClipAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetPreviousReloadState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGunReloadState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGunReloadState ADFBaseGun::GetPreviousReloadState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetPreviousReloadState");

	Params::DFBaseGun_GetPreviousReloadState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetReloadState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGunReloadState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGunReloadState ADFBaseGun::GetReloadState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetReloadState");

	Params::DFBaseGun_GetReloadState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetSelectedFireMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFireMode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFireMode ADFBaseGun::GetSelectedFireMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetSelectedFireMode");

	Params::DFBaseGun_GetSelectedFireMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetShellEjectAttachPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADFBaseGun::GetShellEjectAttachPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetShellEjectAttachPoint");

	Params::DFBaseGun_GetShellEjectAttachPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetSupportedFireModes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ADFBaseGun::GetSupportedFireModes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetSupportedFireModes");

	Params::DFBaseGun_GetSupportedFireModes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.GetTotalAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeLoadedMags                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBaseGun::GetTotalAmmo(bool bIncludeLoadedMags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "GetTotalAmmo");

	Params::DFBaseGun_GetTotalAmmo Parms{};

	Parms.bIncludeLoadedMags = bIncludeLoadedMags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.HasAmmoClip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::HasAmmoClip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "HasAmmoClip");

	Params::DFBaseGun_HasAmmoClip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.HasExhaustedAllAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::HasExhaustedAllAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "HasExhaustedAllAmmo");

	Params::DFBaseGun_HasExhaustedAllAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.IsDryReloading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::IsDryReloading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "IsDryReloading");

	Params::DFBaseGun_IsDryReloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.IsReloading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::IsReloading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "IsReloading");

	Params::DFBaseGun_IsReloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.ShouldSimulateGunReload
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::ShouldSimulateGunReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ShouldSimulateGunReload");

	Params::DFBaseGun_ShouldSimulateGunReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun.ShouldUseRecoil
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseGun::ShouldUseRecoil() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun", "ShouldUseRecoil");

	Params::DFBaseGun_ShouldUseRecoil Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFPlayerComponent.CanRestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFPlayerComponent::CanRestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "CanRestartPlayer");

	Params::DFPlayerComponent_CanRestartPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFPlayerComponent.GetMinRestartDelay
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFPlayerComponent::GetMinRestartDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "GetMinRestartDelay");

	Params::DFPlayerComponent_GetMinRestartDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFPlayerComponent.ReceiveGameHasEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           EndGameFocus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsWinner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFPlayerComponent::ReceiveGameHasEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "ReceiveGameHasEnded");

	Params::DFPlayerComponent_ReceiveGameHasEnded Parms{};

	Parms.EndGameFocus = EndGameFocus;
	Parms.bIsWinner = bIsWinner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFPlayerComponent.ReceivePawnLeavingGame
// (Event, Protected, BlueprintEvent)

void UDFPlayerComponent::ReceivePawnLeavingGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "ReceivePawnLeavingGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFPlayerComponent.ReceiveSeamlessTravelFromCommon
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      OldC                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFPlayerComponent*               OldCPlayerComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFPlayerComponent::ReceiveSeamlessTravelFromCommon(class AController* OldC, class UDFPlayerComponent* OldCPlayerComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "ReceiveSeamlessTravelFromCommon");

	Params::DFPlayerComponent_ReceiveSeamlessTravelFromCommon Parms{};

	Parms.OldC = OldC;
	Parms.OldCPlayerComp = OldCPlayerComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFPlayerComponent.ReceiveSeamlessTravelToCommon
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      NewC                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFPlayerComponent*               NewCPlayerComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFPlayerComponent::ReceiveSeamlessTravelToCommon(class AController* NewC, class UDFPlayerComponent* NewCPlayerComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "ReceiveSeamlessTravelToCommon");

	Params::DFPlayerComponent_ReceiveSeamlessTravelToCommon Parms{};

	Parms.NewC = NewC;
	Parms.NewCPlayerComp = NewCPlayerComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFPlayerComponent.RestartPlayer
// (Native, Public, BlueprintCallable)

void UDFPlayerComponent::RestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "RestartPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFPlayerComponent.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UDFPlayerComponent::GetPawnOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "GetPawnOwner");

	Params::DFPlayerComponent_GetPawnOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFPlayerComponent.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* UDFPlayerComponent::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "GetPlayerState");

	Params::DFPlayerComponent_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFPlayerComponent.GetTeamState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFTeamState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFTeamState* UDFPlayerComponent::GetTeamState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "GetTeamState");

	Params::DFPlayerComponent_GetTeamState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFPlayerComponent.IsPendingRestart
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFPlayerComponent::IsPendingRestart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFPlayerComponent", "IsPendingRestart");

	Params::DFPlayerComponent_IsPendingRestart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseGun_Projectile.ClientDrawDebugFireCone
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          ConeOrig                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ConeDir                                                (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun_Projectile::ClientDrawDebugFireCone(struct FVector& ConeOrig, struct FVector_NetQuantizeNormal& ConeDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun_Projectile", "ClientDrawDebugFireCone");

	Params::DFBaseGun_Projectile_ClientDrawDebugFireCone Parms{};

	Parms.ConeOrig = std::move(ConeOrig);
	Parms.ConeDir = std::move(ConeDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun_Projectile.ClientProjDebugImpactInfo
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class ADFBaseProjectile*                Proj                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactLoc                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNorm                                             (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun_Projectile::ClientProjDebugImpactInfo(class ADFBaseProjectile* Proj, struct FVector& ImpactLoc, struct FVector_NetQuantizeNormal& ImpactNorm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun_Projectile", "ClientProjDebugImpactInfo");

	Params::DFBaseGun_Projectile_ClientProjDebugImpactInfo Parms{};

	Parms.Proj = Proj;
	Parms.ImpactLoc = std::move(ImpactLoc);
	Parms.ImpactNorm = std::move(ImpactNorm);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun_Projectile.ClientProjDebugInfo
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class ADFBaseProjectile*                Proj                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewProjLoc                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LastProjLoc                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewProjRot                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          NewProjVel                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun_Projectile::ClientProjDebugInfo(class ADFBaseProjectile* Proj, struct FVector& NewProjLoc, struct FVector& LastProjLoc, struct FRotator& NewProjRot, struct FVector& NewProjVel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun_Projectile", "ClientProjDebugInfo");

	Params::DFBaseGun_Projectile_ClientProjDebugInfo Parms{};

	Parms.Proj = Proj;
	Parms.NewProjLoc = std::move(NewProjLoc);
	Parms.LastProjLoc = std::move(LastProjLoc);
	Parms.NewProjRot = std::move(NewProjRot);
	Parms.NewProjVel = std::move(NewProjVel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun_Projectile.ServerNotifyCSHit
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ADFBaseProjectile*                HitProj                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCSHitInfo                       HitInfo                                                (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ShotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun_Projectile::ServerNotifyCSHit(class ADFBaseProjectile* HitProj, struct FCSHitInfo& HitInfo, int32 ShotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun_Projectile", "ServerNotifyCSHit");

	Params::DFBaseGun_Projectile_ServerNotifyCSHit Parms{};

	Parms.HitProj = HitProj;
	Parms.HitInfo = std::move(HitInfo);
	Parms.ShotID = ShotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun_Projectile.ServerNotifyCSHitPredicted
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FCSHitInfo                       HitInfo                                                (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ShotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun_Projectile::ServerNotifyCSHitPredicted(struct FCSHitInfo& HitInfo, int32 ShotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun_Projectile", "ServerNotifyCSHitPredicted");

	Params::DFBaseGun_Projectile_ServerNotifyCSHitPredicted Parms{};

	Parms.HitInfo = std::move(HitInfo);
	Parms.ShotID = ShotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseGun_Projectile.CalcShotVector
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutProjOrigin                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutProjDir                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseGun_Projectile::CalcShotVector(struct FVector* OutProjOrigin, struct FVector* OutProjDir) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseGun_Projectile", "CalcShotVector");

	Params::DFBaseGun_Projectile_CalcShotVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProjOrigin != nullptr)
		*OutProjOrigin = std::move(Parms.OutProjOrigin);

	if (OutProjDir != nullptr)
		*OutProjDir = std::move(Parms.OutProjDir);
}


// Function DonkehFramework.DFBaseImpactEffect.GetImpactFX
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* ADFBaseImpactEffect::GetImpactFX(EPhysicalSurface SurfaceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseImpactEffect", "GetImpactFX");

	Params::DFBaseImpactEffect_GetImpactFX Parms{};

	Parms.SurfaceType = SurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseImpactEffect.GetImpactSound
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundCue*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundCue* ADFBaseImpactEffect::GetImpactSound(EPhysicalSurface SurfaceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseImpactEffect", "GetImpactSound");

	Params::DFBaseImpactEffect_GetImpactSound Parms{};

	Parms.SurfaceType = SurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePickup.GivePickupTo
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADFBaseCharacter*                 PickupOwner                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePickup::GivePickupTo(class ADFBaseCharacter* PickupOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "GivePickupTo");

	Params::DFBasePickup_GivePickupTo Parms{};

	Parms.PickupOwner = PickupOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.InitializePickup
// (Native, Event, Protected, BlueprintEvent)

void ADFBasePickup::InitializePickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "InitializePickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.OnPickup
// (Native, Event, Protected, BlueprintEvent)

void ADFBasePickup::OnPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "OnPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.OnRep_Active
// (Native, Protected)

void ADFBasePickup::OnRep_Active()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "OnRep_Active");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.OnRespawn
// (Native, Event, Protected, BlueprintEvent)

void ADFBasePickup::OnRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "OnRespawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.RespawnPickup
// (Native, Protected, BlueprintCallable)

void ADFBasePickup::RespawnPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "RespawnPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.UpdatePickupState
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNewActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePickup::UpdatePickupState(bool bNewActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "UpdatePickupState");

	Params::DFBasePickup_UpdatePickupState Parms{};

	Parms.bNewActive = bNewActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePickup.CanBePickedUp
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseCharacter*                 Invoker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePickup::CanBePickedUp(class ADFBaseCharacter* Invoker) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePickup", "CanBePickedUp");

	Params::DFBasePickup_CanBePickedUp Parms{};

	Parms.Invoker = Invoker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.JumpVaultPressed
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerCharacter::JumpVaultPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "JumpVaultPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.LookUpAtRate
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::LookUpAtRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "LookUpAtRate");

	Params::DFBasePlayerCharacter_LookUpAtRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.MoveForward
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::MoveForward(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "MoveForward");

	Params::DFBasePlayerCharacter_MoveForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.MoveRight
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::MoveRight(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "MoveRight");

	Params::DFBasePlayerCharacter_MoveRight Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.MoveUp
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::MoveUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "MoveUp");

	Params::DFBasePlayerCharacter_MoveUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.OnFirePressed
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerCharacter::OnFirePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "OnFirePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.OnFireReleased
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerCharacter::OnFireReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "OnFireReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.OnToggleFirstPerson
// (Final, Native, Protected)
// Parameters:
// bool                                    bNewFirstPerson                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::OnToggleFirstPerson(bool bNewFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "OnToggleFirstPerson");

	Params::DFBasePlayerCharacter_OnToggleFirstPerson Parms{};

	Parms.bNewFirstPerson = bNewFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.ServerOnToggleFirstPerson
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewFirstPerson                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::ServerOnToggleFirstPerson(bool bNewFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "ServerOnToggleFirstPerson");

	Params::DFBasePlayerCharacter_ServerOnToggleFirstPerson Parms{};

	Parms.bNewFirstPerson = bNewFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.ServerUse
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class AActor*                           UseTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              UseTraceStart                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              UseTraceEnd                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::ServerUse(class AActor* UseTarget, struct FVector_NetQuantize& UseTraceStart, struct FVector_NetQuantize& UseTraceEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "ServerUse");

	Params::DFBasePlayerCharacter_ServerUse Parms{};

	Parms.UseTarget = UseTarget;
	Parms.UseTraceStart = std::move(UseTraceStart);
	Parms.UseTraceEnd = std::move(UseTraceEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.SetMeshVisibility
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bFirstPersonVisibility                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::SetMeshVisibility(bool bFirstPersonVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "SetMeshVisibility");

	Params::DFBasePlayerCharacter_SetMeshVisibility Parms{};

	Parms.bFirstPersonVisibility = bFirstPersonVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.SwitchFireMode
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerCharacter::SwitchFireMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "SwitchFireMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.TurnAtRate
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerCharacter::TurnAtRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "TurnAtRate");

	Params::DFBasePlayerCharacter_TurnAtRate Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.Use
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerCharacter::Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerCharacter.GetCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ADFBasePlayerCharacter::GetCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "GetCamera");

	Params::DFBasePlayerCharacter_GetCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.GetCamera1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ADFBasePlayerCharacter::GetCamera1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "GetCamera1P");

	Params::DFBasePlayerCharacter_GetCamera1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.GetCameraBoom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpringArmComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpringArmComponent* ADFBasePlayerCharacter::GetCameraBoom() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "GetCameraBoom");

	Params::DFBasePlayerCharacter_GetCameraBoom Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.GetDefaultPawnMesh1P
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* ADFBasePlayerCharacter::GetDefaultPawnMesh1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "GetDefaultPawnMesh1P");

	Params::DFBasePlayerCharacter_GetDefaultPawnMesh1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.GetItemAttachPoint1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADFBasePlayerCharacter::GetItemAttachPoint1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "GetItemAttachPoint1P");

	Params::DFBasePlayerCharacter_GetItemAttachPoint1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.GetMesh1P
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADFBasePlayerCharacter::GetMesh1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "GetMesh1P");

	Params::DFBasePlayerCharacter_GetMesh1P Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.IsFirstPerson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerCharacter::IsFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "IsFirstPerson");

	Params::DFBasePlayerCharacter_IsFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.IsLocalFirstPerson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerCharacter::IsLocalFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "IsLocalFirstPerson");

	Params::DFBasePlayerCharacter_IsLocalFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.IsTrueFirstPerson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerCharacter::IsTrueFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "IsTrueFirstPerson");

	Params::DFBasePlayerCharacter_IsTrueFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.IsUsingFirstPersonMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerCharacter::IsUsingFirstPersonMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "IsUsingFirstPersonMesh");

	Params::DFBasePlayerCharacter_IsUsingFirstPersonMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerCharacter.ReceiveGetDefaultPawnMesh1P
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* ADFBasePlayerCharacter::ReceiveGetDefaultPawnMesh1P() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerCharacter", "ReceiveGetDefaultPawnMesh1P");

	Params::DFBasePlayerCharacter_ReceiveGetDefaultPawnMesh1P Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerController.Admin
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Cmd                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::Admin(const class FString& Cmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "Admin");

	Params::DFBasePlayerController_Admin Parms{};

	Parms.Cmd = std::move(Cmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.CastVote
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   VoteSelectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDFVotingChannel                        VotingChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerController::CastVote(int32 VoteSelectionIndex, EDFVotingChannel VotingChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "CastVote");

	Params::DFBasePlayerController_CastVote Parms{};

	Parms.VoteSelectionIndex = VoteSelectionIndex;
	Parms.VotingChannel = VotingChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerController.ClientEnableCheats
// (Net, NetReliable, Native, Event, Protected, NetClient)

void ADFBasePlayerController::ClientEnableCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ClientEnableCheats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.InitiateVote
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDFVoteIssueContext              IssueContext                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   VoteSelectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDFVotingChannel                        VotingChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerController::InitiateVote(TSubclassOf<class UDFVoteIssue> IssueClass, struct FDFVoteIssueContext& IssueContext, int32 VoteSelectionIndex, EDFVotingChannel VotingChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "InitiateVote");

	Params::DFBasePlayerController_InitiateVote Parms{};

	Parms.IssueClass = IssueClass;
	Parms.IssueContext = std::move(IssueContext);
	Parms.VoteSelectionIndex = VoteSelectionIndex;
	Parms.VotingChannel = VotingChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerController.IsGameInputAllowed
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerController::IsGameInputAllowed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "IsGameInputAllowed");

	Params::DFBasePlayerController_IsGameInputAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerController.OnFirePressed
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerController::OnFirePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "OnFirePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.OnFireReleased
// (Native, Protected, BlueprintCallable)

void ADFBasePlayerController::OnFireReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "OnFireReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ReceiveGameHasEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           EndGameFocus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsWinner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceiveGameHasEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceiveGameHasEnded");

	Params::DFBasePlayerController_ReceiveGameHasEnded Parms{};

	Parms.EndGameFocus = EndGameFocus;
	Parms.bIsWinner = bIsWinner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.ReceiveNewChatMsg
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPlayerChatMsg                   ChatMsg                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceiveNewChatMsg(struct FPlayerChatMsg& ChatMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceiveNewChatMsg");

	Params::DFBasePlayerController_ReceiveNewChatMsg Parms{};

	Parms.ChatMsg = std::move(ChatMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.ReceiveOnRepPlayerState
// (Event, Protected, BlueprintEvent)

void ADFBasePlayerController::ReceiveOnRepPlayerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceiveOnRepPlayerState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBasePlayerController.ReceivePlayerTeamNumUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// uint8                                   LastTeamNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeamNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceivePlayerTeamNumUpdated(uint8 LastTeamNum, uint8 NewTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceivePlayerTeamNumUpdated");

	Params::DFBasePlayerController_ReceivePlayerTeamNumUpdated Parms{};

	Parms.LastTeamNum = LastTeamNum;
	Parms.NewTeamNum = NewTeamNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.ReceivePlayerTeamStateUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADFTeamState*                     LastTeamState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFTeamState*                     NewTeamState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewTeamStateInit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceivePlayerTeamStateUpdated(class ADFTeamState* LastTeamState, class ADFTeamState* NewTeamState, bool bNewTeamStateInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceivePlayerTeamStateUpdated");

	Params::DFBasePlayerController_ReceivePlayerTeamStateUpdated Parms{};

	Parms.LastTeamState = LastTeamState;
	Parms.NewTeamState = NewTeamState;
	Parms.bNewTeamStateInit = bNewTeamStateInit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.ReceivePossessPawn
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceivePossessPawn(class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceivePossessPawn");

	Params::DFBasePlayerController_ReceivePossessPawn Parms{};

	Parms.NewPawn = NewPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.ReceivePreClientTravel
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           PendingURL                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSeamlessTravelWithRelativeTravelType                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceivePreClientTravel(const class FString& PendingURL, bool bIsSeamlessTravelWithRelativeTravelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceivePreClientTravel");

	Params::DFBasePlayerController_ReceivePreClientTravel Parms{};

	Parms.PendingURL = std::move(PendingURL);
	Parms.bIsSeamlessTravelWithRelativeTravelType = bIsSeamlessTravelWithRelativeTravelType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.ReceiveUnpossessPawn
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            UnpossessedPawn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ReceiveUnpossessPawn(class APawn* UnpossessedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ReceiveUnpossessPawn");

	Params::DFBasePlayerController_ReceiveUnpossessPawn Parms{};

	Parms.UnpossessedPawn = UnpossessedPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBasePlayerController.Say
// (Final, Exec, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::Say(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "Say");

	Params::DFBasePlayerController_Say Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerAdmin
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class FString                           Cmd                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ServerAdmin(const class FString& Cmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerAdmin");

	Params::DFBasePlayerController_ServerAdmin Parms{};

	Parms.Cmd = std::move(Cmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerCastVote
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   VoteSelectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDFVotingChannel                        VotingChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ServerCastVote(int32 VoteSelectionIndex, EDFVotingChannel VotingChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerCastVote");

	Params::DFBasePlayerController_ServerCastVote Parms{};

	Parms.VoteSelectionIndex = VoteSelectionIndex;
	Parms.VotingChannel = VotingChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerEnableCheats
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ADFBasePlayerController::ServerEnableCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerEnableCheats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerInitiateVote
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDFVoteIssueContext              IssueContext                                           (Parm, NativeAccessSpecifierPublic)
// int32                                   VoteSelectionIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDFVotingChannel                        VotingChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ServerInitiateVote(TSubclassOf<class UDFVoteIssue> IssueClass, const struct FDFVoteIssueContext& IssueContext, int32 VoteSelectionIndex, EDFVotingChannel VotingChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerInitiateVote");

	Params::DFBasePlayerController_ServerInitiateVote Parms{};

	Parms.IssueClass = IssueClass;
	Parms.IssueContext = std::move(IssueContext);
	Parms.VoteSelectionIndex = VoteSelectionIndex;
	Parms.VotingChannel = VotingChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerNotifyProjCSHit
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ADFBaseProjectile*                HitProj                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            HitProjDamageInstigator                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCSHitInfo                       HitInfo                                                (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ShotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ServerNotifyProjCSHit(class ADFBaseProjectile* HitProj, class APawn* HitProjDamageInstigator, struct FCSHitInfo& HitInfo, int32 ShotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerNotifyProjCSHit");

	Params::DFBasePlayerController_ServerNotifyProjCSHit Parms{};

	Parms.HitProj = HitProj;
	Parms.HitProjDamageInstigator = HitProjDamageInstigator;
	Parms.HitInfo = std::move(HitInfo);
	Parms.ShotID = ShotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerSay
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ServerSay(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerSay");

	Params::DFBasePlayerController_ServerSay Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.ServerTeamSay
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::ServerTeamSay(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "ServerTeamSay");

	Params::DFBasePlayerController_ServerTeamSay Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.TeamSay
// (Final, Exec, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerController::TeamSay(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "TeamSay");

	Params::DFBasePlayerController_TeamSay Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerController.GetUnFreezeTimerHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle ADFBasePlayerController::GetUnFreezeTimerHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "GetUnFreezeTimerHandle");

	Params::DFBasePlayerController_GetUnFreezeTimerHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerController.GetVotingComponentByChannel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDFVotingChannel                        VotingChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFVotingComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFVotingComponent* ADFBasePlayerController::GetVotingComponentByChannel(EDFVotingChannel VotingChannel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "GetVotingComponentByChannel");

	Params::DFBasePlayerController_GetVotingComponentByChannel Parms{};

	Parms.VotingChannel = VotingChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerController.IsServerAdministrator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBasePlayerController::IsServerAdministrator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerController", "IsServerAdministrator");

	Params::DFBasePlayerController_IsServerAdministrator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFSingleActionWeapAnimInstInterface.PlayActionMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFSingleActionWeapAnimInstInterface::PlayActionMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFSingleActionWeapAnimInstInterface", "PlayActionMontage");

	Params::DFSingleActionWeapAnimInstInterface_PlayActionMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerState.OnRep_bAdmin
// (Native, Protected)
// Parameters:
// bool                                    bAdminStatusBeforeUpdate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnRep_bAdmin(bool bAdminStatusBeforeUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnRep_bAdmin");

	Params::DFBasePlayerState_OnRep_bAdmin Parms{};

	Parms.bAdminStatusBeforeUpdate = bAdminStatusBeforeUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnRep_NumAssists
// (Native, Protected)
// Parameters:
// int32                                   PrevNumAssists                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnRep_NumAssists(int32 PrevNumAssists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnRep_NumAssists");

	Params::DFBasePlayerState_OnRep_NumAssists Parms{};

	Parms.PrevNumAssists = PrevNumAssists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnRep_NumDeaths
// (Native, Protected)
// Parameters:
// int32                                   PrevNumDeaths                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnRep_NumDeaths(int32 PrevNumDeaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnRep_NumDeaths");

	Params::DFBasePlayerState_OnRep_NumDeaths Parms{};

	Parms.PrevNumDeaths = PrevNumDeaths;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnRep_NumKills
// (Native, Protected)
// Parameters:
// int32                                   PrevNumKills                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnRep_NumKills(int32 PrevNumKills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnRep_NumKills");

	Params::DFBasePlayerState_OnRep_NumKills Parms{};

	Parms.PrevNumKills = PrevNumKills;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnRep_TeamNum
// (Native, Protected)
// Parameters:
// uint8                                   TeamNumBeforeUpdate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnRep_TeamNum(uint8 TeamNumBeforeUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnRep_TeamNum");

	Params::DFBasePlayerState_OnRep_TeamNum Parms{};

	Parms.TeamNumBeforeUpdate = TeamNumBeforeUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnRep_TeamState
// (Native, Protected)
// Parameters:
// class ADFTeamState*                     TeamStateBeforeUpdate                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnRep_TeamState(class ADFTeamState* TeamStateBeforeUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnRep_TeamState");

	Params::DFBasePlayerState_OnRep_TeamState Parms{};

	Parms.TeamStateBeforeUpdate = TeamStateBeforeUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnTeamNumUpdated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// uint8                                   TeamNumBeforeUpdate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnTeamNumUpdated(uint8 TeamNumBeforeUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnTeamNumUpdated");

	Params::DFBasePlayerState_OnTeamNumUpdated Parms{};

	Parms.TeamNumBeforeUpdate = TeamNumBeforeUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.OnTeamStateUpdated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADFTeamState*                     TeamStateBeforeUpdate                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::OnTeamStateUpdated(class ADFTeamState* TeamStateBeforeUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "OnTeamStateUpdated");

	Params::DFBasePlayerState_OnTeamStateUpdated Parms{};

	Parms.TeamStateBeforeUpdate = TeamStateBeforeUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.ReceiveOnRepPlayerName
// (Event, Protected, BlueprintEvent)

void ADFBasePlayerState::ReceiveOnRepPlayerName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "ReceiveOnRepPlayerName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBasePlayerState.ScoreAssistPlayer
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBasePlayerState*               Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBasePlayerState*               Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::ScoreAssistPlayer(class ADFBasePlayerState* Killer, class ADFBasePlayerState* Victim, float Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "ScoreAssistPlayer");

	Params::DFBasePlayerState_ScoreAssistPlayer Parms{};

	Parms.Killer = Killer;
	Parms.Victim = Victim;
	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.ScoreDeath
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBasePlayerState*               KilledBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::ScoreDeath(class ADFBasePlayerState* KilledBy, float Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "ScoreDeath");

	Params::DFBasePlayerState_ScoreDeath Parms{};

	Parms.KilledBy = KilledBy;
	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.ScoreKillPlayer
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBasePlayerState*               Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::ScoreKillPlayer(class ADFBasePlayerState* Victim, float Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "ScoreKillPlayer");

	Params::DFBasePlayerState_ScoreKillPlayer Parms{};

	Parms.Victim = Victim;
	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.ScorePoints
// (BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceNetUpdate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::ScorePoints(float Points, bool bForceNetUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "ScorePoints");

	Params::DFBasePlayerState_ScorePoints Parms{};

	Parms.Points = Points;
	Parms.bForceNetUpdate = bForceNetUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.SetAdminStatus
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAdminStatus                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::SetAdminStatus(bool bNewAdminStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "SetAdminStatus");

	Params::DFBasePlayerState_SetAdminStatus Parms{};

	Parms.bNewAdminStatus = bNewAdminStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.SetTeam
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   NewTeamNum                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCopyToInactivePlayerState                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBasePlayerState::SetTeam(uint8 NewTeamNum, bool bCopyToInactivePlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "SetTeam");

	Params::DFBasePlayerState_SetTeam Parms{};

	Parms.NewTeamNum = NewTeamNum;
	Parms.bCopyToInactivePlayerState = bCopyToInactivePlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBasePlayerState.GetAssists
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBasePlayerState::GetAssists() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "GetAssists");

	Params::DFBasePlayerState_GetAssists Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerState.GetDeaths
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBasePlayerState::GetDeaths() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "GetDeaths");

	Params::DFBasePlayerState_GetDeaths Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerState.GetKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADFBasePlayerState::GetKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "GetKills");

	Params::DFBasePlayerState_GetKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerState.GetPreviousTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ADFBasePlayerState::GetPreviousTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "GetPreviousTeam");

	Params::DFBasePlayerState_GetPreviousTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBasePlayerState.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ADFBasePlayerState::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBasePlayerState", "GetTeam");

	Params::DFBasePlayerState_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFSingleLoadWeapAnimInstInterface.PlayEndReloadMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFullReload                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFSingleLoadWeapAnimInstInterface::PlayEndReloadMontage(class UAnimMontage* MontageToPlay, bool bFullReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFSingleLoadWeapAnimInstInterface", "PlayEndReloadMontage");

	Params::DFSingleLoadWeapAnimInstInterface_PlayEndReloadMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.bFullReload = bFullReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFSingleLoadWeapAnimInstInterface.PlayStartReloadMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFullReload                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFSingleLoadWeapAnimInstInterface::PlayStartReloadMontage(class UAnimMontage* MontageToPlay, bool bFullReload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFSingleLoadWeapAnimInstInterface", "PlayStartReloadMontage");

	Params::DFSingleLoadWeapAnimInstInterface_PlayStartReloadMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.bFullReload = bFullReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.ApplyDamageToImpactedActor
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADFBaseProjectile::ApplyDamageToImpactedActor(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, struct FVector& HitLocation, struct FVector& HitNormal, struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "ApplyDamageToImpactedActor");

	Params::DFBaseProjectile_ApplyDamageToImpactedActor Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.DisableAndDeferDestroy
// (Native, Public, BlueprintCallable)

void ADFBaseProjectile::DisableAndDeferDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "DisableAndDeferDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.IgnoreInstigatorWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldIgnore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBidirectional                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseProjectile::IgnoreInstigatorWhenMoving(bool bShouldIgnore, bool bBidirectional)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "IgnoreInstigatorWhenMoving");

	Params::DFBaseProjectile_IgnoreInstigatorWhenMoving Parms{};

	Parms.bShouldIgnore = bShouldIgnore;
	Parms.bBidirectional = bBidirectional;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.K2_PostProcessValidHit
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bFromCSHitNotify                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseProjectile::K2_PostProcessValidHit(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, struct FVector& HitLocation, struct FVector& HitNormal, struct FHitResult& HitResult, bool bFromCSHitNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "K2_PostProcessValidHit");

	Params::DFBaseProjectile_K2_PostProcessValidHit Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.HitResult = std::move(HitResult);
	Parms.bFromCSHitNotify = bFromCSHitNotify;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseProjectile.ProjectileBounce
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseProjectile::ProjectileBounce(struct FHitResult& ImpactResult, struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "ProjectileBounce");

	Params::DFBaseProjectile_ProjectileBounce Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.ProjectileStop
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectile::ProjectileStop(struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "ProjectileStop");

	Params::DFBaseProjectile_ProjectileStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.ReceivePayloadActivated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       ImpactHitResult                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectile::ReceivePayloadActivated(struct FHitResult& ImpactHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "ReceivePayloadActivated");

	Params::DFBaseProjectile_ReceivePayloadActivated Parms{};

	Parms.ImpactHitResult = std::move(ImpactHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseProjectile.SetProjectileUpdatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  NewProjectileUpdatedComponent                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseProjectile::SetProjectileUpdatedComponent(class USceneComponent* NewProjectileUpdatedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "SetProjectileUpdatedComponent");

	Params::DFBaseProjectile_SetProjectileUpdatedComponent Parms{};

	Parms.NewProjectileUpdatedComponent = NewProjectileUpdatedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.SpawnImpactFX
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectile::SpawnImpactFX(struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "SpawnImpactFX");

	Params::DFBaseProjectile_SpawnImpactFX Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.TriggerPayload
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       ImpactHitResult                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bFromTearOff                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseProjectile::TriggerPayload(struct FHitResult& ImpactHitResult, bool bFromTearOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "TriggerPayload");

	Params::DFBaseProjectile_TriggerPayload Parms{};

	Parms.ImpactHitResult = std::move(ImpactHitResult);
	Parms.bFromTearOff = bFromTearOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectile.GetAdjustedDamageParams
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDFDamageParams                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDFDamageParams ADFBaseProjectile::GetAdjustedDamageParams(class AActor* OtherActor, struct FVector& HitLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "GetAdjustedDamageParams");

	Params::DFBaseProjectile_GetAdjustedDamageParams Parms{};

	Parms.OtherActor = OtherActor;
	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.GetImpactFXClass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ADFBaseImpactEffect>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ADFBaseImpactEffect> ADFBaseProjectile::GetImpactFXClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "GetImpactFXClass");

	Params::DFBaseProjectile_GetImpactFXClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.GetOwningWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseWeapon*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseWeapon* ADFBaseProjectile::GetOwningWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "GetOwningWeapon");

	Params::DFBaseProjectile_GetOwningWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.GetProjectileUpdatedComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ADFBaseProjectile::GetProjectileUpdatedComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "GetProjectileUpdatedComponent");

	Params::DFBaseProjectile_GetProjectileUpdatedComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.GetProjectileUpdatedPrimitive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ADFBaseProjectile::GetProjectileUpdatedPrimitive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "GetProjectileUpdatedPrimitive");

	Params::DFBaseProjectile_GetProjectileUpdatedPrimitive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.HasValidPredictedClientProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseProjectile::HasValidPredictedClientProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "HasValidPredictedClientProjectile");

	Params::DFBaseProjectile_HasValidPredictedClientProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectile.K2_ShouldIgnoreHit
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFBaseProjectile::K2_ShouldIgnoreHit(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, struct FHitResult& HitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectile", "K2_ShouldIgnoreHit");

	Params::DFBaseProjectile_K2_ShouldIgnoreHit Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTableLibrary.GetColumnFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TableWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFTableLibrary::GetColumnFromIndex(int32 Param_Index, int32 TableWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFTableLibrary", "GetColumnFromIndex");

	Params::DFTableLibrary_GetColumnFromIndex Parms{};

	Parms.Param_Index = Param_Index;
	Parms.TableWidth = TableWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTableLibrary.GetColumnInvFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TableHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFTableLibrary::GetColumnInvFromIndex(int32 Param_Index, int32 TableHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFTableLibrary", "GetColumnInvFromIndex");

	Params::DFTableLibrary_GetColumnInvFromIndex Parms{};

	Parms.Param_Index = Param_Index;
	Parms.TableHeight = TableHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTableLibrary.GetIndexFromColumnRowPair
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Column                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Row                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TableHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFTableLibrary::GetIndexFromColumnRowPair(int32 Column, int32 Row, int32 TableHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFTableLibrary", "GetIndexFromColumnRowPair");

	Params::DFTableLibrary_GetIndexFromColumnRowPair Parms{};

	Parms.Column = Column;
	Parms.Row = Row;
	Parms.TableHeight = TableHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTableLibrary.GetIndexFromRowColumnPair
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Row                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Column                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TableWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFTableLibrary::GetIndexFromRowColumnPair(int32 Row, int32 Column, int32 TableWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFTableLibrary", "GetIndexFromRowColumnPair");

	Params::DFTableLibrary_GetIndexFromRowColumnPair Parms{};

	Parms.Row = Row;
	Parms.Column = Column;
	Parms.TableWidth = TableWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTableLibrary.GetRowFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TableWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFTableLibrary::GetRowFromIndex(int32 Param_Index, int32 TableWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFTableLibrary", "GetRowFromIndex");

	Params::DFTableLibrary_GetRowFromIndex Parms{};

	Parms.Param_Index = Param_Index;
	Parms.TableWidth = TableWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTableLibrary.GetRowInvFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TableHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFTableLibrary::GetRowInvFromIndex(int32 Param_Index, int32 TableHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFTableLibrary", "GetRowInvFromIndex");

	Params::DFTableLibrary_GetRowInvFromIndex Parms{};

	Parms.Param_Index = Param_Index;
	Parms.TableHeight = TableHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBaseProjectileLegacy.OnRep_bPayloadTriggered
// (Native, Protected)

void ADFBaseProjectileLegacy::OnRep_bPayloadTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "OnRep_bPayloadTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.PayloadDelayElapsed
// (Native, Protected)

void ADFBaseProjectileLegacy::PayloadDelayElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "PayloadDelayElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.ProjectileBounce
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFBaseProjectileLegacy::ProjectileBounce(struct FHitResult& ImpactResult, struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "ProjectileBounce");

	Params::DFBaseProjectileLegacy_ProjectileBounce Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.ProjectileStop
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectileLegacy::ProjectileStop(struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "ProjectileStop");

	Params::DFBaseProjectileLegacy_ProjectileStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.ReceivePayloadActivated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       ImpactHitResult                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectileLegacy::ReceivePayloadActivated(struct FHitResult& ImpactHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "ReceivePayloadActivated");

	Params::DFBaseProjectileLegacy_ReceivePayloadActivated Parms{};

	Parms.ImpactHitResult = std::move(ImpactHitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFBaseProjectileLegacy.ReceiveSimulatePayloadActivation
// (Event, Protected, BlueprintEvent)

void ADFBaseProjectileLegacy::ReceiveSimulatePayloadActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "ReceiveSimulatePayloadActivation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseProjectileLegacy.ReceiveStopSimulatingPayloadActivation
// (Event, Protected, BlueprintEvent)

void ADFBaseProjectileLegacy::ReceiveStopSimulatingPayloadActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "ReceiveStopSimulatingPayloadActivation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFBaseProjectileLegacy.SimulatePayloadActivation
// (Native, Protected, BlueprintCallable)

void ADFBaseProjectileLegacy::SimulatePayloadActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "SimulatePayloadActivation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.SpawnImpactFX
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectileLegacy::SpawnImpactFX(struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "SpawnImpactFX");

	Params::DFBaseProjectileLegacy_SpawnImpactFX Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.StopSimulatingPayloadActivation
// (Native, Protected, BlueprintCallable)

void ADFBaseProjectileLegacy::StopSimulatingPayloadActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "StopSimulatingPayloadActivation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.TriggerPayload
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       ImpactHitResult                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADFBaseProjectileLegacy::TriggerPayload(struct FHitResult& ImpactHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "TriggerPayload");

	Params::DFBaseProjectileLegacy_TriggerPayload Parms{};

	Parms.ImpactHitResult = std::move(ImpactHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBaseProjectileLegacy.GetOwningWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseWeapon*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseWeapon* ADFBaseProjectileLegacy::GetOwningWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFBaseProjectileLegacy", "GetOwningWeapon");

	Params::DFBaseProjectileLegacy_GetOwningWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.Array_AssetDescriptorSort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FAssetDescriptor>         ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompareDisplayText                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_AssetDescriptorSort(TArray<struct FAssetDescriptor>& ArrayToSort, bool bDescending, bool bCompareDisplayText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_AssetDescriptorSort");

	Params::DFBlueprintFunctions_Array_AssetDescriptorSort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;
	Parms.bCompareDisplayText = bCompareDisplayText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_FloatSort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_FloatSort(TArray<float>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_FloatSort");

	Params::DFBlueprintFunctions_Array_FloatSort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_Int32Sort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_Int32Sort(TArray<int32>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_Int32Sort");

	Params::DFBlueprintFunctions_Array_Int32Sort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_Int64Sort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int64>                           ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_Int64Sort(TArray<int64>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_Int64Sort");

	Params::DFBlueprintFunctions_Array_Int64Sort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_NameSort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_NameSort(TArray<class FName>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_NameSort");

	Params::DFBlueprintFunctions_Array_NameSort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_Reverse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_Reverse(TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_Reverse");

	Params::DFBlueprintFunctions_Array_Reverse Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.Array_StringSort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_StringSort(TArray<class FString>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_StringSort");

	Params::DFBlueprintFunctions_Array_StringSort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_TextSort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FText>                     ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_TextSort(TArray<class FText>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_TextSort");

	Params::DFBlueprintFunctions_Array_TextSort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.Array_UInt8Sort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           ArrayToSort                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDescending                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::Array_UInt8Sort(TArray<uint8>& ArrayToSort, bool bDescending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "Array_UInt8Sort");

	Params::DFBlueprintFunctions_Array_UInt8Sort Parms{};

	Parms.ArrayToSort = std::move(ArrayToSort);
	Parms.bDescending = bDescending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ArrayToSort = std::move(Parms.ArrayToSort);
}


// Function DonkehFramework.DFBlueprintFunctions.CharacterVariationDataFromTableRow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDataTableRowHandle              RowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDFCharacterVariationDataHandle  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDFCharacterVariationDataHandle UDFBlueprintFunctions::CharacterVariationDataFromTableRow(class UObject* WorldContextObject, const struct FDataTableRowHandle& RowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "CharacterVariationDataFromTableRow");

	Params::DFBlueprintFunctions_CharacterVariationDataFromTableRow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RowHandle = std::move(RowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.CharacterVariationGetData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDFCharacterVariationDataHandle  VariationData                                          (Parm, NativeAccessSpecifierPublic)
// struct FDFCharacterVariationData        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDFCharacterVariationData UDFBlueprintFunctions::CharacterVariationGetData(const struct FDFCharacterVariationDataHandle& VariationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "CharacterVariationGetData");

	Params::DFBlueprintFunctions_CharacterVariationGetData Parms{};

	Parms.VariationData = std::move(VariationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.CharacterVariationIsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDFCharacterVariationDataHandle  VariationData                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::CharacterVariationIsValid(const struct FDFCharacterVariationDataHandle& VariationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "CharacterVariationIsValid");

	Params::DFBlueprintFunctions_CharacterVariationIsValid Parms{};

	Parms.VariationData = std::move(VariationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.DoesMapIDSupportGMDefinition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  MapId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFGameModeDefinition*            GMDef                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::DoesMapIDSupportGMDefinition(struct FPrimaryAssetId& MapId, class UDFGameModeDefinition* GMDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "DoesMapIDSupportGMDefinition");

	Params::DFBlueprintFunctions_DoesMapIDSupportGMDefinition Parms{};

	Parms.MapId = std::move(MapId);
	Parms.GMDef = GMDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_CharacterAnimCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharacterAnimCollection         A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCharacterAnimCollection         B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_CharacterAnimCollection(struct FCharacterAnimCollection& A, struct FCharacterAnimCollection& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_CharacterAnimCollection");

	Params::DFBlueprintFunctions_EqualEqual_CharacterAnimCollection Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_CharacterSoundCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharacterSoundCollection        A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCharacterSoundCollection        B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_CharacterSoundCollection(struct FCharacterSoundCollection& A, struct FCharacterSoundCollection& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_CharacterSoundCollection");

	Params::DFBlueprintFunctions_EqualEqual_CharacterSoundCollection Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_PerspectiveAnim
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPerspectiveAnim                 A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPerspectiveAnim                 B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_PerspectiveAnim(struct FPerspectiveAnim& A, struct FPerspectiveAnim& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_PerspectiveAnim");

	Params::DFBlueprintFunctions_EqualEqual_PerspectiveAnim Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_PerspectiveAnimSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPerspectiveAnimSequence         A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPerspectiveAnimSequence         B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_PerspectiveAnimSequence(struct FPerspectiveAnimSequence& A, struct FPerspectiveAnimSequence& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_PerspectiveAnimSequence");

	Params::DFBlueprintFunctions_EqualEqual_PerspectiveAnimSequence Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_PerspectiveSound
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPerspectiveSound                A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPerspectiveSound                B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_PerspectiveSound(struct FPerspectiveSound& A, struct FPerspectiveSound& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_PerspectiveSound");

	Params::DFBlueprintFunctions_EqualEqual_PerspectiveSound Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_WeaponAnim
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWeaponAnim                      A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponAnim                      B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_WeaponAnim(struct FWeaponAnim& A, struct FWeaponAnim& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_WeaponAnim");

	Params::DFBlueprintFunctions_EqualEqual_WeaponAnim Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_WeaponAnimCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWeaponAnimCollection            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponAnimCollection            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_WeaponAnimCollection(struct FWeaponAnimCollection& A, struct FWeaponAnimCollection& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_WeaponAnimCollection");

	Params::DFBlueprintFunctions_EqualEqual_WeaponAnimCollection Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_WeaponAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWeaponAnimMontage               A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponAnimMontage               B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_WeaponAnimMontage(struct FWeaponAnimMontage& A, struct FWeaponAnimMontage& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_WeaponAnimMontage");

	Params::DFBlueprintFunctions_EqualEqual_WeaponAnimMontage Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_WeaponAnimSequence
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWeaponAnimSequence              A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponAnimSequence              B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_WeaponAnimSequence(struct FWeaponAnimSequence& A, struct FWeaponAnimSequence& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_WeaponAnimSequence");

	Params::DFBlueprintFunctions_EqualEqual_WeaponAnimSequence Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.EqualEqual_WeaponSoundCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FWeaponSoundCollection           A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponSoundCollection           B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::EqualEqual_WeaponSoundCollection(struct FWeaponSoundCollection& A, struct FWeaponSoundCollection& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "EqualEqual_WeaponSoundCollection");

	Params::DFBlueprintFunctions_EqualEqual_WeaponSoundCollection Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.FindMapIdByDisplayName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             MapDisplayName                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          MapIds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDFBlueprintFunctions::FindMapIdByDisplayName(class FText& MapDisplayName, TArray<struct FPrimaryAssetId>& MapIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "FindMapIdByDisplayName");

	Params::DFBlueprintFunctions_FindMapIdByDisplayName Parms{};

	Parms.MapDisplayName = MapDisplayName;
	Parms.MapIds = std::move(MapIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.FlushPressedKeys
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::FlushPressedKeys(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "FlushPressedKeys");

	Params::DFBlueprintFunctions_FlushPressedKeys Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.GameHasEnded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           EndGameFocus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsWinner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::GameHasEnded(class AController* Controller, class AActor* EndGameFocus, bool bIsWinner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GameHasEnded");

	Params::DFBlueprintFunctions_GameHasEnded Parms{};

	Parms.Controller = Controller;
	Parms.EndGameFocus = EndGameFocus;
	Parms.bIsWinner = bIsWinner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.GetAllMapNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<class FString> UDFBlueprintFunctions::GetAllMapNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetAllMapNames");

	Params::DFBlueprintFunctions_GetAllMapNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetCopyrightNotice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetCopyrightNotice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetCopyrightNotice");

	Params::DFBlueprintFunctions_GetCopyrightNotice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetDefaultBoundingCylinder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CylinderRadius                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CylinderHalfHeight                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::GetDefaultBoundingCylinder(class AActor* Actor, float* CylinderRadius, float* CylinderHalfHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetDefaultBoundingCylinder");

	Params::DFBlueprintFunctions_GetDefaultBoundingCylinder Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CylinderRadius != nullptr)
		*CylinderRadius = Parms.CylinderRadius;

	if (CylinderHalfHeight != nullptr)
		*CylinderHalfHeight = Parms.CylinderHalfHeight;
}


// Function DonkehFramework.DFBlueprintFunctions.GetFocalPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDFBlueprintFunctions::GetFocalPoint(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetFocalPoint");

	Params::DFBlueprintFunctions_GetFocalPoint Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGameBuildInfo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetGameBuildInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGameBuildInfo");

	Params::DFBlueprintFunctions_GetGameBuildInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGameDefaultMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetGameDefaultMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGameDefaultMap");

	Params::DFBlueprintFunctions_GetGameDefaultMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGameModeForMapName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetGameModeForMapName(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGameModeForMapName");

	Params::DFBlueprintFunctions_GetGameModeForMapName Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGameModeForName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           GameModeName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetGameModeForName(const class FString& GameModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGameModeForName");

	Params::DFBlueprintFunctions_GetGameModeForName Parms{};

	Parms.GameModeName = std::move(GameModeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGameNameForDisplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDFBlueprintFunctions::GetGameNameForDisplay(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGameNameForDisplay");

	Params::DFBlueprintFunctions_GetGameNameForDisplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGameVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetGameVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGameVersion");

	Params::DFBlueprintFunctions_GetGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetGlobalDefaultGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetGlobalDefaultGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetGlobalDefaultGameMode");

	Params::DFBlueprintFunctions_GetGlobalDefaultGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataDefaultGameMode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             OutDefaultGameModeRef                                  (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataDefaultGameMode(struct FAssetData& WorldAsset, TSoftClassPtr<class UClass>* OutDefaultGameModeRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataDefaultGameMode");

	Params::DFBlueprintFunctions_GetMapAssetDataDefaultGameMode Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDefaultGameModeRef != nullptr)
		*OutDefaultGameModeRef = Parms.OutDefaultGameModeRef;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutMapDescription                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataDescription(struct FAssetData& WorldAsset, class FString* OutMapDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataDescription");

	Params::DFBlueprintFunctions_GetMapAssetDataDescription Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapDescription != nullptr)
		*OutMapDescription = std::move(Parms.OutMapDescription);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataDisplayName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutMapDisplayName                                      (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataDisplayName(struct FAssetData& WorldAsset, class FText* OutMapDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataDisplayName");

	Params::DFBlueprintFunctions_GetMapAssetDataDisplayName Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapDisplayName != nullptr)
		*OutMapDisplayName = Parms.OutMapDisplayName;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataGameRulesetClasses
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<TSoftClassPtr<class UClass>>       OutGameRulesetClasses                                  (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataGameRulesetClasses(struct FAssetData& WorldAsset, TSet<TSoftClassPtr<class UClass>>* OutGameRulesetClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataGameRulesetClasses");

	Params::DFBlueprintFunctions_GetMapAssetDataGameRulesetClasses Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGameRulesetClasses != nullptr)
		*OutGameRulesetClasses = std::move(Parms.OutGameRulesetClasses);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataNameForDisplay
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDFBlueprintFunctions::GetMapAssetDataNameForDisplay(struct FAssetData& WorldAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataNameForDisplay");

	Params::DFBlueprintFunctions_GetMapAssetDataNameForDisplay Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataPreviewBannerImg
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        OutMapPreviewBannerImgRef                              (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataPreviewBannerImg(struct FAssetData& WorldAsset, TSoftObjectPtr<class UTexture2D>* OutMapPreviewBannerImgRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataPreviewBannerImg");

	Params::DFBlueprintFunctions_GetMapAssetDataPreviewBannerImg Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapPreviewBannerImgRef != nullptr)
		*OutMapPreviewBannerImgRef = Parms.OutMapPreviewBannerImgRef;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataPreviewImg
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        OutMapPreviewImgRef                                    (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataPreviewImg(struct FAssetData& WorldAsset, TSoftObjectPtr<class UTexture2D>* OutMapPreviewImgRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataPreviewImg");

	Params::DFBlueprintFunctions_GetMapAssetDataPreviewImg Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapPreviewImgRef != nullptr)
		*OutMapPreviewImgRef = Parms.OutMapPreviewImgRef;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDataSupportedGameModes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAssetData                       WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<TSoftClassPtr<class UClass>>       OutSupportedGameModes                                  (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDataSupportedGameModes(struct FAssetData& WorldAsset, TSet<TSoftClassPtr<class UClass>>* OutSupportedGameModes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDataSupportedGameModes");

	Params::DFBlueprintFunctions_GetMapAssetDataSupportedGameModes Parms{};

	Parms.WorldAsset = std::move(WorldAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSupportedGameModes != nullptr)
		*OutSupportedGameModes = std::move(Parms.OutSupportedGameModes);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDefaultGameMode
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             OutDefaultGameModeRef                                  (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDefaultGameMode(struct FPrimaryAssetId& WorldAssetId, TSoftClassPtr<class UClass>* OutDefaultGameModeRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDefaultGameMode");

	Params::DFBlueprintFunctions_GetMapAssetDefaultGameMode Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDefaultGameModeRef != nullptr)
		*OutDefaultGameModeRef = Parms.OutDefaultGameModeRef;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetDescription
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutMapDescription                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetDescription(struct FPrimaryAssetId& WorldAssetId, class FString* OutMapDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetDescription");

	Params::DFBlueprintFunctions_GetMapAssetDescription Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapDescription != nullptr)
		*OutMapDescription = std::move(Parms.OutMapDescription);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetGameRulesetClasses
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<TSoftClassPtr<class UClass>>       OutGameRulesetClasses                                  (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetGameRulesetClasses(struct FPrimaryAssetId& WorldAssetId, TSet<TSoftClassPtr<class UClass>>* OutGameRulesetClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetGameRulesetClasses");

	Params::DFBlueprintFunctions_GetMapAssetGameRulesetClasses Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGameRulesetClasses != nullptr)
		*OutGameRulesetClasses = std::move(Parms.OutGameRulesetClasses);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetNameForDisplay
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDFBlueprintFunctions::GetMapAssetNameForDisplay(struct FPrimaryAssetId& WorldAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetNameForDisplay");

	Params::DFBlueprintFunctions_GetMapAssetNameForDisplay Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetPreviewBannerImg
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        OutMapPreviewBannerImgRef                              (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetPreviewBannerImg(struct FPrimaryAssetId& WorldAssetId, TSoftObjectPtr<class UTexture2D>* OutMapPreviewBannerImgRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetPreviewBannerImg");

	Params::DFBlueprintFunctions_GetMapAssetPreviewBannerImg Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapPreviewBannerImgRef != nullptr)
		*OutMapPreviewBannerImgRef = Parms.OutMapPreviewBannerImgRef;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetPreviewImg
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        OutMapPreviewImgRef                                    (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetPreviewImg(struct FPrimaryAssetId& WorldAssetId, TSoftObjectPtr<class UTexture2D>* OutMapPreviewImgRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetPreviewImg");

	Params::DFBlueprintFunctions_GetMapAssetPreviewImg Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapPreviewImgRef != nullptr)
		*OutMapPreviewImgRef = Parms.OutMapPreviewImgRef;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetSupportedGameModes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<TSoftClassPtr<class UClass>>       OutSupportedGameModes                                  (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetSupportedGameModes(struct FPrimaryAssetId& WorldAssetId, TSet<TSoftClassPtr<class UClass>>* OutSupportedGameModes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetSupportedGameModes");

	Params::DFBlueprintFunctions_GetMapAssetSupportedGameModes Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSupportedGameModes != nullptr)
		*OutSupportedGameModes = std::move(Parms.OutSupportedGameModes);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapAssetVisibleInMapSelectUI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  WorldAssetId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutVisibleInMapSelectUI                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::GetMapAssetVisibleInMapSelectUI(struct FPrimaryAssetId& WorldAssetId, bool* bOutVisibleInMapSelectUI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapAssetVisibleInMapSelectUI");

	Params::DFBlueprintFunctions_GetMapAssetVisibleInMapSelectUI Parms{};

	Parms.WorldAssetId = std::move(WorldAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutVisibleInMapSelectUI != nullptr)
		*bOutVisibleInMapSelectUI = Parms.bOutVisibleInMapSelectUI;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetMapName(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapName");

	Params::DFBlueprintFunctions_GetMapName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetMapNameForDisplay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDFBlueprintFunctions::GetMapNameForDisplay(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetMapNameForDisplay");

	Params::DFBlueprintFunctions_GetMapNameForDisplay Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetNumShotsFiredBPCompat
// (Final, Native, Static, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRepShotInfo                     Counter                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRepShotInfo                     PreviousCounter                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFBlueprintFunctions::GetNumShotsFiredBPCompat(struct FRepShotInfo& Counter, struct FRepShotInfo& PreviousCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetNumShotsFiredBPCompat");

	Params::DFBlueprintFunctions_GetNumShotsFiredBPCompat Parms{};

	Parms.Counter = std::move(Counter);
	Parms.PreviousCounter = std::move(PreviousCounter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetPluginFriendlyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PluginName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDFBlueprintFunctions::GetPluginFriendlyName(const class FString& PluginName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetPluginFriendlyName");

	Params::DFBlueprintFunctions_GetPluginFriendlyName Parms{};

	Parms.PluginName = std::move(PluginName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetShotCounterBPCompat
// (Final, Native, Static, Protected, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRepShotInfo                     Counter                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFBlueprintFunctions::GetShotCounterBPCompat(struct FRepShotInfo& Counter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetShotCounterBPCompat");

	Params::DFBlueprintFunctions_GetShotCounterBPCompat Parms{};

	Parms.Counter = std::move(Counter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetStartSpot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDFBlueprintFunctions::GetStartSpot(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetStartSpot");

	Params::DFBlueprintFunctions_GetStartSpot Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetSurfaceName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPhysicalSurface                        SurfaceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDFBlueprintFunctions::GetSurfaceName(EPhysicalSurface SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetSurfaceName");

	Params::DFBlueprintFunctions_GetSurfaceName Parms{};

	Parms.SurfaceType = SurfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetTargetLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           RequestedBy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDFBlueprintFunctions::GetTargetLocation(class AActor* Actor, class AActor* RequestedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetTargetLocation");

	Params::DFBlueprintFunctions_GetTargetLocation Parms{};

	Parms.Actor = Actor;
	Parms.RequestedBy = RequestedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetTeamNum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UDFBlueprintFunctions::GetTeamNum(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetTeamNum");

	Params::DFBlueprintFunctions_GetTeamNum Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetTeamStateFromTeamId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamIdNum                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFTeamState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFTeamState* UDFBlueprintFunctions::GetTeamStateFromTeamId(class UObject* WorldContextObject, uint8 TeamIdNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetTeamStateFromTeamId");

	Params::DFBlueprintFunctions_GetTeamStateFromTeamId Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamIdNum = TeamIdNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetVisibilityDefault
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDFBlueprintFunctions::GetVisibilityDefault(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetVisibilityDefault");

	Params::DFBlueprintFunctions_GetVisibilityDefault Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetVOIPTalkerForPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     InPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVOIPTalker*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVOIPTalker* UDFBlueprintFunctions::GetVOIPTalkerForPlayer(class APlayerState* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetVOIPTalkerForPlayer");

	Params::DFBlueprintFunctions_GetVOIPTalkerForPlayer Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.GetWorldSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWorldSettings*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldSettings* UDFBlueprintFunctions::GetWorldSettings(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "GetWorldSettings");

	Params::DFBlueprintFunctions_GetWorldSettings Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.HasFiringStopped
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRepShotInfo                     Counter                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::HasFiringStopped(struct FRepShotInfo& Counter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "HasFiringStopped");

	Params::DFBlueprintFunctions_HasFiringStopped Parms{};

	Parms.Counter = std::move(Counter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.HasOptions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Keys                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchAll                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::HasOptions(const class FString& Options, TArray<class FString>& Keys, bool bMatchAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "HasOptions");

	Params::DFBlueprintFunctions_HasOptions Parms{};

	Parms.Options = std::move(Options);
	Parms.Keys = std::move(Keys);
	Parms.bMatchAll = bMatchAll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsEmptyOrWhitespace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsEmptyOrWhitespace(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsEmptyOrWhitespace");

	Params::DFBlueprintFunctions_IsEmptyOrWhitespace Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsLocallyPlayerControlled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsLocallyPlayerControlled(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsLocallyPlayerControlled");

	Params::DFBlueprintFunctions_IsLocallyPlayerControlled Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsPendingKillPending
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsPendingKillPending(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsPendingKillPending");

	Params::DFBlueprintFunctions_IsPendingKillPending Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsPlayerMuted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     PSToCheck                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsPlayerMuted(class APlayerController* PC, class APlayerState* PSToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsPlayerMuted");

	Params::DFBlueprintFunctions_IsPlayerMuted Parms{};

	Parms.PC = PC;
	Parms.PSToCheck = PSToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsPlayerTalking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerPS                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsPlayerTalking(class APlayerState* PlayerPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsPlayerTalking");

	Params::DFBlueprintFunctions_IsPlayerTalking Parms{};

	Parms.PlayerPS = PlayerPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsPlayInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsPlayInEditor(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsPlayInEditor");

	Params::DFBlueprintFunctions_IsPlayInEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsValidActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsValidActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsValidActor");

	Params::DFBlueprintFunctions_IsValidActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.IsVOIPTalkerStillAlive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UVOIPTalker*                      InTalker                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::IsVOIPTalkerStillAlive(class UVOIPTalker* InTalker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "IsVOIPTalkerStillAlive");

	Params::DFBlueprintFunctions_IsVOIPTalkerStillAlive Parms{};

	Parms.InTalker = InTalker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.PrintStringToLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELogVerbosityBP                         InLogVerbosity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintStackTrace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::PrintStringToLog(class UObject* WorldContextObject, const class FString& InString, ELogVerbosityBP InLogVerbosity, bool bPrintStackTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "PrintStringToLog");

	Params::DFBlueprintFunctions_PrintStringToLog Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InString = std::move(InString);
	Parms.InLogVerbosity = InLogVerbosity;
	Parms.bPrintStackTrace = bPrintStackTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.PrintTextToLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (ConstParm, Parm, NativeAccessSpecifierPublic)
// ELogVerbosityBP                         InLogVerbosity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintStackTrace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::PrintTextToLog(class UObject* WorldContextObject, class FText InText, ELogVerbosityBP InLogVerbosity, bool bPrintStackTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "PrintTextToLog");

	Params::DFBlueprintFunctions_PrintTextToLog Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InText = InText;
	Parms.InLogVerbosity = InLogVerbosity;
	Parms.bPrintStackTrace = bPrintStackTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.ResetAllPlayerVoiceTalkers
// (Final, Native, Static, Public, BlueprintCallable)

void UDFBlueprintFunctions::ResetAllPlayerVoiceTalkers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "ResetAllPlayerVoiceTalkers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.ResetPlayerVoiceTalker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     InPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::ResetPlayerVoiceTalker(class APlayerState* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "ResetPlayerVoiceTalker");

	Params::DFBlueprintFunctions_ResetPlayerVoiceTalker Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.SetCastStaticShadow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCastStaticShadow                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::SetCastStaticShadow(class UPrimitiveComponent* PrimitiveComponent, bool bCastStaticShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "SetCastStaticShadow");

	Params::DFBlueprintFunctions_SetCastStaticShadow Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.bCastStaticShadow = bCastStaticShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.SetNetAddressable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  ActorComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::SetNetAddressable(class UActorComponent* ActorComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "SetNetAddressable");

	Params::DFBlueprintFunctions_SetNetAddressable Parms{};

	Parms.ActorComp = ActorComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.SetStartSpot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewStartSpot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::SetStartSpot(class AController* Controller, class AActor* NewStartSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "SetStartSpot");

	Params::DFBlueprintFunctions_SetStartSpot Parms{};

	Parms.Controller = Controller;
	Parms.NewStartSpot = NewStartSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.SetTeamNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeamNum                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::SetTeamNum(class AActor* Target, uint8 NewTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "SetTeamNum");

	Params::DFBlueprintFunctions_SetTeamNum Parms{};

	Parms.Target = Target;
	Parms.NewTeamNum = NewTeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.SpawnImpactFXFromDamageEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADFBaseImpactEffect>  ImpactClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageTaken                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitInstigator                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseImpactEffect*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseImpactEffect* UDFBlueprintFunctions::SpawnImpactFXFromDamageEvent(class UObject* WorldContextObject, TSubclassOf<class ADFBaseImpactEffect> ImpactClass, float DamageTaken, struct FDamageEvent& DamageEvent, class AActor* HitActor, class AActor* HitInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "SpawnImpactFXFromDamageEvent");

	Params::DFBlueprintFunctions_SpawnImpactFXFromDamageEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ImpactClass = ImpactClass;
	Parms.DamageTaken = DamageTaken;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.HitActor = HitActor;
	Parms.HitInstigator = HitInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.SpawnImpactFXFromHitResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADFBaseImpactEffect>  ImpactClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ADFBaseImpactEffect*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseImpactEffect* UDFBlueprintFunctions::SpawnImpactFXFromHitResult(class UObject* WorldContextObject, TSubclassOf<class ADFBaseImpactEffect> ImpactClass, struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "SpawnImpactFXFromHitResult");

	Params::DFBlueprintFunctions_SpawnImpactFXFromHitResult Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ImpactClass = ImpactClass;
	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.TextIsEmptyOrWhitespace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::TextIsEmptyOrWhitespace(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "TextIsEmptyOrWhitespace");

	Params::DFBlueprintFunctions_TextIsEmptyOrWhitespace Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFBlueprintFunctions.TransferInventoryItems
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDFInventoryComponent*            FromInv                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFInventoryComponent*            ToInv                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepLoadedAmmo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFBlueprintFunctions::TransferInventoryItems(class UDFInventoryComponent* FromInv, class UDFInventoryComponent* ToInv, bool bKeepLoadedAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "TransferInventoryItems");

	Params::DFBlueprintFunctions_TransferInventoryItems Parms{};

	Parms.FromInv = FromInv;
	Parms.ToInv = ToInv;
	Parms.bKeepLoadedAmmo = bKeepLoadedAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFBlueprintFunctions.WasShotFired
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRepShotInfo                     Counter                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRepShotInfo                     OtherCounter                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFBlueprintFunctions::WasShotFired(struct FRepShotInfo& Counter, struct FRepShotInfo& OtherCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFBlueprintFunctions", "WasShotFired");

	Params::DFBlueprintFunctions_WasShotFired Parms{};

	Parms.Counter = std::move(Counter);
	Parms.OtherCounter = std::move(OtherCounter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTeamAgentInterface.EventSetTeamNum
// (Event, Public, BlueprintEvent)
// Parameters:
// uint8                                   NewTeamNum                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDFTeamAgentInterface::EventSetTeamNum(uint8 NewTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamAgentInterface", "EventSetTeamNum");

	Params::DFTeamAgentInterface_EventSetTeamNum Parms{};

	Parms.NewTeamNum = NewTeamNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFTeamAgentInterface.EventGetTeamNum
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 IDFTeamAgentInterface::EventGetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamAgentInterface", "EventGetTeamNum");

	Params::DFTeamAgentInterface_EventGetTeamNum Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.ReceiveReset
// (Event, Protected, BlueprintEvent)

void UDFCharacterLeanHandler::ReceiveReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "ReceiveReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFCharacterLeanHandler.ReceiveTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFCharacterLeanHandler::ReceiveTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "ReceiveTick");

	Params::DFCharacterLeanHandler_ReceiveTick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFCharacterLeanHandler.UpdateLeanDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELeanDirection                          NewLeanDir                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFCharacterLeanHandler::UpdateLeanDirection(ELeanDirection NewLeanDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "UpdateLeanDirection");

	Params::DFCharacterLeanHandler_UpdateLeanDirection Parms{};

	Parms.NewLeanDir = NewLeanDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFCharacterLeanHandler.DetermineLeanTargetAmount
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanDirection                          DesiredLeanDir                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoving                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterLeanHandler::DetermineLeanTargetAmount(ELeanDirection DesiredLeanDir, bool bMoving) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "DetermineLeanTargetAmount");

	Params::DFCharacterLeanHandler_DetermineLeanTargetAmount Parms{};

	Parms.DesiredLeanDir = DesiredLeanDir;
	Parms.bMoving = bMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetLeanRollRot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DesiredLeanAmt                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterLeanHandler::GetLeanRollRot(float DesiredLeanAmt) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetLeanRollRot");

	Params::DFCharacterLeanHandler_GetLeanRollRot Parms{};

	Parms.DesiredLeanAmt = DesiredLeanAmt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetLeanXOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DesiredLeanAmt                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterLeanHandler::GetLeanXOffset(float DesiredLeanAmt) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetLeanXOffset");

	Params::DFCharacterLeanHandler_GetLeanXOffset Parms{};

	Parms.DesiredLeanAmt = DesiredLeanAmt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetLeanYOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DesiredLeanAmt                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterLeanHandler::GetLeanYOffset(float DesiredLeanAmt) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetLeanYOffset");

	Params::DFCharacterLeanHandler_GetLeanYOffset Parms{};

	Parms.DesiredLeanAmt = DesiredLeanAmt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetMaxLeanXOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanDirection                          NewLeanDir                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterStance                        LeanStance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoving                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterLeanHandler::GetMaxLeanXOffset(ELeanDirection NewLeanDir, ECharacterStance LeanStance, bool bMoving) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetMaxLeanXOffset");

	Params::DFCharacterLeanHandler_GetMaxLeanXOffset Parms{};

	Parms.NewLeanDir = NewLeanDir;
	Parms.LeanStance = LeanStance;
	Parms.bMoving = bMoving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetOwningCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseCharacter*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseCharacter* UDFCharacterLeanHandler::GetOwningCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetOwningCharacter");

	Params::DFCharacterLeanHandler_GetOwningCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetOwningCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDFCharacterMovementComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFCharacterMovementComponent* UDFCharacterLeanHandler::GetOwningCharacterMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetOwningCharacterMovement");

	Params::DFCharacterLeanHandler_GetOwningCharacterMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetPreviousStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterStance                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterStance UDFCharacterLeanHandler::GetPreviousStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetPreviousStance");

	Params::DFCharacterLeanHandler_GetPreviousStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterStance                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterStance UDFCharacterLeanHandler::GetStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "GetStance");

	Params::DFCharacterLeanHandler_GetStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.IsLeaning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterLeanHandler::IsLeaning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "IsLeaning");

	Params::DFCharacterLeanHandler_IsLeaning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterLeanHandler.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterLeanHandler::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterLeanHandler", "IsMoving");

	Params::DFCharacterLeanHandler_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.ClampSpeedMultiplier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MultValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterMovementComponent::ClampSpeedMultiplier(float MultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "ClampSpeedMultiplier");

	Params::DFCharacterMovementComponent_ClampSpeedMultiplier Parms{};

	Parms.MultValue = MultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.GetDFCharacterOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseCharacter*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseCharacter* UDFCharacterMovementComponent::GetDFCharacterOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "GetDFCharacterOwner");

	Params::DFCharacterMovementComponent_GetDFCharacterOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.GetLeanAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDFCharacterMovementComponent::GetLeanAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "GetLeanAmount");

	Params::DFCharacterMovementComponent_GetLeanAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.GetLeanDirection
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanDirection                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELeanDirection UDFCharacterMovementComponent::GetLeanDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "GetLeanDirection");

	Params::DFCharacterMovementComponent_GetLeanDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.GetPreviousStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterStance                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterStance UDFCharacterMovementComponent::GetPreviousStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "GetPreviousStance");

	Params::DFCharacterMovementComponent_GetPreviousStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECharacterStance                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECharacterStance UDFCharacterMovementComponent::GetStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "GetStance");

	Params::DFCharacterMovementComponent_GetStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsAiming
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsAiming");

	Params::DFCharacterMovementComponent_IsAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsAlive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsAlive");

	Params::DFCharacterMovementComponent_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsCrawling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsCrawling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsCrawling");

	Params::DFCharacterMovementComponent_IsCrawling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsLeaning
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsLeaning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsLeaning");

	Params::DFCharacterMovementComponent_IsLeaning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsMoving
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIgnoreZVel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsMoving(bool bIgnoreZVel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsMoving");

	Params::DFCharacterMovementComponent_IsMoving Parms{};

	Parms.bIgnoreZVel = bIgnoreZVel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsMovingForward
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsMovingForward() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsMovingForward");

	Params::DFCharacterMovementComponent_IsMovingForward Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsProne
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsProne() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsProne");

	Params::DFCharacterMovementComponent_IsProne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsReloading
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsReloading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsReloading");

	Params::DFCharacterMovementComponent_IsReloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsSprinting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsSprinting");

	Params::DFCharacterMovementComponent_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsStanding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsStanding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsStanding");

	Params::DFCharacterMovementComponent_IsStanding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsStrafing
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsStrafing(float Threshold) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsStrafing");

	Params::DFCharacterMovementComponent_IsStrafing Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.IsVaulting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFCharacterMovementComponent::IsVaulting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "IsVaulting");

	Params::DFCharacterMovementComponent_IsVaulting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCharacterMovementComponent.VaultTrace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDFVaultTraceResult              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDFVaultTraceResult UDFCharacterMovementComponent::VaultTrace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCharacterMovementComponent", "VaultTrace");

	Params::DFCharacterMovementComponent_VaultTrace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFCheatManager.ToggleGunInfiniteAmmo
// (Exec, Native, Public, BlueprintCallable)

void UDFCheatManager::ToggleGunInfiniteAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCheatManager", "ToggleGunInfiniteAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFCheatManager.ToggleGunInfiniteClipAmmo
// (Exec, Native, Public, BlueprintCallable)

void UDFCheatManager::ToggleGunInfiniteClipAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCheatManager", "ToggleGunInfiniteClipAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFCheatManager.ToggleGunRecoil
// (Exec, Native, Public, BlueprintCallable)

void UDFCheatManager::ToggleGunRecoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCheatManager", "ToggleGunRecoil");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFCheatManager.ToggleItemDebug
// (Exec, Native, Public, BlueprintCallable)

void UDFCheatManager::ToggleItemDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFCheatManager", "ToggleItemDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFFunctionLibrary.ClearMeshAnimInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshToClear                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFFunctionLibrary::ClearMeshAnimInstance(class USkeletalMeshComponent* MeshToClear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFFunctionLibrary", "ClearMeshAnimInstance");

	Params::DFFunctionLibrary_ClearMeshAnimInstance Parms{};

	Parms.MeshToClear = MeshToClear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFFunctionLibrary.SetEnableAutoBlendOutForActiveMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           AnimSourceMesh                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewEnableAutoBlendOut                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFFunctionLibrary::SetEnableAutoBlendOutForActiveMontage(class UAnimMontage* AnimMontage, class USkeletalMeshComponent* AnimSourceMesh, bool bNewEnableAutoBlendOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFFunctionLibrary", "SetEnableAutoBlendOutForActiveMontage");

	Params::DFFunctionLibrary_SetEnableAutoBlendOutForActiveMontage Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.AnimSourceMesh = AnimSourceMesh;
	Parms.bNewEnableAutoBlendOut = bNewEnableAutoBlendOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.Init
// (Event, Protected, BlueprintEvent)

void UDFGameRulesetBase::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "Init");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFGameRulesetBase.MatchHasEnded
// (Native, Event, Public, BlueprintEvent)

void UDFGameRulesetBase::MatchHasEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "MatchHasEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerDied
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerDied(class AController* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerDied");

	Params::DFGameRulesetBase_PlayerDied Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerJoined
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerJoined(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerJoined");

	Params::DFGameRulesetBase_PlayerJoined Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerJoinedTeam
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      JoiningPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerJoinedTeam(class AController* JoiningPlayer, uint8 TeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerJoinedTeam");

	Params::DFGameRulesetBase_PlayerJoinedTeam Parms{};

	Parms.JoiningPlayer = JoiningPlayer;
	Parms.TeamNum = TeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerKilled
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerKilled(class AController* Killer, class AController* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerKilled");

	Params::DFGameRulesetBase_PlayerKilled Parms{};

	Parms.Killer = Killer;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerPostLogin
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerPostLogin(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerPostLogin");

	Params::DFGameRulesetBase_PlayerPostLogin Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerPostLogout
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      ExitingPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerPostLogout(class AController* ExitingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerPostLogout");

	Params::DFGameRulesetBase_PlayerPostLogout Parms{};

	Parms.ExitingPlayer = ExitingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerSpawn
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPlayerPawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerSpawn(class AController* Player, class APawn* NewPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerSpawn");

	Params::DFGameRulesetBase_PlayerSpawn Parms{};

	Parms.Player = Player;
	Parms.NewPlayerPawn = NewPlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerSuicide
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerSuicide(class AController* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerSuicide");

	Params::DFGameRulesetBase_PlayerSuicide Parms{};

	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.PlayerWounded
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::PlayerWounded(class AController* Victim, float DamageAmount, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "PlayerWounded");

	Params::DFGameRulesetBase_PlayerWounded Parms{};

	Parms.Victim = Victim;
	Parms.DamageAmount = DamageAmount;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFGameRulesetBase.ReceiveTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::ReceiveTick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "ReceiveTick");

	Params::DFGameRulesetBase_ReceiveTick Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFGameRulesetBase.RegisterActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           RegisteredActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::RegisterActor(class AActor* RegisteredActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "RegisterActor");

	Params::DFGameRulesetBase_RegisterActor Parms{};

	Parms.RegisteredActor = RegisteredActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFGameRulesetBase.UnregisterActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           UnregisteredActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFGameRulesetBase::UnregisterActor(class AActor* UnregisteredActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "UnregisterActor");

	Params::DFGameRulesetBase_UnregisterActor Parms{};

	Parms.UnregisteredActor = UnregisteredActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFGameRulesetBase.GetGameMode
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseGameMode*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseGameMode* UDFGameRulesetBase::GetGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "GetGameMode");

	Params::DFGameRulesetBase_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFGameRulesetBase.GetGameState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseGameState*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADFBaseGameState* UDFGameRulesetBase::GetGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFGameRulesetBase", "GetGameState");

	Params::DFGameRulesetBase_GetGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.Add
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseItem*                      Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::Add(class ADFBaseItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "Add");

	Params::DFInventoryComponent_Add Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.AddDefaultInventoryItems
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UDFInventoryComponent::AddDefaultInventoryItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "AddDefaultInventoryItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFInventoryComponent.Clear
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDestroyItems                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFInventoryComponent::Clear(bool bDestroyItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "Clear");

	Params::DFInventoryComponent_Clear Parms{};

	Parms.bDestroyItems = bDestroyItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFInventoryComponent.Remove
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADFBaseItem*                      Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestroyItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::Remove(class ADFBaseItem* Item, bool bDestroyItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "Remove");

	Params::DFInventoryComponent_Remove Parms{};

	Parms.Item = Item;
	Parms.bDestroyItem = bDestroyItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.RemoveItemAt
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseItem*                      OutRemovedItem                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestroyItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::RemoveItemAt(int32 Param_Index, class ADFBaseItem** OutRemovedItem, bool bDestroyItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "RemoveItemAt");

	Params::DFInventoryComponent_RemoveItemAt Parms{};

	Parms.Param_Index = Param_Index;
	Parms.bDestroyItem = bDestroyItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRemovedItem != nullptr)
		*OutRemovedItem = Parms.OutRemovedItem;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.Find
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADFBaseItem*                      ItemToCompare                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::Find(class ADFBaseItem* ItemToCompare, int32* OutIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "Find");

	Params::DFInventoryComponent_Find Parms{};

	Parms.ItemToCompare = ItemToCompare;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.FindItemByClass
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ADFBaseItem>          ItemClass                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseItem*                      OutItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::FindItemByClass(TSubclassOf<class ADFBaseItem>& ItemClass, class ADFBaseItem** OutItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "FindItemByClass");

	Params::DFInventoryComponent_FindItemByClass Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItem != nullptr)
		*OutItem = Parms.OutItem;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.GetItem
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADFBaseItem*                      OutItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::GetItem(int32 Param_Index, class ADFBaseItem** OutItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "GetItem");

	Params::DFInventoryComponent_GetItem Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItem != nullptr)
		*OutItem = Parms.OutItem;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.IsValidIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFInventoryComponent::IsValidIndex(int32 Param_Index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "IsValidIndex");

	Params::DFInventoryComponent_IsValidIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFInventoryComponent.Size
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFInventoryComponent::Size() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFInventoryComponent", "Size");

	Params::DFInventoryComponent_Size Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTeamState.ReceiveInitTeam
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
// class UDFTeamDefinition*                InTeamDef                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADFTeamState::ReceiveInitTeam(class UDFTeamDefinition* InTeamDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamState", "ReceiveInitTeam");

	Params::DFTeamState_ReceiveInitTeam Parms{};

	Parms.InTeamDef = InTeamDef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFTeamState.ReceivePostInitTeam
// (Event, Protected, BlueprintEvent)

void ADFTeamState::ReceivePostInitTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamState", "ReceivePostInitTeam");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFTeamState.GetFactionInfo
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UDFFactionInfo*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDFFactionInfo* ADFTeamState::GetFactionInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamState", "GetFactionInfo");

	Params::DFTeamState_GetFactionInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTeamState.IsPendingSetupBP
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFTeamState::IsPendingSetupBP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamState", "IsPendingSetupBP");

	Params::DFTeamState_IsPendingSetupBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFTeamState.IsReadyToInitialize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADFTeamState::IsReadyToInitialize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFTeamState", "IsReadyToInitialize");

	Params::DFTeamState_IsReadyToInitialize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFThrowableWeapAnimInstInterface.PlayCockMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFThrowableWeapAnimInstInterface::PlayCockMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFThrowableWeapAnimInstInterface", "PlayCockMontage");

	Params::DFThrowableWeapAnimInstInterface_PlayCockMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFThrowableWeapAnimInstInterface.PlayThrowOverhandMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFThrowableWeapAnimInstInterface::PlayThrowOverhandMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFThrowableWeapAnimInstInterface", "PlayThrowOverhandMontage");

	Params::DFThrowableWeapAnimInstInterface_PlayThrowOverhandMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFThrowableWeapAnimInstInterface.PlayThrowUnderhandMontage
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDFThrowableWeapAnimInstInterface::PlayThrowUnderhandMontage(class UAnimMontage* MontageToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFThrowableWeapAnimInstInterface", "PlayThrowUnderhandMontage");

	Params::DFThrowableWeapAnimInstInterface_PlayThrowUnderhandMontage Parms{};

	Parms.MontageToPlay = MontageToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.GetVoteSelections
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDFPlayerVoteSelection>   OutVoteSelections                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFVoteIssue::GetVoteSelections(TArray<struct FDFPlayerVoteSelection>* OutVoteSelections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "GetVoteSelections");

	Params::DFVoteIssue_GetVoteSelections Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVoteSelections != nullptr)
		*OutVoteSelections = std::move(Parms.OutVoteSelections);
}


// Function DonkehFramework.DFVoteIssue.ReceiveVoteInit
// (Event, Protected, BlueprintEvent)

void UDFVoteIssue::ReceiveVoteInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "ReceiveVoteInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFVoteIssue.ReceiveVoteReset
// (Event, Protected, BlueprintEvent)

void UDFVoteIssue::ReceiveVoteReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "ReceiveVoteReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DonkehFramework.DFVoteIssue.ResetVote
// (Final, Native, Public, BlueprintCallable)

void UDFVoteIssue::ResetVote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "ResetVote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFVoteIssue.VoteFailed
// (Native, Event, Public, BlueprintEvent)

void UDFVoteIssue::VoteFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "VoteFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFVoteIssue.VotePassed
// (Native, Event, Public, BlueprintEvent)

void UDFVoteIssue::VotePassed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "VotePassed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFVoteIssue.AllowsStartVoteBy
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class APlayerState*                     InvokingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVoteIssue::AllowsStartVoteBy(class APlayerState* InvokingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "AllowsStartVoteBy");

	Params::DFVoteIssue_AllowsStartVoteBy Parms{};

	Parms.InvokingPlayer = InvokingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.AllowsVoteFrom
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class APlayerState*                     VoterPS                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVoteIssue::AllowsVoteFrom(class APlayerState* VoterPS) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "AllowsVoteFrom");

	Params::DFVoteIssue_AllowsVoteFrom Parms{};

	Parms.VoterPS = VoterPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.CanStartVote
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     InvokingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVoteIssue::CanStartVote(class APlayerState* InvokingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "CanStartVote");

	Params::DFVoteIssue_CanStartVote Parms{};

	Parms.InvokingPlayer = InvokingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.CanVoteOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     VoterPS                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVoteIssue::CanVoteOn(class APlayerState* VoterPS) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "CanVoteOn");

	Params::DFVoteIssue_CanVoteOn Parms{};

	Parms.VoterPS = VoterPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.DetermineVoteStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDFVoteStatus                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDFVoteStatus UDFVoteIssue::DetermineVoteStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "DetermineVoteStatus");

	Params::DFVoteIssue_DetermineVoteStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.GetEligibleVoterCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFVoteIssue::GetEligibleVoterCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "GetEligibleVoterCount");

	Params::DFVoteIssue_GetEligibleVoterCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.GetEligibleVoters
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APlayerState*>             OutEligibleVoters                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFVoteIssue::GetEligibleVoters(TArray<class APlayerState*>* OutEligibleVoters) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "GetEligibleVoters");

	Params::DFVoteIssue_GetEligibleVoters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEligibleVoters != nullptr)
		*OutEligibleVoters = std::move(Parms.OutEligibleVoters);
}


// Function DonkehFramework.DFVoteIssue.GetOwningVotingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDFVotingComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFVotingComponent* UDFVoteIssue::GetOwningVotingComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "GetOwningVotingComponent");

	Params::DFVoteIssue_GetOwningVotingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.GetRequiredVoteCountToPass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDFVoteIssue::GetRequiredVoteCountToPass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "GetRequiredVoteCountToPass");

	Params::DFVoteIssue_GetRequiredVoteCountToPass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVoteIssue.GetYesNoVoteCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   OutYesVotes                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutNoVotes                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFVoteIssue::GetYesNoVoteCounts(int32* OutYesVotes, int32* OutNoVotes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssue", "GetYesNoVoteCounts");

	Params::DFVoteIssue_GetYesNoVoteCounts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutYesVotes != nullptr)
		*OutYesVotes = Parms.OutYesVotes;

	if (OutNoVotes != nullptr)
		*OutNoVotes = Parms.OutNoVotes;
}


// Function DonkehFramework.DFVoteIssuePlayer.CanInitiateVoteWithTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     TargetPS                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVoteIssuePlayer::CanInitiateVoteWithTarget(class APlayerState* TargetPS) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVoteIssuePlayer", "CanInitiateVoteWithTarget");

	Params::DFVoteIssuePlayer_CanInitiateVoteWithTarget Parms{};

	Parms.TargetPS = TargetPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.CastVote
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     InvokingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VoteSelectionID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::CastVote(class APlayerState* InvokingPlayer, int32 VoteSelectionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "CastVote");

	Params::DFVotingComponent_CastVote Parms{};

	Parms.InvokingPlayer = InvokingPlayer;
	Parms.VoteSelectionID = VoteSelectionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.InitiateVote
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerState*                     InvokingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDFVoteIssueContext              IssueContext                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::InitiateVote(class APlayerState* InvokingPlayer, TSubclassOf<class UDFVoteIssue> IssueClass, struct FDFVoteIssueContext& IssueContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "InitiateVote");

	Params::DFVotingComponent_InitiateVote Parms{};

	Parms.InvokingPlayer = InvokingPlayer;
	Parms.IssueClass = IssueClass;
	Parms.IssueContext = std::move(IssueContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DonkehFramework.DFVotingComponent.OnPlayerVoteIssueEventDynamic__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UDFVotingComponent*               SourceVotingComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDFVotingComponent::OnPlayerVoteIssueEventDynamic__DelegateSignature(class UDFVotingComponent* SourceVotingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "OnPlayerVoteIssueEventDynamic__DelegateSignature");

	Params::DFVotingComponent_OnPlayerVoteIssueEventDynamic__DelegateSignature Parms{};

	Parms.SourceVotingComponent = SourceVotingComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DonkehFramework.DFVotingComponent.OnRep_ActiveVoteInfo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FDFActiveVoteInfo                PreviousValue                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDFVotingComponent::OnRep_ActiveVoteInfo(struct FDFActiveVoteInfo& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "OnRep_ActiveVoteInfo");

	Params::DFVotingComponent_OnRep_ActiveVoteInfo Parms{};

	Parms.PreviousValue = std::move(PreviousValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.DFVotingComponent.CanCastVote
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     VotingPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VoteSelectionID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::CanCastVote(class APlayerState* VotingPlayer, int32 VoteSelectionID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "CanCastVote");

	Params::DFVotingComponent_CanCastVote Parms{};

	Parms.VotingPlayer = VotingPlayer;
	Parms.VoteSelectionID = VoteSelectionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.CanInitiateVote
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     InvokingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::CanInitiateVote(class APlayerState* InvokingPlayer, TSubclassOf<class UDFVoteIssue> IssueClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "CanInitiateVote");

	Params::DFVotingComponent_CanInitiateVote Parms{};

	Parms.InvokingPlayer = InvokingPlayer;
	Parms.IssueClass = IssueClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.CanVoteTargetPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     TargetPS                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::CanVoteTargetPlayer(class APlayerState* TargetPS, TSubclassOf<class UDFVoteIssue> IssueClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "CanVoteTargetPlayer");

	Params::DFVotingComponent_CanVoteTargetPlayer Parms{};

	Parms.TargetPS = TargetPS;
	Parms.IssueClass = IssueClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.GetVoteIssueDefinitionForClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDFVoteIssueDefinition           OutIssueDefinition                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::GetVoteIssueDefinitionForClass(TSubclassOf<class UDFVoteIssue> IssueClass, struct FDFVoteIssueDefinition* OutIssueDefinition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "GetVoteIssueDefinitionForClass");

	Params::DFVotingComponent_GetVoteIssueDefinitionForClass Parms{};

	Parms.IssueClass = IssueClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIssueDefinition != nullptr)
		*OutIssueDefinition = std::move(Parms.OutIssueDefinition);

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.GetVoteIssueForClass
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UDFVoteIssue>         IssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFVoteIssue*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFVoteIssue* UDFVotingComponent::GetVoteIssueForClass(TSubclassOf<class UDFVoteIssue> IssueClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "GetVoteIssueForClass");

	Params::DFVotingComponent_GetVoteIssueForClass Parms{};

	Parms.IssueClass = IssueClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingComponent.IsVotingInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingComponent::IsVotingInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DFVotingComponent", "IsVotingInProgress");

	Params::DFVotingComponent_IsVotingInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingStatics.GetGameStateVotingComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDFVotingComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDFVotingComponent* UDFVotingStatics::GetGameStateVotingComponent(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFVotingStatics", "GetGameStateVotingComponent");

	Params::DFVotingStatics_GetGameStateVotingComponent Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingStatics.IsValidVotingPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDFVotingStatics::IsValidVotingPlayer(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFVotingStatics", "IsValidVotingPlayer");

	Params::DFVotingStatics_IsValidVotingPlayer Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingStatics.MakeVoteContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     TargetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDFVoteIssueContext              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDFVoteIssueContext UDFVotingStatics::MakeVoteContext(class APlayerState* TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFVotingStatics", "MakeVoteContext");

	Params::DFVotingStatics_MakeVoteContext Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.DFVotingStatics.VoteInfoGetPromptTextForDisplay
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDFActiveVoteInfo                VoteInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDFVotingStatics::VoteInfoGetPromptTextForDisplay(struct FDFActiveVoteInfo& VoteInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DFVotingStatics", "VoteInfoGetPromptTextForDisplay");

	Params::DFVotingStatics_VoteInfoGetPromptTextForDisplay Parms{};

	Parms.VoteInfo = std::move(VoteInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.GameSessionBlueprintLibrary.AddAdmin
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                AdminPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSessionBlueprintLibrary::AddAdmin(class UObject* WorldContextObj, class APlayerController* AdminPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSessionBlueprintLibrary", "AddAdmin");

	Params::GameSessionBlueprintLibrary_AddAdmin Parms{};

	Parms.WorldContextObj = WorldContextObj;
	Parms.AdminPlayer = AdminPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.GameSessionBlueprintLibrary.GetMaxPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSessionBlueprintLibrary::GetMaxPlayers(class UObject* WorldContextObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSessionBlueprintLibrary", "GetMaxPlayers");

	Params::GameSessionBlueprintLibrary_GetMaxPlayers Parms{};

	Parms.WorldContextObj = WorldContextObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.GameSessionBlueprintLibrary.GetMaxSpectators
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSessionBlueprintLibrary::GetMaxSpectators(class UObject* WorldContextObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSessionBlueprintLibrary", "GetMaxSpectators");

	Params::GameSessionBlueprintLibrary_GetMaxSpectators Parms{};

	Parms.WorldContextObj = WorldContextObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.GameSessionBlueprintLibrary.GetMinPlayers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSessionBlueprintLibrary::GetMinPlayers(class UObject* WorldContextObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSessionBlueprintLibrary", "GetMinPlayers");

	Params::GameSessionBlueprintLibrary_GetMinPlayers Parms{};

	Parms.WorldContextObj = WorldContextObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.GameSessionBlueprintLibrary.RemoveAdmin
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                AdminPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSessionBlueprintLibrary::RemoveAdmin(class UObject* WorldContextObj, class APlayerController* AdminPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSessionBlueprintLibrary", "RemoveAdmin");

	Params::GameSessionBlueprintLibrary_RemoveAdmin Parms{};

	Parms.WorldContextObj = WorldContextObj;
	Parms.AdminPlayer = AdminPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.SpawnPointProviderInterface.CanRestartPlayerFromSpawnPointBP
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FSpawnPointDef                   SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>                PlayerPawnClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISpawnPointProviderInterface::CanRestartPlayerFromSpawnPointBP(struct FSpawnPointDef& SpawnPoint, class AController* Player, TSubclassOf<class APawn> PlayerPawnClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnPointProviderInterface", "CanRestartPlayerFromSpawnPointBP");

	Params::SpawnPointProviderInterface_CanRestartPlayerFromSpawnPointBP Parms{};

	Parms.SpawnPoint = std::move(SpawnPoint);
	Parms.Player = Player;
	Parms.PlayerPawnClass = PlayerPawnClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointProviderInterface.CanSpawnActorFromSpawnPointBP
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FSpawnPointDef                   SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               SpawnActorClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISpawnPointProviderInterface::CanSpawnActorFromSpawnPointBP(struct FSpawnPointDef& SpawnPoint, TSubclassOf<class AActor> SpawnActorClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnPointProviderInterface", "CanSpawnActorFromSpawnPointBP");

	Params::SpawnPointProviderInterface_CanSpawnActorFromSpawnPointBP Parms{};

	Parms.SpawnPoint = std::move(SpawnPoint);
	Parms.SpawnActorClass = SpawnActorClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointProviderInterface.FindSpawnPointBP
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// int32                                   SpawnPointID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnPointDef                   FoundSpawnPoint                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISpawnPointProviderInterface::FindSpawnPointBP(int32 SpawnPointID, struct FSpawnPointDef* FoundSpawnPoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnPointProviderInterface", "FindSpawnPointBP");

	Params::SpawnPointProviderInterface_FindSpawnPointBP Parms{};

	Parms.SpawnPointID = SpawnPointID;

	UObject::ProcessEvent(Func, &Parms);

	if (FoundSpawnPoint != nullptr)
		*FoundSpawnPoint = std::move(Parms.FoundSpawnPoint);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointProviderInterface.GetAllSpawnPointsBP
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FSpawnPointDef>           SpawnPoints                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ISpawnPointProviderInterface::GetAllSpawnPointsBP(TArray<struct FSpawnPointDef>* SpawnPoints) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnPointProviderInterface", "GetAllSpawnPointsBP");

	Params::SpawnPointProviderInterface_GetAllSpawnPointsBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnPoints != nullptr)
		*SpawnPoints = std::move(Parms.SpawnPoints);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointProviderInterface.GetSpawnPointCollisionHandlingOverrideBP
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FSpawnPointDef                   SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      OutSpawnCollisionMethod                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISpawnPointProviderInterface::GetSpawnPointCollisionHandlingOverrideBP(struct FSpawnPointDef& SpawnPoint, ESpawnActorCollisionHandlingMethod* OutSpawnCollisionMethod) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnPointProviderInterface", "GetSpawnPointCollisionHandlingOverrideBP");

	Params::SpawnPointProviderInterface_GetSpawnPointCollisionHandlingOverrideBP Parms{};

	Parms.SpawnPoint = std::move(SpawnPoint);

	UObject::ProcessEvent(Func, &Parms);

	if (OutSpawnCollisionMethod != nullptr)
		*OutSpawnCollisionMethod = Parms.OutSpawnCollisionMethod;

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.CanRestartPlayerFromAnySpawnPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>                PlayerPawnClass                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::CanRestartPlayerFromAnySpawnPoint(class UObject* Target, class AController* Player, TSubclassOf<class APawn>& PlayerPawnClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "CanRestartPlayerFromAnySpawnPoint");

	Params::SpawnPointStatics_CanRestartPlayerFromAnySpawnPoint Parms{};

	Parms.Target = Target;
	Parms.Player = Player;
	Parms.PlayerPawnClass = PlayerPawnClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.CanRestartPlayerFromSpawnPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnPointDef                   SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class APawn>                PlayerPawnClass                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::CanRestartPlayerFromSpawnPoint(class UObject* Target, struct FSpawnPointDef& SpawnPoint, class AController* Player, TSubclassOf<class APawn>& PlayerPawnClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "CanRestartPlayerFromSpawnPoint");

	Params::SpawnPointStatics_CanRestartPlayerFromSpawnPoint Parms{};

	Parms.Target = Target;
	Parms.SpawnPoint = std::move(SpawnPoint);
	Parms.Player = Player;
	Parms.PlayerPawnClass = PlayerPawnClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.CanSpawnActorFromAnySpawnPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               SpawnActorClass                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::CanSpawnActorFromAnySpawnPoint(class UObject* Target, TSubclassOf<class AActor>& SpawnActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "CanSpawnActorFromAnySpawnPoint");

	Params::SpawnPointStatics_CanSpawnActorFromAnySpawnPoint Parms{};

	Parms.Target = Target;
	Parms.SpawnActorClass = SpawnActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.CanSpawnActorFromSpawnPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnPointDef                   SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               SpawnActorClass                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::CanSpawnActorFromSpawnPoint(class UObject* Target, struct FSpawnPointDef& SpawnPoint, TSubclassOf<class AActor>& SpawnActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "CanSpawnActorFromSpawnPoint");

	Params::SpawnPointStatics_CanSpawnActorFromSpawnPoint Parms{};

	Parms.Target = Target;
	Parms.SpawnPoint = std::move(SpawnPoint);
	Parms.SpawnActorClass = SpawnActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.FindSpawnPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnPointID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnPointDef                   FoundSpawnPoint                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::FindSpawnPoint(class UObject* Target, int32 SpawnPointID, struct FSpawnPointDef* FoundSpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "FindSpawnPoint");

	Params::SpawnPointStatics_FindSpawnPoint Parms{};

	Parms.Target = Target;
	Parms.SpawnPointID = SpawnPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FoundSpawnPoint != nullptr)
		*FoundSpawnPoint = std::move(Parms.FoundSpawnPoint);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.GetAllSpawnPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSpawnPointDef>           SpawnPoints                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpawnPointStatics::GetAllSpawnPoints(class UObject* Target, TArray<struct FSpawnPointDef>* SpawnPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "GetAllSpawnPoints");

	Params::SpawnPointStatics_GetAllSpawnPoints Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnPoints != nullptr)
		*SpawnPoints = std::move(Parms.SpawnPoints);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.GetAllSpawnPointTransforms
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               SpawnPointTransforms                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpawnPointStatics::GetAllSpawnPointTransforms(class UObject* Target, TArray<struct FTransform>* SpawnPointTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "GetAllSpawnPointTransforms");

	Params::SpawnPointStatics_GetAllSpawnPointTransforms Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnPointTransforms != nullptr)
		*SpawnPointTransforms = std::move(Parms.SpawnPointTransforms);

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.GetSpawnPointCollisionHandlingOverride
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSpawnPointDef                   SpawnPoint                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      OutSpawnCollisionMethod                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::GetSpawnPointCollisionHandlingOverride(class UObject* Target, struct FSpawnPointDef& SpawnPoint, ESpawnActorCollisionHandlingMethod* OutSpawnCollisionMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "GetSpawnPointCollisionHandlingOverride");

	Params::SpawnPointStatics_GetSpawnPointCollisionHandlingOverride Parms{};

	Parms.Target = Target;
	Parms.SpawnPoint = std::move(SpawnPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnCollisionMethod != nullptr)
		*OutSpawnCollisionMethod = Parms.OutSpawnCollisionMethod;

	return Parms.ReturnValue;
}


// Function DonkehFramework.SpawnPointStatics.SpawnPointExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SpawnPointID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpawnPointStatics::SpawnPointExists(class UObject* Target, int32 SpawnPointID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpawnPointStatics", "SpawnPointExists");

	Params::SpawnPointStatics_SpawnPointExists Parms{};

	Parms.Target = Target;
	Parms.SpawnPointID = SpawnPointID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DonkehFramework.UseableInterface.Used
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Invoker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IUseableInterface::Used(class AActor* Invoker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UseableInterface", "Used");

	Params::UseableInterface_Used Parms{};

	Parms.Invoker = Invoker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DonkehFramework.VisibilityInterface.EventGetFocalPoint
// (Event, Protected, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IVisibilityInterface::EventGetFocalPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VisibilityInterface", "EventGetFocalPoint");

	Params::VisibilityInterface_EventGetFocalPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

