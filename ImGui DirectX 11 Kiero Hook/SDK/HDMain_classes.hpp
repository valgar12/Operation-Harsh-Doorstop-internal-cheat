#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HDMain

#include "Basic.hpp"

#include "DonkehFrameworkUI_classes.hpp"
#include "DonkehFramework_structs.hpp"
#include "DonkehFramework_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "HDMain_structs.hpp"
#include "UMG_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Tinkerbox_classes.hpp"
#include "HDCoreUGC_classes.hpp"
#include "GOAPNPC_classes.hpp"
#include "DonkehFrameworkAnim_classes.hpp"
#include "DonkehFrameworkComms_structs.hpp"
#include "ArcVehicles_classes.hpp"


namespace SDK
{

// Class HDMain.HDBaseProjectile
// 0x0000 (0x0380 - 0x0380)
#pragma pack(push, 0x1)
class alignas(0x10) AHDBaseProjectile : public ADFBaseProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDBaseProjectile">();
	}
	static class AHDBaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDBaseProjectile>();
	}
};
#pragma pack(pop)
//(alignof(AHDBaseProjectile) == 0x000010, "Wrong alignment on AHDBaseProjectile");
//(sizeof(AHDBaseProjectile) == 0x000380, "Wrong size on AHDBaseProjectile");

// Class HDMain.HDProj_Deployable
// 0x0000 (0x0380 - 0x0380)
class AHDProj_Deployable : public AHDBaseProjectile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDProj_Deployable">();
	}
	static class AHDProj_Deployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDProj_Deployable>();
	}
};
//(alignof(AHDProj_Deployable) == 0x000010, "Wrong alignment on AHDProj_Deployable");
//(sizeof(AHDProj_Deployable) == 0x000380, "Wrong size on AHDProj_Deployable");

// Class HDMain.HDProj_SpawnPointDeployable
// 0x0010 (0x0390 - 0x0380)
class AHDProj_SpawnPointDeployable : public AHDProj_Deployable
{
public:
	EHDTeam                                       Team;                                              // 0x0380(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1146[0xF];                                     // 0x0381(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDProj_SpawnPointDeployable">();
	}
	static class AHDProj_SpawnPointDeployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDProj_SpawnPointDeployable>();
	}
};
//(alignof(AHDProj_SpawnPointDeployable) == 0x000010, "Wrong alignment on AHDProj_SpawnPointDeployable");
//(sizeof(AHDProj_SpawnPointDeployable) == 0x000390, "Wrong size on AHDProj_SpawnPointDeployable");
//(offsetof(AHDProj_SpawnPointDeployable, Team) == 0x000380, "Member 'AHDProj_SpawnPointDeployable::Team' has a wrong offset!");

// Class HDMain.DeployMenu
// 0x0000 (0x0238 - 0x0238)
class UDeployMenu : public UDFBaseMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu">();
	}
	static class UDeployMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu>();
	}
};
//(alignof(UDeployMenu) == 0x000008, "Wrong alignment on UDeployMenu");
//(sizeof(UDeployMenu) == 0x000238, "Wrong size on UDeployMenu");

// Class HDMain.DeployMenu_ClassSelectionListing
// 0x0000 (0x0230 - 0x0230)
class UDeployMenu_ClassSelectionListing : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_ClassSelectionListing">();
	}
	static class UDeployMenu_ClassSelectionListing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_ClassSelectionListing>();
	}
};
//(alignof(UDeployMenu_ClassSelectionListing) == 0x000008, "Wrong alignment on UDeployMenu_ClassSelectionListing");
//(sizeof(UDeployMenu_ClassSelectionListing) == 0x000230, "Wrong size on UDeployMenu_ClassSelectionListing");

// Class HDMain.HDGOAPActionBase
// 0x0000 (0x0098 - 0x0098)
class UHDGOAPActionBase : public UGOAPAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPActionBase">();
	}
	static class UHDGOAPActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPActionBase>();
	}
};
//(alignof(UHDGOAPActionBase) == 0x000008, "Wrong alignment on UHDGOAPActionBase");
//(sizeof(UHDGOAPActionBase) == 0x000098, "Wrong size on UHDGOAPActionBase");

// Class HDMain.HDServerListFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDServerListFilterRule : public UObject
{
public:
	bool MatchesServer(class UHDServerListItemData* ListItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDServerListFilterRule">();
	}
	static class UHDServerListFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDServerListFilterRule>();
	}
};
//(alignof(UHDServerListFilterRule) == 0x000008, "Wrong alignment on UHDServerListFilterRule");
//(sizeof(UHDServerListFilterRule) == 0x000028, "Wrong size on UHDServerListFilterRule");

// Class HDMain.HDServerAtCapacityFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDServerAtCapacityFilterRule final  : public UHDServerListFilterRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDServerAtCapacityFilterRule">();
	}
	static class UHDServerAtCapacityFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDServerAtCapacityFilterRule>();
	}
};
//(alignof(UHDServerAtCapacityFilterRule) == 0x000008, "Wrong alignment on UHDServerAtCapacityFilterRule");
//(sizeof(UHDServerAtCapacityFilterRule) == 0x000028, "Wrong size on UHDServerAtCapacityFilterRule");

// Class HDMain.DeployMenu_ClassSelectionPanel
// 0x0000 (0x0230 - 0x0230)
class UDeployMenu_ClassSelectionPanel : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_ClassSelectionPanel">();
	}
	static class UDeployMenu_ClassSelectionPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_ClassSelectionPanel>();
	}
};
//(alignof(UDeployMenu_ClassSelectionPanel) == 0x000008, "Wrong alignment on UDeployMenu_ClassSelectionPanel");
//(sizeof(UDeployMenu_ClassSelectionPanel) == 0x000230, "Wrong size on UDeployMenu_ClassSelectionPanel");

// Class HDMain.DeployMenu_PlatoonSquadListBase
// 0x0020 (0x0250 - 0x0230)
class UDeployMenu_PlatoonSquadListBase : public UUserWidget
{
public:
	class UPlatoonListEntry*                      PlatoonData;                                       // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSortSquads;                                       // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1148[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USquadListEntry*>                CurrentSquads;                                     // 0x0240(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DeconstructSquad(class USquadListEntry* RemovedSquadData, int32 RemovedSquadIdx);
	void GenerateSquad(class USquadListEntry* SquadData);
	void OnPlatoonSet();
	void RepopulatePlatoon();
	void SetupPlatoon(class UPlatoonListEntry* InPlatoonData);
	void SquadAddedToPlatoon(class AHDPlatoonState* SourcePlatoon, class AHDSquadState* NewSquad);
	void SquadPreRemoveFromPlatoon(class AHDPlatoonState* SourcePlatoon, class AHDSquadState* SquadToBeRemoved);

	class AHDPlatoonState* GetPlatoonStateFromData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_PlatoonSquadListBase">();
	}
	static class UDeployMenu_PlatoonSquadListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_PlatoonSquadListBase>();
	}
};
//(alignof(UDeployMenu_PlatoonSquadListBase) == 0x000008, "Wrong alignment on UDeployMenu_PlatoonSquadListBase");
//(sizeof(UDeployMenu_PlatoonSquadListBase) == 0x000250, "Wrong size on UDeployMenu_PlatoonSquadListBase");
//(offsetof(UDeployMenu_PlatoonSquadListBase, PlatoonData) == 0x000230, "Member 'UDeployMenu_PlatoonSquadListBase::PlatoonData' has a wrong offset!");
//(offsetof(UDeployMenu_PlatoonSquadListBase, bSortSquads) == 0x000238, "Member 'UDeployMenu_PlatoonSquadListBase::bSortSquads' has a wrong offset!");
//(offsetof(UDeployMenu_PlatoonSquadListBase, CurrentSquads) == 0x000240, "Member 'UDeployMenu_PlatoonSquadListBase::CurrentSquads' has a wrong offset!");

// Class HDMain.HDGOAPGoalBase
// 0x0000 (0x0068 - 0x0068)
class UHDGOAPGoalBase : public UGOAPGoal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPGoalBase">();
	}
	static class UHDGOAPGoalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPGoalBase>();
	}
};
//(alignof(UHDGOAPGoalBase) == 0x000008, "Wrong alignment on UHDGOAPGoalBase");
//(sizeof(UHDGOAPGoalBase) == 0x000068, "Wrong size on UHDGOAPGoalBase");

// Class HDMain.HDSquadStateCreationPayload
// 0x0030 (0x0058 - 0x0028)
class UHDSquadStateCreationPayload final  : public UObject
{
public:
	struct FHDSquadCreationParams                 CreationParams;                                    // 0x0028(0x0030)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDSquadStateCreationPayload">();
	}
	static class UHDSquadStateCreationPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDSquadStateCreationPayload>();
	}
};
//(alignof(UHDSquadStateCreationPayload) == 0x000008, "Wrong alignment on UHDSquadStateCreationPayload");
//(sizeof(UHDSquadStateCreationPayload) == 0x000058, "Wrong size on UHDSquadStateCreationPayload");
//(offsetof(UHDSquadStateCreationPayload, CreationParams) == 0x000028, "Member 'UHDSquadStateCreationPayload::CreationParams' has a wrong offset!");

// Class HDMain.DeployMenu_SpawnMapView
// 0x0000 (0x0230 - 0x0230)
class UDeployMenu_SpawnMapView : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_SpawnMapView">();
	}
	static class UDeployMenu_SpawnMapView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_SpawnMapView>();
	}
};
//(alignof(UDeployMenu_SpawnMapView) == 0x000008, "Wrong alignment on UDeployMenu_SpawnMapView");
//(sizeof(UDeployMenu_SpawnMapView) == 0x000230, "Wrong size on UDeployMenu_SpawnMapView");

// Class HDMain.DeployMenu_SpawnMinimap
// 0x0000 (0x0298 - 0x0298)
class UDeployMenu_SpawnMinimap : public UDFMinimap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_SpawnMinimap">();
	}
	static class UDeployMenu_SpawnMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_SpawnMinimap>();
	}
};
//(alignof(UDeployMenu_SpawnMinimap) == 0x000008, "Wrong alignment on UDeployMenu_SpawnMinimap");
//(sizeof(UDeployMenu_SpawnMinimap) == 0x000298, "Wrong size on UDeployMenu_SpawnMinimap");

// Class HDMain.HDGOAPAct_LoadWeapon
// 0x0000 (0x0098 - 0x0098)
class UHDGOAPAct_LoadWeapon final  : public UHDGOAPActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPAct_LoadWeapon">();
	}
	static class UHDGOAPAct_LoadWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPAct_LoadWeapon>();
	}
};
//(alignof(UHDGOAPAct_LoadWeapon) == 0x000008, "Wrong alignment on UHDGOAPAct_LoadWeapon");
//(sizeof(UHDGOAPAct_LoadWeapon) == 0x000098, "Wrong size on UHDGOAPAct_LoadWeapon");

// Class HDMain.HDHasUGCServerFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDHasUGCServerFilterRule final  : public UHDServerListFilterRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDHasUGCServerFilterRule">();
	}
	static class UHDHasUGCServerFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDHasUGCServerFilterRule>();
	}
};
//(alignof(UHDHasUGCServerFilterRule) == 0x000008, "Wrong alignment on UHDHasUGCServerFilterRule");
//(sizeof(UHDHasUGCServerFilterRule) == 0x000028, "Wrong size on UHDHasUGCServerFilterRule");

// Class HDMain.DeployMenu_SquadListBase
// 0x0030 (0x0260 - 0x0230)
class UDeployMenu_SquadListBase : public UUserWidget
{
public:
	class USquadListEntry*                        SquadData;                                         // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSortSquadMembers;                                 // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114A[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USquadMemberInfo*>               CurrentSquadMembers;                               // 0x0240(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USquadMemberInfo*>               MemberEntryWidgetsPendingRemoval;                  // 0x0250(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DeconstructSquadMember(class USquadMemberInfo* RemovedMemberData);
	void GenerateSquadMember(class USquadMemberInfo* MemberData);
	void MemberAddedToSquad(class AHDSquadState* SourceSquad, class AHDPlayerState* NewMemberPS);
	void MemberPreRemoveFromSquad(class AHDSquadState* SourceSquad, class AHDPlayerState* MemberPSToBeRemoved);
	void MemberSquadInfoUpdated(class AHDSquadState* SourceSquad, class AHDPlayerState* MemberPS, struct FHDSquadAssignmentInfo& MemberSQInfo);
	void OnListRefresh();
	void OnSquadLeaderUpdated(class AHDPlayerState* NewLeaderPS, class AHDPlayerState* PrevLeaderPS);
	void OnSquadLockStateUpdated(bool bNewLockedState);
	void OnSquadNameUpdated(class FText& NewSquadName, class FText& PreviousSquadName);
	void OnSquadSet();
	void RepopulateSquad();
	void SetupSquad(class USquadListEntry* InSquadData);
	void SquadLeaderChanged(class AHDSquadState* SourceSquad, class AHDPlayerState* NewLeaderPS, class AHDPlayerState* PrevLeaderPS);
	void SquadLockStateUpdated(class AHDSquadState* SourceSquad, bool bNewLocked);
	void SquadNameChanged(class AHDSquadState* SourceSquad, class FText& NewName, class FText& PrevName);

	class AHDPlatoonState* GetParentPlatoonStateFromData() const;
	class AHDSquadState* GetSquadStateFromData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_SquadListBase">();
	}
	static class UDeployMenu_SquadListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_SquadListBase>();
	}
};
//(alignof(UDeployMenu_SquadListBase) == 0x000008, "Wrong alignment on UDeployMenu_SquadListBase");
//(sizeof(UDeployMenu_SquadListBase) == 0x000260, "Wrong size on UDeployMenu_SquadListBase");
//(offsetof(UDeployMenu_SquadListBase, SquadData) == 0x000230, "Member 'UDeployMenu_SquadListBase::SquadData' has a wrong offset!");
//(offsetof(UDeployMenu_SquadListBase, bSortSquadMembers) == 0x000238, "Member 'UDeployMenu_SquadListBase::bSortSquadMembers' has a wrong offset!");
//(offsetof(UDeployMenu_SquadListBase, CurrentSquadMembers) == 0x000240, "Member 'UDeployMenu_SquadListBase::CurrentSquadMembers' has a wrong offset!");
//(offsetof(UDeployMenu_SquadListBase, MemberEntryWidgetsPendingRemoval) == 0x000250, "Member 'UDeployMenu_SquadListBase::MemberEntryWidgetsPendingRemoval' has a wrong offset!");

// Class HDMain.DeployMenu_SquadMemberListingBase
// 0x0008 (0x0238 - 0x0230)
class UDeployMenu_SquadMemberListingBase : public UUserWidget
{
public:
	class USquadMemberInfo*                       MemberData;                                        // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MemberPlayerNameChanged(class APlayerState* PlayerState, const class FString& NewPlayerName);
	void OnMemberPlayerNameUpdated(const class FString& NewPlayerName);
	void OnMemberSet();
	void SetupMember(class USquadMemberInfo* InMemberData);

	class AHDPlatoonState* GetParentPlatoonStateFromData() const;
	class AHDSquadState* GetParentSquadStateFromData() const;
	class AHDPlayerState* GetPlayerStateFromData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_SquadMemberListingBase">();
	}
	static class UDeployMenu_SquadMemberListingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_SquadMemberListingBase>();
	}
};
//(alignof(UDeployMenu_SquadMemberListingBase) == 0x000008, "Wrong alignment on UDeployMenu_SquadMemberListingBase");
//(sizeof(UDeployMenu_SquadMemberListingBase) == 0x000238, "Wrong size on UDeployMenu_SquadMemberListingBase");
//(offsetof(UDeployMenu_SquadMemberListingBase, MemberData) == 0x000230, "Member 'UDeployMenu_SquadMemberListingBase::MemberData' has a wrong offset!");

// Class HDMain.HDScoreboardListingRowBase
// 0x00E8 (0x0318 - 0x0230)
class UHDScoreboardListingRowBase : public UUserWidget
{
public:
	class UHDScoreboardBase*                      ParentMenu;                                        // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADFBasePlayerState*                     PlayerState;                                       // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114C[0x3];                                     // 0x0240(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bRefreshListingOnTick : 1;                         // 0x0243(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_114D[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                MutePlayerBtn;                                     // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerName;                                        // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Score;                                             // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Kills;                                             // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Deaths;                                            // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Ping;                                              // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              NotTalkingVoiceIcon;                               // 0x0278(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              TalkingVoiceIcon;                                  // 0x02A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              MutedVoiceIcon;                                    // 0x02C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114E[0x20];                                    // 0x02F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             PlayerNumber;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(class UHDScoreboardBase* InParentMenu, class ADFBasePlayerState* InPlayerState, bool bInRefreshListingOnTick);
	void OnMutePlayer();
	void ReceivePlayerVoiceStateChanged(EPlayerVoiceState NewVoiceState);
	void ReceiveRefreshListing();
	void RefreshListing();
	void SetVoiceStateIcon(class UTexture2D* NewIcon);

	int32 GetCurrentPing() const;
	TSoftObjectPtr<class UTexture2D> GetIconForVoiceState(EPlayerVoiceState VoiceState) const;
	bool HasInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDScoreboardListingRowBase">();
	}
	static class UHDScoreboardListingRowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDScoreboardListingRowBase>();
	}
};
//(alignof(UHDScoreboardListingRowBase) == 0x000008, "Wrong alignment on UHDScoreboardListingRowBase");
//(sizeof(UHDScoreboardListingRowBase) == 0x000318, "Wrong size on UHDScoreboardListingRowBase");
//(offsetof(UHDScoreboardListingRowBase, ParentMenu) == 0x000230, "Member 'UHDScoreboardListingRowBase::ParentMenu' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, PlayerState) == 0x000238, "Member 'UHDScoreboardListingRowBase::PlayerState' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, MutePlayerBtn) == 0x000248, "Member 'UHDScoreboardListingRowBase::MutePlayerBtn' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, PlayerName) == 0x000250, "Member 'UHDScoreboardListingRowBase::PlayerName' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, Score) == 0x000258, "Member 'UHDScoreboardListingRowBase::Score' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, Kills) == 0x000260, "Member 'UHDScoreboardListingRowBase::Kills' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, Deaths) == 0x000268, "Member 'UHDScoreboardListingRowBase::Deaths' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, Ping) == 0x000270, "Member 'UHDScoreboardListingRowBase::Ping' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, NotTalkingVoiceIcon) == 0x000278, "Member 'UHDScoreboardListingRowBase::NotTalkingVoiceIcon' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, TalkingVoiceIcon) == 0x0002A0, "Member 'UHDScoreboardListingRowBase::TalkingVoiceIcon' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, MutedVoiceIcon) == 0x0002C8, "Member 'UHDScoreboardListingRowBase::MutedVoiceIcon' has a wrong offset!");
//(offsetof(UHDScoreboardListingRowBase, PlayerNumber) == 0x000310, "Member 'UHDScoreboardListingRowBase::PlayerNumber' has a wrong offset!");

// Class HDMain.DeployMenu_SquadSelectionWidgetBase
// 0x0020 (0x0250 - 0x0230)
class UDeployMenu_SquadSelectionWidgetBase : public UUserWidget
{
public:
	class AHDTeamState*                           PlatoonTeamState;                                  // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSortPlatoons;                                     // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1151[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPlatoonListEntry*>              CurrentPlatoons;                                   // 0x0240(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DeconstructPlatoon(class UPlatoonListEntry* RemovedPlatoonData, int32 RemovedPlatoonIdx);
	void GeneratePlatoon(class UPlatoonListEntry* PlatoonData);
	void OnSquadSelectionSet();
	void PlatoonAddedToTeam(class AHDTeamState* SourceTeam, class AHDPlatoonState* NewPlatoon);
	void PlatoonPreRemoveFromTeam(class AHDTeamState* SourceTeam, class AHDPlatoonState* PlatoonToBeRemoved);
	void RepopulateSquadSelection();
	void SetupSquadSelection(class AHDTeamState* InPlatoonTeamState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployMenu_SquadSelectionWidgetBase">();
	}
	static class UDeployMenu_SquadSelectionWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeployMenu_SquadSelectionWidgetBase>();
	}
};
//(alignof(UDeployMenu_SquadSelectionWidgetBase) == 0x000008, "Wrong alignment on UDeployMenu_SquadSelectionWidgetBase");
//(sizeof(UDeployMenu_SquadSelectionWidgetBase) == 0x000250, "Wrong size on UDeployMenu_SquadSelectionWidgetBase");
//(offsetof(UDeployMenu_SquadSelectionWidgetBase, PlatoonTeamState) == 0x000230, "Member 'UDeployMenu_SquadSelectionWidgetBase::PlatoonTeamState' has a wrong offset!");
//(offsetof(UDeployMenu_SquadSelectionWidgetBase, bSortPlatoons) == 0x000238, "Member 'UDeployMenu_SquadSelectionWidgetBase::bSortPlatoons' has a wrong offset!");
//(offsetof(UDeployMenu_SquadSelectionWidgetBase, CurrentPlatoons) == 0x000240, "Member 'UDeployMenu_SquadSelectionWidgetBase::CurrentPlatoons' has a wrong offset!");

// Class HDMain.HDAIHandlerBase
// 0x0028 (0x0050 - 0x0028)
class UHDAIHandlerBase : public UObject
{
public:
	uint8                                         Pad_1153[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDAIController*                        Controller;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDGOAPComponent*                       GOAPComponent;                                     // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1154[0x8];                                     // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIHandlerBase*                       HandlerDuplicate;                                  // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIHandlerBase">();
	}
	static class UHDAIHandlerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIHandlerBase>();
	}
};
//(alignof(UHDAIHandlerBase) == 0x000008, "Wrong alignment on UHDAIHandlerBase");
//(sizeof(UHDAIHandlerBase) == 0x000050, "Wrong size on UHDAIHandlerBase");
//(offsetof(UHDAIHandlerBase, Controller) == 0x000030, "Member 'UHDAIHandlerBase::Controller' has a wrong offset!");
//(offsetof(UHDAIHandlerBase, GOAPComponent) == 0x000038, "Member 'UHDAIHandlerBase::GOAPComponent' has a wrong offset!");
//(offsetof(UHDAIHandlerBase, HandlerDuplicate) == 0x000048, "Member 'UHDAIHandlerBase::HandlerDuplicate' has a wrong offset!");

// Class HDMain.HDAICaptureHandler
// 0x0018 (0x0068 - 0x0050)
class UHDAICaptureHandler final  : public UHDAIHandlerBase
{
public:
	class AHDBaseCapturePoint*                    CurrentCP;                                         // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHDAICaptureMode                              CurrentCaptureMode;                                // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1155[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AICaptureModePreference;                           // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalNumberOfCapturePoints;                        // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1156[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool EstablishNewControlPoint();
	struct FVector GetCurrentCPLocation();
	int32 GetTotalNumberOfCapturePoints();
	void SetCurrentCaptureMode(EHDAICaptureMode NewCaptureMode);
	void SetCurrentCP(class AHDBaseCapturePoint* InCurrentCP);

	TArray<class AHDBaseCapturePoint*> FindAvailableControlPointsOfType(EHDAICaptureMode InCaptureMode) const;
	TArray<class AHDBaseCapturePoint*> FindAvailableControlPointsOfTypeV1(EHDAICaptureMode InCaptureMode) const;
	TArray<class AHDBaseCapturePoint*> FindAvailableControlPointsOfTypeV2(EHDAICaptureMode InCaptureMode) const;
	TArray<class AHDBaseCapturePoint*> FindAvailableControlPointsOfTypeV3(EHDAICaptureMode InCaptureMode) const;
	class AHDBaseCapturePoint* FindControlPointClosestToPawn(TArray<class AHDBaseCapturePoint*>& CPs) const;
	class AHDBaseCapturePoint* FindControlPointRandom(TArray<class AHDBaseCapturePoint*>& CPs) const;
	bool FindControlPointToCapture(class AHDBaseCapturePoint** OutFoundCP) const;
	class AActor* GetStartSpotClosestToControlPoint(class AActor* InCapturePoint) const;
	bool ShouldEstablishNewControlPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAICaptureHandler">();
	}
	static class UHDAICaptureHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAICaptureHandler>();
	}
};
//(alignof(UHDAICaptureHandler) == 0x000008, "Wrong alignment on UHDAICaptureHandler");
//(sizeof(UHDAICaptureHandler) == 0x000068, "Wrong size on UHDAICaptureHandler");
//(offsetof(UHDAICaptureHandler, CurrentCP) == 0x000050, "Member 'UHDAICaptureHandler::CurrentCP' has a wrong offset!");
//(offsetof(UHDAICaptureHandler, CurrentCaptureMode) == 0x000058, "Member 'UHDAICaptureHandler::CurrentCaptureMode' has a wrong offset!");
//(offsetof(UHDAICaptureHandler, AICaptureModePreference) == 0x00005C, "Member 'UHDAICaptureHandler::AICaptureModePreference' has a wrong offset!");
//(offsetof(UHDAICaptureHandler, TotalNumberOfCapturePoints) == 0x000060, "Member 'UHDAICaptureHandler::TotalNumberOfCapturePoints' has a wrong offset!");

// Class HDMain.HDSQCommChannelState
// 0x0030 (0x0058 - 0x0028)
class UHDSQCommChannelState final  : public UObject
{
public:
	uint8                                         Pad_115C[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDSquadState*                          SquadState;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDFCommStateSetupParams                InitialSetupParams;                                // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_115D[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FName GetChannelNameForSquad(class AHDSquadState* Squad);

	void SetupSQChannelState(class AHDSquadState* ForSquadState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDSQCommChannelState">();
	}
	static class UHDSQCommChannelState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDSQCommChannelState>();
	}
};
//(alignof(UHDSQCommChannelState) == 0x000008, "Wrong alignment on UHDSQCommChannelState");
//(sizeof(UHDSQCommChannelState) == 0x000058, "Wrong size on UHDSQCommChannelState");
//(offsetof(UHDSQCommChannelState, SquadState) == 0x000030, "Member 'UHDSQCommChannelState::SquadState' has a wrong offset!");
//(offsetof(UHDSQCommChannelState, InitialSetupParams) == 0x000038, "Member 'UHDSQCommChannelState::InitialSetupParams' has a wrong offset!");

// Class HDMain.HDAIAimingHandler
// 0x0100 (0x0150 - 0x0050)
class UHDAIAimingHandler final  : public UHDAIHandlerBase
{
public:
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIBehaviorHandler*                   BehaviorHandler;                                   // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIVocalHandler*                      VocalHandler;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionComponent*                 PerceptionComponent;                               // 0x0070(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                AimingTargetPoint;                                 // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentTargetLocation;                             // 0x0084(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetStimulusStrength;                     // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentTargetStimulusAge;                          // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefreshTargetTime;                                 // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RefreshTargetRate;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NewTargetStimulusStrengthThreshold;                // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingAtTargetAngleThreshold;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAimingAtTarget : 1;                               // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_115E[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimingSpeed;                                       // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingSpeedNear;                                   // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingSpeedFar;                                    // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingSpeedAngleNear;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingSpeedAngleFar;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingSpeedMultiplier;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationRate;                                      // 0x00C4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               DefaultRotationRate;                               // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_115F[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnContactStateChanged;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1160[0xC];                                     // 0x00F0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponAimingDistance;                              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMinConeOfFireAngleDegrees;                   // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponMaxConeOfFireAngleDegrees;                   // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableNoEnemyLookAround : 1;                      // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1161[0x3];                                     // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NoEnemyFocalPoint;                                 // 0x010C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointTime;                                // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointIntervalMin;                         // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointIntervalMax;                         // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointAngleMin;                            // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointAngleMax;                            // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointDistanceMin;                         // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextFocalPointDistanceMax;                         // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ProjectileAimingTossVelocity;                      // 0x0134(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileAimingTime;                              // 0x0140(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileAimingRate;                              // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileAimingRateVariation;                     // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1162[0x4];                                     // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AimAtCurrentTarget();
	void CalcAimingDirection();
	bool CheckForTarget(class AActor* TargetActor, const struct FAIStimulus& Stimulus);
	void EstablishNewTargetFromPerception(TSubclassOf<class UAISense>& SenseToUse);
	void MakeNoEnemyFocalPoint();
	void SetEnableNoEnemyLookAround(bool bInEnableNoEnemyLookAround);
	bool ShouldChangeNoEnemyFocalPoint();
	bool SuggestProjectileVelocity(struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float TossSpeed);

	void GetActorStimulusData(class AActor* InActor, struct FVector* OutLocation, float* OutStrength, float* OutAge) const;
	bool GetEnableNoEnemyLookAround() const;
	bool GetIsNewTargetMoreRelevant(float OldTargetStrength, float NewTargetStrength) const;
	struct FVector GetNoEnemyFocalPoint() const;
	bool HasValidCustomAimingTarget() const;
	bool IsAimingAtTarget() const;
	bool IsCandidateTarget(class AActor* ActorToCheck) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIAimingHandler">();
	}
	static class UHDAIAimingHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIAimingHandler>();
	}
};
//(alignof(UHDAIAimingHandler) == 0x000008, "Wrong alignment on UHDAIAimingHandler");
//(sizeof(UHDAIAimingHandler) == 0x000150, "Wrong size on UHDAIAimingHandler");
//(offsetof(UHDAIAimingHandler, CombatHandler) == 0x000050, "Member 'UHDAIAimingHandler::CombatHandler' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NavigationHandler) == 0x000058, "Member 'UHDAIAimingHandler::NavigationHandler' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, BehaviorHandler) == 0x000060, "Member 'UHDAIAimingHandler::BehaviorHandler' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, VocalHandler) == 0x000068, "Member 'UHDAIAimingHandler::VocalHandler' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, PerceptionComponent) == 0x000070, "Member 'UHDAIAimingHandler::PerceptionComponent' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingTargetPoint) == 0x000078, "Member 'UHDAIAimingHandler::AimingTargetPoint' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, CurrentTargetLocation) == 0x000084, "Member 'UHDAIAimingHandler::CurrentTargetLocation' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, CurrentTargetStimulusStrength) == 0x000090, "Member 'UHDAIAimingHandler::CurrentTargetStimulusStrength' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, CurrentTargetStimulusAge) == 0x000094, "Member 'UHDAIAimingHandler::CurrentTargetStimulusAge' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, RefreshTargetTime) == 0x000098, "Member 'UHDAIAimingHandler::RefreshTargetTime' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, RefreshTargetRate) == 0x00009C, "Member 'UHDAIAimingHandler::RefreshTargetRate' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NewTargetStimulusStrengthThreshold) == 0x0000A0, "Member 'UHDAIAimingHandler::NewTargetStimulusStrengthThreshold' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingAtTargetAngleThreshold) == 0x0000A4, "Member 'UHDAIAimingHandler::AimingAtTargetAngleThreshold' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingSpeed) == 0x0000AC, "Member 'UHDAIAimingHandler::AimingSpeed' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingSpeedNear) == 0x0000B0, "Member 'UHDAIAimingHandler::AimingSpeedNear' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingSpeedFar) == 0x0000B4, "Member 'UHDAIAimingHandler::AimingSpeedFar' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingSpeedAngleNear) == 0x0000B8, "Member 'UHDAIAimingHandler::AimingSpeedAngleNear' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingSpeedAngleFar) == 0x0000BC, "Member 'UHDAIAimingHandler::AimingSpeedAngleFar' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, AimingSpeedMultiplier) == 0x0000C0, "Member 'UHDAIAimingHandler::AimingSpeedMultiplier' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, RotationRate) == 0x0000C4, "Member 'UHDAIAimingHandler::RotationRate' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, DefaultRotationRate) == 0x0000D0, "Member 'UHDAIAimingHandler::DefaultRotationRate' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, OnContactStateChanged) == 0x0000E0, "Member 'UHDAIAimingHandler::OnContactStateChanged' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, WeaponAimingDistance) == 0x0000FC, "Member 'UHDAIAimingHandler::WeaponAimingDistance' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, WeaponMinConeOfFireAngleDegrees) == 0x000100, "Member 'UHDAIAimingHandler::WeaponMinConeOfFireAngleDegrees' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, WeaponMaxConeOfFireAngleDegrees) == 0x000104, "Member 'UHDAIAimingHandler::WeaponMaxConeOfFireAngleDegrees' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NoEnemyFocalPoint) == 0x00010C, "Member 'UHDAIAimingHandler::NoEnemyFocalPoint' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointTime) == 0x000118, "Member 'UHDAIAimingHandler::NextFocalPointTime' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointIntervalMin) == 0x00011C, "Member 'UHDAIAimingHandler::NextFocalPointIntervalMin' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointIntervalMax) == 0x000120, "Member 'UHDAIAimingHandler::NextFocalPointIntervalMax' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointAngleMin) == 0x000124, "Member 'UHDAIAimingHandler::NextFocalPointAngleMin' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointAngleMax) == 0x000128, "Member 'UHDAIAimingHandler::NextFocalPointAngleMax' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointDistanceMin) == 0x00012C, "Member 'UHDAIAimingHandler::NextFocalPointDistanceMin' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, NextFocalPointDistanceMax) == 0x000130, "Member 'UHDAIAimingHandler::NextFocalPointDistanceMax' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, ProjectileAimingTossVelocity) == 0x000134, "Member 'UHDAIAimingHandler::ProjectileAimingTossVelocity' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, ProjectileAimingTime) == 0x000140, "Member 'UHDAIAimingHandler::ProjectileAimingTime' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, ProjectileAimingRate) == 0x000144, "Member 'UHDAIAimingHandler::ProjectileAimingRate' has a wrong offset!");
//(offsetof(UHDAIAimingHandler, ProjectileAimingRateVariation) == 0x000148, "Member 'UHDAIAimingHandler::ProjectileAimingRateVariation' has a wrong offset!");

// Class HDMain.HDAIBehaviorStateBase
// 0x0030 (0x0058 - 0x0028)
class UHDAIBehaviorStateBase : public UObject
{
public:
	class AHDAIController*                        Controller;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDGOAPComponent*                       GOAPComponent;                                     // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanEverTick : 1;                                  // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1168[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StateUpdateTime;                                   // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StateUpdateRate;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1169[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIBehaviorStateBase*                 CurrentSubState;                                   // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 CurrentParentState;                                // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanEnterState();
	bool CanExitState();
	bool CanUpdateState(float DeltaTime);
	void EnterState();
	bool ExitCurrentSubState();
	void ExitState();
	void Init(class AHDAIController* InController, class UHDGOAPComponent* InGOAPComponent, class UHDAIBehaviorStateBase* InParentState);
	void ResetUpdateTimer(float InTimerInterval);
	bool SwitchToSubState(class UHDAIBehaviorStateBase* InNewState);
	bool UpdateCurrentSubState(float DeltaTime);
	void UpdateState(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehaviorStateBase">();
	}
	static class UHDAIBehaviorStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehaviorStateBase>();
	}
};
//(alignof(UHDAIBehaviorStateBase) == 0x000008, "Wrong alignment on UHDAIBehaviorStateBase");
//(sizeof(UHDAIBehaviorStateBase) == 0x000058, "Wrong size on UHDAIBehaviorStateBase");
//(offsetof(UHDAIBehaviorStateBase, Controller) == 0x000028, "Member 'UHDAIBehaviorStateBase::Controller' has a wrong offset!");
//(offsetof(UHDAIBehaviorStateBase, GOAPComponent) == 0x000030, "Member 'UHDAIBehaviorStateBase::GOAPComponent' has a wrong offset!");
//(offsetof(UHDAIBehaviorStateBase, StateUpdateTime) == 0x00003C, "Member 'UHDAIBehaviorStateBase::StateUpdateTime' has a wrong offset!");
//(offsetof(UHDAIBehaviorStateBase, StateUpdateRate) == 0x000040, "Member 'UHDAIBehaviorStateBase::StateUpdateRate' has a wrong offset!");
//(offsetof(UHDAIBehaviorStateBase, CurrentSubState) == 0x000048, "Member 'UHDAIBehaviorStateBase::CurrentSubState' has a wrong offset!");
//(offsetof(UHDAIBehaviorStateBase, CurrentParentState) == 0x000050, "Member 'UHDAIBehaviorStateBase::CurrentParentState' has a wrong offset!");

// Class HDMain.HDAIBehState_BasicAASCombat
// 0x00B8 (0x0110 - 0x0058)
class UHDAIBehState_BasicAASCombat final  : public UHDAIBehaviorStateBase
{
public:
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIBehaviorHandler*                   BehaviorHandler;                                   // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIGroupBehaviorHandler*              GroupHandler;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocation;                                    // 0x0070(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AttackSpot;                                        // 0x007C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SafeSpot;                                          // 0x0088(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSafeSpotIsOpen : 1;                               // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCurrentLocationIsSafe : 1;                        // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_116D[0x3];                                     // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistanceBetweenAttackAndSafeSpot;               // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitCombatStateTimerMin;                           // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitCombatStateTimerMax;                           // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToExitCombatState;                             // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116E[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIBehaviorStateBase*                 FindAttackSpotState;                               // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 FindSafeSpotState;                                 // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 AttackingState;                                    // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 SafespottingState;                                 // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 RepositionState;                                   // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDAIBehaviorStateBase>     FindSafeSpotClass;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDAIBehaviorStateBase>     FindAttackSpotClass;                               // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDAIBehaviorStateBase>     AttackingClass;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDAIBehaviorStateBase>     SafespottingClass;                                 // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDAIBehaviorStateBase>     RepositionClass;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHDAIBehaviorDecisionBase*>      CombatRepositioningDecisions;                      // 0x0100(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FindAttackSpot();
	void FindSafeSpot();
	void HandleCombatRepositioning();
	bool HandleExitCombatStateTimer();
	bool IsValidAttackSpot(struct FVector& InAttackSpot);
	bool IsValidSafeSpot(struct FVector& InSafeSpot);
	void ProcessCombatLocations();
	void StartAttacking();
	void StartCombatRepositioning(const struct FVector& InMoveTarget);
	void StartSafespotting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_BasicAASCombat">();
	}
	static class UHDAIBehState_BasicAASCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_BasicAASCombat>();
	}
};
//(alignof(UHDAIBehState_BasicAASCombat) == 0x000008, "Wrong alignment on UHDAIBehState_BasicAASCombat");
//(sizeof(UHDAIBehState_BasicAASCombat) == 0x000110, "Wrong size on UHDAIBehState_BasicAASCombat");
//(offsetof(UHDAIBehState_BasicAASCombat, CombatHandler) == 0x000058, "Member 'UHDAIBehState_BasicAASCombat::CombatHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, BehaviorHandler) == 0x000060, "Member 'UHDAIBehState_BasicAASCombat::BehaviorHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, GroupHandler) == 0x000068, "Member 'UHDAIBehState_BasicAASCombat::GroupHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, TargetLocation) == 0x000070, "Member 'UHDAIBehState_BasicAASCombat::TargetLocation' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, AttackSpot) == 0x00007C, "Member 'UHDAIBehState_BasicAASCombat::AttackSpot' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, SafeSpot) == 0x000088, "Member 'UHDAIBehState_BasicAASCombat::SafeSpot' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, MinDistanceBetweenAttackAndSafeSpot) == 0x000098, "Member 'UHDAIBehState_BasicAASCombat::MinDistanceBetweenAttackAndSafeSpot' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, ExitCombatStateTimerMin) == 0x00009C, "Member 'UHDAIBehState_BasicAASCombat::ExitCombatStateTimerMin' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, ExitCombatStateTimerMax) == 0x0000A0, "Member 'UHDAIBehState_BasicAASCombat::ExitCombatStateTimerMax' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, TimeToExitCombatState) == 0x0000A4, "Member 'UHDAIBehState_BasicAASCombat::TimeToExitCombatState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, FindAttackSpotState) == 0x0000B0, "Member 'UHDAIBehState_BasicAASCombat::FindAttackSpotState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, FindSafeSpotState) == 0x0000B8, "Member 'UHDAIBehState_BasicAASCombat::FindSafeSpotState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, AttackingState) == 0x0000C0, "Member 'UHDAIBehState_BasicAASCombat::AttackingState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, SafespottingState) == 0x0000C8, "Member 'UHDAIBehState_BasicAASCombat::SafespottingState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, RepositionState) == 0x0000D0, "Member 'UHDAIBehState_BasicAASCombat::RepositionState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, FindSafeSpotClass) == 0x0000D8, "Member 'UHDAIBehState_BasicAASCombat::FindSafeSpotClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, FindAttackSpotClass) == 0x0000E0, "Member 'UHDAIBehState_BasicAASCombat::FindAttackSpotClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, AttackingClass) == 0x0000E8, "Member 'UHDAIBehState_BasicAASCombat::AttackingClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, SafespottingClass) == 0x0000F0, "Member 'UHDAIBehState_BasicAASCombat::SafespottingClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, RepositionClass) == 0x0000F8, "Member 'UHDAIBehState_BasicAASCombat::RepositionClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCombat, CombatRepositioningDecisions) == 0x000100, "Member 'UHDAIBehState_BasicAASCombat::CombatRepositioningDecisions' has a wrong offset!");

// Class HDMain.HDAIBehaviorDecisionBase
// 0x0010 (0x0038 - 0x0028)
class UHDAIBehaviorDecisionBase : public UObject
{
public:
	class AHDAIController*                        Controller;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDGOAPComponent*                       GOAPComponent;                                     // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehaviorDecisionBase">();
	}
	static class UHDAIBehaviorDecisionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehaviorDecisionBase>();
	}
};
//(alignof(UHDAIBehaviorDecisionBase) == 0x000008, "Wrong alignment on UHDAIBehaviorDecisionBase");
//(sizeof(UHDAIBehaviorDecisionBase) == 0x000038, "Wrong size on UHDAIBehaviorDecisionBase");
//(offsetof(UHDAIBehaviorDecisionBase, Controller) == 0x000028, "Member 'UHDAIBehaviorDecisionBase::Controller' has a wrong offset!");
//(offsetof(UHDAIBehaviorDecisionBase, GOAPComponent) == 0x000030, "Member 'UHDAIBehaviorDecisionBase::GOAPComponent' has a wrong offset!");

// Class HDMain.HDURLStatics
// 0x0000 (0x0028 - 0x0028)
class UHDURLStatics final  : public UBlueprintFunctionLibrary
{
public:
	static class FString GetDisableKitRestrictionsOptionName();
	static class FString GetFactionOptionName(EHDTeam Team);
	static class FString GetNumBotsOptionName(EHDTeam Team);
	static class FString GetNumTicketsOptionName(EHDTeam Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDURLStatics">();
	}
	static class UHDURLStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDURLStatics>();
	}
};
//(alignof(UHDURLStatics) == 0x000008, "Wrong alignment on UHDURLStatics");
//(sizeof(UHDURLStatics) == 0x000028, "Wrong size on UHDURLStatics");

// Class HDMain.HDAIBehaviorHandler
// 0x0088 (0x00D8 - 0x0050)
class UHDAIBehaviorHandler final  : public UHDAIHandlerBase
{
public:
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIAimingHandler*                     AimingHandler;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIVocalHandler*                      VocalHandler;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICaptureHandler*                    CaptureHandler;                                    // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIGroupBehaviorHandler*              GroupHandler;                                      // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuppressionThreatLevel;                            // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionLevelPerShot;                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionThreatThreshold;                        // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionFalloff;                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionTime;                                   // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuppressionFallingOffDelay;                        // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingHitThreatLevel;                               // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BeingHitThreatThreshold;                           // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingHitFalloff;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingHitThreatLevelSpikeProbability;               // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingHitThreatLevelSpikeAmount;                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingHitFallingOffDelay;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingHitTime;                                      // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1174[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIBehaviorStateBase*                 CurrentBehaviorState;                              // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHDAIBehaviorStateBase>     DefaultBehaviorStateClass;                         // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1175[0x4];                                     // 0x00C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistanceToStartCombatState;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsInCombat : 1;                                   // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1176[0x7];                                     // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcThreatLevels();
	void EnterCurrentBehaviorState();
	void ExitCurrentBehaviorState();
	void HandleBehaviorStates(float DeltaTime);
	void OnOwnerDeath(class APawn* VictimPawn, class AController* VictimController, float KillingDamage, struct FDamageEvent& DamageEvent, class APawn* InstigatingPawn, class AActor* DamageCauser);
	void ReceiveHitDamage();
	void ReceiveSuppression();
	void StartCombatBehaviorState(const struct FVector& InCombatTarget, const struct FVector& InNavigationAnchor);
	void StartCombatRepositioning(const struct FVector& InMoveTarget);
	void StartMoveToObjectiveBehaviorState();
	void UpdateCurrentBehaviorState(float DeltaTime);

	bool GetIsBeingHit() const;
	bool GetIsUnderSuppression() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehaviorHandler">();
	}
	static class UHDAIBehaviorHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehaviorHandler>();
	}
};
//(alignof(UHDAIBehaviorHandler) == 0x000008, "Wrong alignment on UHDAIBehaviorHandler");
//(sizeof(UHDAIBehaviorHandler) == 0x0000D8, "Wrong size on UHDAIBehaviorHandler");
//(offsetof(UHDAIBehaviorHandler, NavigationHandler) == 0x000050, "Member 'UHDAIBehaviorHandler::NavigationHandler' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, CombatHandler) == 0x000058, "Member 'UHDAIBehaviorHandler::CombatHandler' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, AimingHandler) == 0x000060, "Member 'UHDAIBehaviorHandler::AimingHandler' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, VocalHandler) == 0x000068, "Member 'UHDAIBehaviorHandler::VocalHandler' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, CaptureHandler) == 0x000070, "Member 'UHDAIBehaviorHandler::CaptureHandler' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, GroupHandler) == 0x000078, "Member 'UHDAIBehaviorHandler::GroupHandler' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, SuppressionThreatLevel) == 0x000080, "Member 'UHDAIBehaviorHandler::SuppressionThreatLevel' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, SuppressionLevelPerShot) == 0x000084, "Member 'UHDAIBehaviorHandler::SuppressionLevelPerShot' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, SuppressionThreatThreshold) == 0x000088, "Member 'UHDAIBehaviorHandler::SuppressionThreatThreshold' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, SuppressionFalloff) == 0x00008C, "Member 'UHDAIBehaviorHandler::SuppressionFalloff' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, SuppressionTime) == 0x000090, "Member 'UHDAIBehaviorHandler::SuppressionTime' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, SuppressionFallingOffDelay) == 0x000094, "Member 'UHDAIBehaviorHandler::SuppressionFallingOffDelay' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitThreatLevel) == 0x000098, "Member 'UHDAIBehaviorHandler::BeingHitThreatLevel' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitThreatThreshold) == 0x00009C, "Member 'UHDAIBehaviorHandler::BeingHitThreatThreshold' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitFalloff) == 0x0000A0, "Member 'UHDAIBehaviorHandler::BeingHitFalloff' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitThreatLevelSpikeProbability) == 0x0000A4, "Member 'UHDAIBehaviorHandler::BeingHitThreatLevelSpikeProbability' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitThreatLevelSpikeAmount) == 0x0000A8, "Member 'UHDAIBehaviorHandler::BeingHitThreatLevelSpikeAmount' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitFallingOffDelay) == 0x0000AC, "Member 'UHDAIBehaviorHandler::BeingHitFallingOffDelay' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, BeingHitTime) == 0x0000B0, "Member 'UHDAIBehaviorHandler::BeingHitTime' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, CurrentBehaviorState) == 0x0000B8, "Member 'UHDAIBehaviorHandler::CurrentBehaviorState' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, DefaultBehaviorStateClass) == 0x0000C0, "Member 'UHDAIBehaviorHandler::DefaultBehaviorStateClass' has a wrong offset!");
//(offsetof(UHDAIBehaviorHandler, MinDistanceToStartCombatState) == 0x0000CC, "Member 'UHDAIBehaviorHandler::MinDistanceToStartCombatState' has a wrong offset!");

// Class HDMain.HDServerListView
// 0x0058 (0x03C0 - 0x0368)
class UHDServerListView final  : public UListView
{
public:
	uint8                                         Pad_1178[0x4];                                     // 0x0368(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bItemSortAscending;                                // 0x036C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHDServerListSortBy                           ItemSortBy;                                        // 0x036D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1179[0x2];                                     // 0x036E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UHDServerListFilterRule>, struct FHDFilterRuleParams> ItemFilterRules;                                   // 0x0370(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)

public:
	void SetItemFilterRules(TMap<TSubclassOf<class UHDServerListFilterRule>, struct FHDFilterRuleParams>& FilterRules);
	void SetItemSortAscending(bool bSortAscending);
	void SetItemSortBy(EHDServerListSortBy SortBy);
	void SortListItems(bool bSortAscending, EHDServerListSortBy SortBy);

	bool DoesFilterExcludeListItem(class UObject* Item) const;
	struct FMargin GetDesiredEntryPaddingForItem(class UObject* Item) const;
	float GetEntrySpacing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDServerListView">();
	}
	static class UHDServerListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDServerListView>();
	}
};
//(alignof(UHDServerListView) == 0x000008, "Wrong alignment on UHDServerListView");
//(sizeof(UHDServerListView) == 0x0003C0, "Wrong size on UHDServerListView");
//(offsetof(UHDServerListView, bItemSortAscending) == 0x00036C, "Member 'UHDServerListView::bItemSortAscending' has a wrong offset!");
//(offsetof(UHDServerListView, ItemSortBy) == 0x00036D, "Member 'UHDServerListView::ItemSortBy' has a wrong offset!");
//(offsetof(UHDServerListView, ItemFilterRules) == 0x000370, "Member 'UHDServerListView::ItemFilterRules' has a wrong offset!");

// Class HDMain.HDGOAPGoal_EliminateEnemy
// 0x0000 (0x0068 - 0x0068)
class UHDGOAPGoal_EliminateEnemy final  : public UHDGOAPGoalBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPGoal_EliminateEnemy">();
	}
	static class UHDGOAPGoal_EliminateEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPGoal_EliminateEnemy>();
	}
};
//(alignof(UHDGOAPGoal_EliminateEnemy) == 0x000008, "Wrong alignment on UHDGOAPGoal_EliminateEnemy");
//(sizeof(UHDGOAPGoal_EliminateEnemy) == 0x000068, "Wrong size on UHDGOAPGoal_EliminateEnemy");

// Class HDMain.HDTeamCommChannelState
// 0x0030 (0x0058 - 0x0028)
class UHDTeamCommChannelState final  : public UObject
{
public:
	uint8                                         Pad_117B[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDTeamState*                           TeamState;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDFCommStateSetupParams                InitialSetupParams;                                // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_117C[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FName GetChannelNameForCommand(class AHDTeamState* CmdTeam);
	static class FName GetChannelNameForTeam(class AHDTeamState* Team);

	void SetupTeamChannelState(class AHDTeamState* ForTeamState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDTeamCommChannelState">();
	}
	static class UHDTeamCommChannelState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDTeamCommChannelState>();
	}
};
//(alignof(UHDTeamCommChannelState) == 0x000008, "Wrong alignment on UHDTeamCommChannelState");
//(sizeof(UHDTeamCommChannelState) == 0x000058, "Wrong size on UHDTeamCommChannelState");
//(offsetof(UHDTeamCommChannelState, TeamState) == 0x000030, "Member 'UHDTeamCommChannelState::TeamState' has a wrong offset!");
//(offsetof(UHDTeamCommChannelState, InitialSetupParams) == 0x000038, "Member 'UHDTeamCommChannelState::InitialSetupParams' has a wrong offset!");

// Class HDMain.HDAIBehDecision_MoveCloser
// 0x0020 (0x0058 - 0x0038)
class UHDAIBehDecision_MoveCloser final  : public UHDAIBehaviorDecisionBase
{
public:
	uint8                                         Pad_117D[0x20];                                    // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehDecision_MoveCloser">();
	}
	static class UHDAIBehDecision_MoveCloser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehDecision_MoveCloser>();
	}
};
//(alignof(UHDAIBehDecision_MoveCloser) == 0x000008, "Wrong alignment on UHDAIBehDecision_MoveCloser");
//(sizeof(UHDAIBehDecision_MoveCloser) == 0x000058, "Wrong size on UHDAIBehDecision_MoveCloser");

// Class HDMain.HDAIBehState_Reposition
// 0x0048 (0x00A0 - 0x0058)
class UHDAIBehState_Reposition final  : public UHDAIBehaviorStateBase
{
public:
	struct FVector                                MoveDestination;                                   // 0x0058(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_117E[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIBehState_BasicAASCombat*           CombatState;                                       // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSprinting : 1;                                  // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_117F[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintTimeMin;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTimeMax;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTimeEnd;                                     // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaThresholdMin;                         // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaThresholdMax;                         // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaThreshold;                            // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaMin;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLookAroundTimeMin;                           // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLookAroundTimeMax;                           // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLookAroundTimeEnd;                           // 0x0098(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1180[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSprinting();
	void StartSprinting();
	void StopSprinting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_Reposition">();
	}
	static class UHDAIBehState_Reposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_Reposition>();
	}
};
//(alignof(UHDAIBehState_Reposition) == 0x000008, "Wrong alignment on UHDAIBehState_Reposition");
//(sizeof(UHDAIBehState_Reposition) == 0x0000A0, "Wrong size on UHDAIBehState_Reposition");
//(offsetof(UHDAIBehState_Reposition, MoveDestination) == 0x000058, "Member 'UHDAIBehState_Reposition::MoveDestination' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, CombatState) == 0x000068, "Member 'UHDAIBehState_Reposition::CombatState' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintTimeMin) == 0x000074, "Member 'UHDAIBehState_Reposition::SprintTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintTimeMax) == 0x000078, "Member 'UHDAIBehState_Reposition::SprintTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintTimeEnd) == 0x00007C, "Member 'UHDAIBehState_Reposition::SprintTimeEnd' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintStaminaThresholdMin) == 0x000080, "Member 'UHDAIBehState_Reposition::SprintStaminaThresholdMin' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintStaminaThresholdMax) == 0x000084, "Member 'UHDAIBehState_Reposition::SprintStaminaThresholdMax' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintStaminaThreshold) == 0x000088, "Member 'UHDAIBehState_Reposition::SprintStaminaThreshold' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintStaminaMin) == 0x00008C, "Member 'UHDAIBehState_Reposition::SprintStaminaMin' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintLookAroundTimeMin) == 0x000090, "Member 'UHDAIBehState_Reposition::SprintLookAroundTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintLookAroundTimeMax) == 0x000094, "Member 'UHDAIBehState_Reposition::SprintLookAroundTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_Reposition, SprintLookAroundTimeEnd) == 0x000098, "Member 'UHDAIBehState_Reposition::SprintLookAroundTimeEnd' has a wrong offset!");

// Class HDMain.HDAIBehState_Attacking
// 0x0018 (0x0070 - 0x0058)
class UHDAIBehState_Attacking final  : public UHDAIBehaviorStateBase
{
public:
	uint8                                         bAttackingTimerStarted : 1;                        // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1181[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackingEndTime;                                  // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackingTimeMin;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackingTimeMax;                                  // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHDAIBehState_BasicAASCombat*           CombatState;                                       // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleAttacking();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_Attacking">();
	}
	static class UHDAIBehState_Attacking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_Attacking>();
	}
};
//(alignof(UHDAIBehState_Attacking) == 0x000008, "Wrong alignment on UHDAIBehState_Attacking");
//(sizeof(UHDAIBehState_Attacking) == 0x000070, "Wrong size on UHDAIBehState_Attacking");
//(offsetof(UHDAIBehState_Attacking, AttackingEndTime) == 0x00005C, "Member 'UHDAIBehState_Attacking::AttackingEndTime' has a wrong offset!");
//(offsetof(UHDAIBehState_Attacking, AttackingTimeMin) == 0x000060, "Member 'UHDAIBehState_Attacking::AttackingTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_Attacking, AttackingTimeMax) == 0x000064, "Member 'UHDAIBehState_Attacking::AttackingTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_Attacking, CombatState) == 0x000068, "Member 'UHDAIBehState_Attacking::CombatState' has a wrong offset!");

// Class HDMain.HDServerListItemData
// 0x00A0 (0x00C8 - 0x0028)
class UHDServerListItemData final  : public UObject
{
public:
	struct FHDServerInfo                          ServerInfo;                                        // 0x0028(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDServerListItemData">();
	}
	static class UHDServerListItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDServerListItemData>();
	}
};
//(alignof(UHDServerListItemData) == 0x000008, "Wrong alignment on UHDServerListItemData");
//(sizeof(UHDServerListItemData) == 0x0000C8, "Wrong size on UHDServerListItemData");
//(offsetof(UHDServerListItemData, ServerInfo) == 0x000028, "Member 'UHDServerListItemData::ServerInfo' has a wrong offset!");

// Class HDMain.HDAIBehState_BasicAAS
// 0x0058 (0x00B0 - 0x0058)
class UHDAIBehState_BasicAAS final  : public UHDAIBehaviorStateBase
{
public:
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIBehaviorHandler*                   BehaviorHandler;                                   // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIGroupBehaviorHandler*              GroupHandler;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICaptureHandler*                    CaptureHandler;                                    // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIBehaviorStateBase*                 CombatState;                                       // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 CaptureState;                                      // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDAIBehaviorStateBase*                 IdleState;                                         // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDAIBehaviorStateBase>     CombatStateClass;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHDAIBehaviorStateBase>     CaptureStateClass;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHDAIBehaviorStateBase>     IdleStateClass;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToStartCombatState;                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1182[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectBehaviorState();
	void StartCaptureState();
	void StartCombatRepositioning(const struct FVector& InMoveTarget);
	void StartCombatState(const struct FVector& InCombatTarget, const struct FVector& InNavigationAnchor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_BasicAAS">();
	}
	static class UHDAIBehState_BasicAAS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_BasicAAS>();
	}
};
//(alignof(UHDAIBehState_BasicAAS) == 0x000008, "Wrong alignment on UHDAIBehState_BasicAAS");
//(sizeof(UHDAIBehState_BasicAAS) == 0x0000B0, "Wrong size on UHDAIBehState_BasicAAS");
//(offsetof(UHDAIBehState_BasicAAS, CombatHandler) == 0x000058, "Member 'UHDAIBehState_BasicAAS::CombatHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, BehaviorHandler) == 0x000060, "Member 'UHDAIBehState_BasicAAS::BehaviorHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, GroupHandler) == 0x000068, "Member 'UHDAIBehState_BasicAAS::GroupHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, CaptureHandler) == 0x000070, "Member 'UHDAIBehState_BasicAAS::CaptureHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, CombatState) == 0x000078, "Member 'UHDAIBehState_BasicAAS::CombatState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, CaptureState) == 0x000080, "Member 'UHDAIBehState_BasicAAS::CaptureState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, IdleState) == 0x000088, "Member 'UHDAIBehState_BasicAAS::IdleState' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, CombatStateClass) == 0x000090, "Member 'UHDAIBehState_BasicAAS::CombatStateClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, CaptureStateClass) == 0x000098, "Member 'UHDAIBehState_BasicAAS::CaptureStateClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, IdleStateClass) == 0x0000A0, "Member 'UHDAIBehState_BasicAAS::IdleStateClass' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAAS, MinDistanceToStartCombatState) == 0x0000A8, "Member 'UHDAIBehState_BasicAAS::MinDistanceToStartCombatState' has a wrong offset!");

// Class HDMain.HDAIBehState_BasicAASCapture
// 0x0048 (0x00A0 - 0x0058)
class UHDAIBehState_BasicAASCapture final  : public UHDAIBehaviorStateBase
{
public:
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICaptureHandler*                    CaptureHandler;                                    // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIGroupBehaviorHandler*              GroupHandler;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsSprinting : 1;                                  // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1183[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintTimeMin;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTimeMax;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTimeEnd;                                     // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaThresholdMin;                         // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaThresholdMax;                         // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaThreshold;                            // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStaminaMin;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLookAroundTimeMin;                           // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLookAroundTimeMax;                           // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLookAroundTimeEnd;                           // 0x0098(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1184[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdvanceToObjective();
	void GroupLeaderDecisionMaking();
	void GroupMemberDecisionMaking();
	void HandleSprinting();
	void LoneWolfDecisionMaking();
	void PatrolAtObjective();
	void StartCapturingTheObjective();
	void StartSprinting();
	void StopSprinting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_BasicAASCapture">();
	}
	static class UHDAIBehState_BasicAASCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_BasicAASCapture>();
	}
};
//(alignof(UHDAIBehState_BasicAASCapture) == 0x000008, "Wrong alignment on UHDAIBehState_BasicAASCapture");
//(sizeof(UHDAIBehState_BasicAASCapture) == 0x0000A0, "Wrong size on UHDAIBehState_BasicAASCapture");
//(offsetof(UHDAIBehState_BasicAASCapture, NavigationHandler) == 0x000058, "Member 'UHDAIBehState_BasicAASCapture::NavigationHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, CaptureHandler) == 0x000060, "Member 'UHDAIBehState_BasicAASCapture::CaptureHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, GroupHandler) == 0x000068, "Member 'UHDAIBehState_BasicAASCapture::GroupHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintTimeMin) == 0x000074, "Member 'UHDAIBehState_BasicAASCapture::SprintTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintTimeMax) == 0x000078, "Member 'UHDAIBehState_BasicAASCapture::SprintTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintTimeEnd) == 0x00007C, "Member 'UHDAIBehState_BasicAASCapture::SprintTimeEnd' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintStaminaThresholdMin) == 0x000080, "Member 'UHDAIBehState_BasicAASCapture::SprintStaminaThresholdMin' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintStaminaThresholdMax) == 0x000084, "Member 'UHDAIBehState_BasicAASCapture::SprintStaminaThresholdMax' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintStaminaThreshold) == 0x000088, "Member 'UHDAIBehState_BasicAASCapture::SprintStaminaThreshold' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintStaminaMin) == 0x00008C, "Member 'UHDAIBehState_BasicAASCapture::SprintStaminaMin' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintLookAroundTimeMin) == 0x000090, "Member 'UHDAIBehState_BasicAASCapture::SprintLookAroundTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintLookAroundTimeMax) == 0x000094, "Member 'UHDAIBehState_BasicAASCapture::SprintLookAroundTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_BasicAASCapture, SprintLookAroundTimeEnd) == 0x000098, "Member 'UHDAIBehState_BasicAASCapture::SprintLookAroundTimeEnd' has a wrong offset!");

// Class HDMain.HDAIBehState_BasicAASIdle
// 0x0000 (0x0058 - 0x0058)
class UHDAIBehState_BasicAASIdle final  : public UHDAIBehaviorStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_BasicAASIdle">();
	}
	static class UHDAIBehState_BasicAASIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_BasicAASIdle>();
	}
};
//(alignof(UHDAIBehState_BasicAASIdle) == 0x000008, "Wrong alignment on UHDAIBehState_BasicAASIdle");
//(sizeof(UHDAIBehState_BasicAASIdle) == 0x000058, "Wrong size on UHDAIBehState_BasicAASIdle");

// Class HDMain.HDAIBehState_FindAttackSpot
// 0x0060 (0x00B8 - 0x0058)
class UHDAIBehState_FindAttackSpot final  : public UHDAIBehaviorStateBase
{
public:
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                FindAttackSpotStartLocation;                       // 0x0060(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FindAttackSpotEndLocation;                         // 0x006C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitialDirection;                                  // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDirectionRandomizationAngle;                // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FindAttackSpotMaxDistanceMin;                      // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FindAttackSpotMaxDistanceMax;                      // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumOfRandomAttemptsRemaining;                      // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumOfRandomAttempts;                            // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomAttemptNavRadius;                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsAtLocation : 1;                                 // 0x009C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1185[0x3];                                     // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitEndTime;                                       // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitTimeMin;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitTimeMax;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoUpdateSafeSpot : 1;                           // 0x00AC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1186[0x3];                                     // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIBehState_BasicAASCombat*           CombatState;                                       // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_FindAttackSpot">();
	}
	static class UHDAIBehState_FindAttackSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_FindAttackSpot>();
	}
};
//(alignof(UHDAIBehState_FindAttackSpot) == 0x000008, "Wrong alignment on UHDAIBehState_FindAttackSpot");
//(sizeof(UHDAIBehState_FindAttackSpot) == 0x0000B8, "Wrong size on UHDAIBehState_FindAttackSpot");
//(offsetof(UHDAIBehState_FindAttackSpot, NavigationHandler) == 0x000058, "Member 'UHDAIBehState_FindAttackSpot::NavigationHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, FindAttackSpotStartLocation) == 0x000060, "Member 'UHDAIBehState_FindAttackSpot::FindAttackSpotStartLocation' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, FindAttackSpotEndLocation) == 0x00006C, "Member 'UHDAIBehState_FindAttackSpot::FindAttackSpotEndLocation' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, InitialDirection) == 0x000078, "Member 'UHDAIBehState_FindAttackSpot::InitialDirection' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, InitialDirectionRandomizationAngle) == 0x000084, "Member 'UHDAIBehState_FindAttackSpot::InitialDirectionRandomizationAngle' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, FindAttackSpotMaxDistanceMin) == 0x000088, "Member 'UHDAIBehState_FindAttackSpot::FindAttackSpotMaxDistanceMin' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, FindAttackSpotMaxDistanceMax) == 0x00008C, "Member 'UHDAIBehState_FindAttackSpot::FindAttackSpotMaxDistanceMax' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, NumOfRandomAttemptsRemaining) == 0x000090, "Member 'UHDAIBehState_FindAttackSpot::NumOfRandomAttemptsRemaining' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, MaxNumOfRandomAttempts) == 0x000094, "Member 'UHDAIBehState_FindAttackSpot::MaxNumOfRandomAttempts' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, RandomAttemptNavRadius) == 0x000098, "Member 'UHDAIBehState_FindAttackSpot::RandomAttemptNavRadius' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, WaitEndTime) == 0x0000A0, "Member 'UHDAIBehState_FindAttackSpot::WaitEndTime' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, WaitTimeMin) == 0x0000A4, "Member 'UHDAIBehState_FindAttackSpot::WaitTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, WaitTimeMax) == 0x0000A8, "Member 'UHDAIBehState_FindAttackSpot::WaitTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_FindAttackSpot, CombatState) == 0x0000B0, "Member 'UHDAIBehState_FindAttackSpot::CombatState' has a wrong offset!");

// Class HDMain.HDAIBehState_FindSafeSpot
// 0x0078 (0x00D0 - 0x0058)
class UHDAIBehState_FindSafeSpot final  : public UHDAIBehaviorStateBase
{
public:
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIAimingHandler*                     AimingHandler;                                     // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlayerCharacter*                     OwnerChar;                                         // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FindSafeSpotStartLocation;                         // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FindSafeSpotEndLocation;                           // 0x0084(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InitialDirection;                                  // 0x0090(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDirectionRandomizationAngle;                // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FindSafeSpotMaxDistanceMin;                        // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FindSafeSpotMaxDistanceMax;                        // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumOfRandomAttemptsRemaining;                      // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumOfRandomAttempts;                            // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomAttemptNavRadius;                            // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsAtLocation : 1;                                 // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1187[0x3];                                     // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitEndTime;                                       // 0x00B8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitTimeMin;                                       // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitTimeMax;                                       // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoUpdateAttackSpot : 1;                         // 0x00C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSprintWhileFindingSafeSpot : 1;                   // 0x00C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1188[0x3];                                     // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIBehState_BasicAASCombat*           CombatState;                                       // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_FindSafeSpot">();
	}
	static class UHDAIBehState_FindSafeSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_FindSafeSpot>();
	}
};
//(alignof(UHDAIBehState_FindSafeSpot) == 0x000008, "Wrong alignment on UHDAIBehState_FindSafeSpot");
//(sizeof(UHDAIBehState_FindSafeSpot) == 0x0000D0, "Wrong size on UHDAIBehState_FindSafeSpot");
//(offsetof(UHDAIBehState_FindSafeSpot, NavigationHandler) == 0x000058, "Member 'UHDAIBehState_FindSafeSpot::NavigationHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, CombatHandler) == 0x000060, "Member 'UHDAIBehState_FindSafeSpot::CombatHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, AimingHandler) == 0x000068, "Member 'UHDAIBehState_FindSafeSpot::AimingHandler' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, OwnerChar) == 0x000070, "Member 'UHDAIBehState_FindSafeSpot::OwnerChar' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, FindSafeSpotStartLocation) == 0x000078, "Member 'UHDAIBehState_FindSafeSpot::FindSafeSpotStartLocation' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, FindSafeSpotEndLocation) == 0x000084, "Member 'UHDAIBehState_FindSafeSpot::FindSafeSpotEndLocation' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, InitialDirection) == 0x000090, "Member 'UHDAIBehState_FindSafeSpot::InitialDirection' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, InitialDirectionRandomizationAngle) == 0x00009C, "Member 'UHDAIBehState_FindSafeSpot::InitialDirectionRandomizationAngle' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, FindSafeSpotMaxDistanceMin) == 0x0000A0, "Member 'UHDAIBehState_FindSafeSpot::FindSafeSpotMaxDistanceMin' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, FindSafeSpotMaxDistanceMax) == 0x0000A4, "Member 'UHDAIBehState_FindSafeSpot::FindSafeSpotMaxDistanceMax' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, NumOfRandomAttemptsRemaining) == 0x0000A8, "Member 'UHDAIBehState_FindSafeSpot::NumOfRandomAttemptsRemaining' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, MaxNumOfRandomAttempts) == 0x0000AC, "Member 'UHDAIBehState_FindSafeSpot::MaxNumOfRandomAttempts' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, RandomAttemptNavRadius) == 0x0000B0, "Member 'UHDAIBehState_FindSafeSpot::RandomAttemptNavRadius' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, WaitEndTime) == 0x0000B8, "Member 'UHDAIBehState_FindSafeSpot::WaitEndTime' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, WaitTimeMin) == 0x0000BC, "Member 'UHDAIBehState_FindSafeSpot::WaitTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, WaitTimeMax) == 0x0000C0, "Member 'UHDAIBehState_FindSafeSpot::WaitTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_FindSafeSpot, CombatState) == 0x0000C8, "Member 'UHDAIBehState_FindSafeSpot::CombatState' has a wrong offset!");

// Class HDMain.HDAIBehState_SafeSpotting
// 0x0018 (0x0070 - 0x0058)
class UHDAIBehState_SafeSpotting final  : public UHDAIBehaviorStateBase
{
public:
	uint8                                         bSafespottingTimerStarted : 1;                     // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1189[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SafespottingEndTime;                               // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SafespottingTimeMin;                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafespottingTimeMax;                               // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHDAIBehState_BasicAASCombat*           CombatState;                                       // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleSafeSpotting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIBehState_SafeSpotting">();
	}
	static class UHDAIBehState_SafeSpotting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIBehState_SafeSpotting>();
	}
};
//(alignof(UHDAIBehState_SafeSpotting) == 0x000008, "Wrong alignment on UHDAIBehState_SafeSpotting");
//(sizeof(UHDAIBehState_SafeSpotting) == 0x000070, "Wrong size on UHDAIBehState_SafeSpotting");
//(offsetof(UHDAIBehState_SafeSpotting, SafespottingEndTime) == 0x00005C, "Member 'UHDAIBehState_SafeSpotting::SafespottingEndTime' has a wrong offset!");
//(offsetof(UHDAIBehState_SafeSpotting, SafespottingTimeMin) == 0x000060, "Member 'UHDAIBehState_SafeSpotting::SafespottingTimeMin' has a wrong offset!");
//(offsetof(UHDAIBehState_SafeSpotting, SafespottingTimeMax) == 0x000064, "Member 'UHDAIBehState_SafeSpotting::SafespottingTimeMax' has a wrong offset!");
//(offsetof(UHDAIBehState_SafeSpotting, CombatState) == 0x000068, "Member 'UHDAIBehState_SafeSpotting::CombatState' has a wrong offset!");

// Class HDMain.HDAICombatHandler
// 0x01A0 (0x01F0 - 0x0050)
class UHDAICombatHandler final  : public UHDAIHandlerBase
{
public:
	class UHDAIBehaviorHandler*                   BehaviorHandler;                                   // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIVocalHandler*                      VocalHandler;                                      // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Enemy;                                             // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118A[0x4];                                     // 0x0068(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CombatTargetLocation;                              // 0x006C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CustomCombatTargetLocation;                        // 0x0078(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHDAICombatTargetType                         CombatTargetLocationType;                          // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDoNotAttack : 1;                                  // 0x0085(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWeaponAutoReload : 1;                             // 0x0085(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWeaponMovementFire : 1;                           // 0x0085(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bWeaponHasAmmo : 1;                                // 0x0085(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_118B[0x2];                                     // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponNextFireTime;                                // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackRateMin;                                     // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackRateMax;                                     // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BurstAttackProbability;                            // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BurstAttackNumberMin;                              // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BurstAttackNumberMax;                              // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentBurstAttackNumber;                          // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponStopFireTime;                                // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponStopFireTimeMin;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponStopFireTimeMax;                             // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bWeaponInfiniteAmmo : 1;                           // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWeaponInfiniteClipAmmo : 1;                       // 0x00B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreFriendlySuppression : 1;                    // 0x00B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreFriendlyHits : 1;                           // 0x00B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_118C[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReload;                                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReceiveSuppression;                              // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReceiveHitDamage;                                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FHDAISuppressionSource>         SuppressionSources;                                // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumSuppressionSources;                          // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionSourceTimeThreshold;                    // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionSourceUpdateRate;                       // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionSourceUpdateTime;                       // 0x0104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDKit*                                 CurrentKit;                                        // 0x0108(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpecificItemType                             CurrentSpecificItemType;                           // 0x0110(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118D[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHDAIItemData>                  EquipmentReferences;                               // 0x0118(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EquipmentHandlingTime;                             // 0x0128(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EquipmentHandlingRate;                             // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EquipmentHandlingRateVariation;                    // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSpecialtyItemInUse : 1;                           // 0x0134(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProjectileWeaponInUse : 1;                        // 0x0134(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_118E[0x3];                                     // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AfterEquipCooldownTime;                            // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpecialtyItemUseTimeLimit;                         // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterSpecialtyItemUsedTimeLimit;                   // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118F[0x4];                                     // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESpecificItemType, struct FHDAISpecificItemTypeAttackData> ItemAttackData;                                    // 0x0148(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHDAISpecificItemTypeAttackData        DefaultItemAttackData;                             // 0x0198(0x002C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GrenadeLauncherRangeMin;                           // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeLauncherRangeMax;                           // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrenadeLauncherChance;                             // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RocketLauncherRangeMin;                            // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RocketLauncherRangeMax;                            // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RocketLauncherChance;                              // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FragGrenadeRangeMin;                               // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FragGrenadeRangeMax;                               // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FragGrenadeChance;                                 // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmokeGrenadeRangeMin;                              // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmokeGrenadeChance;                                // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddSuppressionSource(const struct FHDAISuppressionSource& InSuppressionSource);
	void ClearCombatTargetLocation();
	void ClearCustomCombatTargetLocation();
	struct FVector GetMostRelevantSuppressionSource();
	struct FVector GetOldestSuppressionSource();
	void PauseAttack();
	void ReceiveHitDamage(class ADFBaseProjectile* OtherProjectile, class ADFBasePickup* Pickup);
	void ReceiveSuppression(class ADFBaseProjectile* OtherProjectile, class ADFBasePickup* Pickup);
	void Reload(class AHDBaseWeapon* InWeapon);
	void SetEnemy(class AActor* NewEnemy);
	void SetItemAttackParameters(struct FHDAISpecificItemTypeAttackData& InAttackData);
	void SetNextAttackTime();
	void SetupEquipmentReferences();
	void StartAttack();
	void StopAttack();
	void StopUsingSpecialtyItem();
	void UpdateAttackParameters();
	void UpdateEquipmentHandling();
	void UpdateSuppressionSources();

	bool CanAttackEnemy(bool bCheckFireTime, bool bIgnoreAmmoReloadCheck) const;
	bool HasAmmoLoaded() const;
	bool HasValidCombatTargetLocation() const;
	bool HasValidCustomCombatTargetLocation() const;
	bool HasValidEnemy(bool bAliveCheck) const;
	bool IsFiring() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAICombatHandler">();
	}
	static class UHDAICombatHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAICombatHandler>();
	}
};
//(alignof(UHDAICombatHandler) == 0x000008, "Wrong alignment on UHDAICombatHandler");
//(sizeof(UHDAICombatHandler) == 0x0001F0, "Wrong size on UHDAICombatHandler");
//(offsetof(UHDAICombatHandler, BehaviorHandler) == 0x000050, "Member 'UHDAICombatHandler::BehaviorHandler' has a wrong offset!");
//(offsetof(UHDAICombatHandler, VocalHandler) == 0x000058, "Member 'UHDAICombatHandler::VocalHandler' has a wrong offset!");
//(offsetof(UHDAICombatHandler, Enemy) == 0x000060, "Member 'UHDAICombatHandler::Enemy' has a wrong offset!");
//(offsetof(UHDAICombatHandler, CombatTargetLocation) == 0x00006C, "Member 'UHDAICombatHandler::CombatTargetLocation' has a wrong offset!");
//(offsetof(UHDAICombatHandler, CustomCombatTargetLocation) == 0x000078, "Member 'UHDAICombatHandler::CustomCombatTargetLocation' has a wrong offset!");
//(offsetof(UHDAICombatHandler, CombatTargetLocationType) == 0x000084, "Member 'UHDAICombatHandler::CombatTargetLocationType' has a wrong offset!");
//(offsetof(UHDAICombatHandler, WeaponNextFireTime) == 0x000088, "Member 'UHDAICombatHandler::WeaponNextFireTime' has a wrong offset!");
//(offsetof(UHDAICombatHandler, AttackRateMin) == 0x00008C, "Member 'UHDAICombatHandler::AttackRateMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, AttackRateMax) == 0x000090, "Member 'UHDAICombatHandler::AttackRateMax' has a wrong offset!");
//(offsetof(UHDAICombatHandler, BurstAttackProbability) == 0x000094, "Member 'UHDAICombatHandler::BurstAttackProbability' has a wrong offset!");
//(offsetof(UHDAICombatHandler, BurstAttackNumberMin) == 0x000098, "Member 'UHDAICombatHandler::BurstAttackNumberMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, BurstAttackNumberMax) == 0x00009C, "Member 'UHDAICombatHandler::BurstAttackNumberMax' has a wrong offset!");
//(offsetof(UHDAICombatHandler, CurrentBurstAttackNumber) == 0x0000A0, "Member 'UHDAICombatHandler::CurrentBurstAttackNumber' has a wrong offset!");
//(offsetof(UHDAICombatHandler, WeaponStopFireTime) == 0x0000A4, "Member 'UHDAICombatHandler::WeaponStopFireTime' has a wrong offset!");
//(offsetof(UHDAICombatHandler, WeaponStopFireTimeMin) == 0x0000A8, "Member 'UHDAICombatHandler::WeaponStopFireTimeMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, WeaponStopFireTimeMax) == 0x0000AC, "Member 'UHDAICombatHandler::WeaponStopFireTimeMax' has a wrong offset!");
//(offsetof(UHDAICombatHandler, OnReload) == 0x0000B8, "Member 'UHDAICombatHandler::OnReload' has a wrong offset!");
//(offsetof(UHDAICombatHandler, OnReceiveSuppression) == 0x0000C8, "Member 'UHDAICombatHandler::OnReceiveSuppression' has a wrong offset!");
//(offsetof(UHDAICombatHandler, OnReceiveHitDamage) == 0x0000D8, "Member 'UHDAICombatHandler::OnReceiveHitDamage' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SuppressionSources) == 0x0000E8, "Member 'UHDAICombatHandler::SuppressionSources' has a wrong offset!");
//(offsetof(UHDAICombatHandler, MaxNumSuppressionSources) == 0x0000F8, "Member 'UHDAICombatHandler::MaxNumSuppressionSources' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SuppressionSourceTimeThreshold) == 0x0000FC, "Member 'UHDAICombatHandler::SuppressionSourceTimeThreshold' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SuppressionSourceUpdateRate) == 0x000100, "Member 'UHDAICombatHandler::SuppressionSourceUpdateRate' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SuppressionSourceUpdateTime) == 0x000104, "Member 'UHDAICombatHandler::SuppressionSourceUpdateTime' has a wrong offset!");
//(offsetof(UHDAICombatHandler, CurrentKit) == 0x000108, "Member 'UHDAICombatHandler::CurrentKit' has a wrong offset!");
//(offsetof(UHDAICombatHandler, CurrentSpecificItemType) == 0x000110, "Member 'UHDAICombatHandler::CurrentSpecificItemType' has a wrong offset!");
//(offsetof(UHDAICombatHandler, EquipmentReferences) == 0x000118, "Member 'UHDAICombatHandler::EquipmentReferences' has a wrong offset!");
//(offsetof(UHDAICombatHandler, EquipmentHandlingTime) == 0x000128, "Member 'UHDAICombatHandler::EquipmentHandlingTime' has a wrong offset!");
//(offsetof(UHDAICombatHandler, EquipmentHandlingRate) == 0x00012C, "Member 'UHDAICombatHandler::EquipmentHandlingRate' has a wrong offset!");
//(offsetof(UHDAICombatHandler, EquipmentHandlingRateVariation) == 0x000130, "Member 'UHDAICombatHandler::EquipmentHandlingRateVariation' has a wrong offset!");
//(offsetof(UHDAICombatHandler, AfterEquipCooldownTime) == 0x000138, "Member 'UHDAICombatHandler::AfterEquipCooldownTime' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SpecialtyItemUseTimeLimit) == 0x00013C, "Member 'UHDAICombatHandler::SpecialtyItemUseTimeLimit' has a wrong offset!");
//(offsetof(UHDAICombatHandler, AfterSpecialtyItemUsedTimeLimit) == 0x000140, "Member 'UHDAICombatHandler::AfterSpecialtyItemUsedTimeLimit' has a wrong offset!");
//(offsetof(UHDAICombatHandler, ItemAttackData) == 0x000148, "Member 'UHDAICombatHandler::ItemAttackData' has a wrong offset!");
//(offsetof(UHDAICombatHandler, DefaultItemAttackData) == 0x000198, "Member 'UHDAICombatHandler::DefaultItemAttackData' has a wrong offset!");
//(offsetof(UHDAICombatHandler, GrenadeLauncherRangeMin) == 0x0001C4, "Member 'UHDAICombatHandler::GrenadeLauncherRangeMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, GrenadeLauncherRangeMax) == 0x0001C8, "Member 'UHDAICombatHandler::GrenadeLauncherRangeMax' has a wrong offset!");
//(offsetof(UHDAICombatHandler, GrenadeLauncherChance) == 0x0001CC, "Member 'UHDAICombatHandler::GrenadeLauncherChance' has a wrong offset!");
//(offsetof(UHDAICombatHandler, RocketLauncherRangeMin) == 0x0001D0, "Member 'UHDAICombatHandler::RocketLauncherRangeMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, RocketLauncherRangeMax) == 0x0001D4, "Member 'UHDAICombatHandler::RocketLauncherRangeMax' has a wrong offset!");
//(offsetof(UHDAICombatHandler, RocketLauncherChance) == 0x0001D8, "Member 'UHDAICombatHandler::RocketLauncherChance' has a wrong offset!");
//(offsetof(UHDAICombatHandler, FragGrenadeRangeMin) == 0x0001DC, "Member 'UHDAICombatHandler::FragGrenadeRangeMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, FragGrenadeRangeMax) == 0x0001E0, "Member 'UHDAICombatHandler::FragGrenadeRangeMax' has a wrong offset!");
//(offsetof(UHDAICombatHandler, FragGrenadeChance) == 0x0001E4, "Member 'UHDAICombatHandler::FragGrenadeChance' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SmokeGrenadeRangeMin) == 0x0001E8, "Member 'UHDAICombatHandler::SmokeGrenadeRangeMin' has a wrong offset!");
//(offsetof(UHDAICombatHandler, SmokeGrenadeChance) == 0x0001EC, "Member 'UHDAICombatHandler::SmokeGrenadeChance' has a wrong offset!");

// Class HDMain.HDAIController
// 0x0030 (0x0360 - 0x0330)
class AHDAIController : public ADFBaseAIController
{
public:
	class UHDPlayerComponent*                     PlayerComponent;                                   // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDGOAPComponent*                       GOAPComponent;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanJoinSquads : 1;                                // 0x0340(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanJoinPlayerSquads : 1;                          // 0x0340(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanCreateSquads : 1;                              // 0x0340(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1190[0x3];                                     // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumberOfAILedSquads;                            // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfSquadMembers;                           // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfAISquadMembers;                         // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseFactionSpecifiedSquadLeaderKit : 1;            // 0x0350(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseFactionSpecifiedSquadMemberKit : 1;            // 0x0350(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1191[0x3];                                     // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FocusActorPerceivedLocation;                       // 0x0354(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool JoinOrCreateSquad();

	class UHDKit* GetFactionSpecifiedSquadLeaderKit() const;
	class UHDKit* GetFactionSpecifiedSquadMemberKit() const;
	TSubclassOf<class APawn> GetStartPawnClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIController">();
	}
	static class AHDAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDAIController>();
	}
};
//(alignof(AHDAIController) == 0x000008, "Wrong alignment on AHDAIController");
//(sizeof(AHDAIController) == 0x000360, "Wrong size on AHDAIController");
//(offsetof(AHDAIController, PlayerComponent) == 0x000330, "Member 'AHDAIController::PlayerComponent' has a wrong offset!");
//(offsetof(AHDAIController, GOAPComponent) == 0x000338, "Member 'AHDAIController::GOAPComponent' has a wrong offset!");
//(offsetof(AHDAIController, MaxNumberOfAILedSquads) == 0x000344, "Member 'AHDAIController::MaxNumberOfAILedSquads' has a wrong offset!");
//(offsetof(AHDAIController, MaxNumberOfSquadMembers) == 0x000348, "Member 'AHDAIController::MaxNumberOfSquadMembers' has a wrong offset!");
//(offsetof(AHDAIController, MaxNumberOfAISquadMembers) == 0x00034C, "Member 'AHDAIController::MaxNumberOfAISquadMembers' has a wrong offset!");
//(offsetof(AHDAIController, FocusActorPerceivedLocation) == 0x000354, "Member 'AHDAIController::FocusActorPerceivedLocation' has a wrong offset!");

// Class HDMain.HDAIGroupBehaviorHandler
// 0x00B0 (0x0100 - 0x0050)
class UHDAIGroupBehaviorHandler final  : public UHDAIHandlerBase
{
public:
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICaptureHandler*                    CaptureHandler;                                    // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlayerState*                         PlayerState;                                       // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsGroupLeader : 1;                                // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsGroupMember : 1;                                // 0x0068(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGroupDataIsSet : 1;                               // 0x0068(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bGroupDataIsSynchronized : 1;                      // 0x0068(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLeaderIsHuman : 1;                                // 0x0068(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsRespawned : 1;                                  // 0x0068(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1192[0x3];                                     // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumValidGroupMembers;                              // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumGroupMembersOnPoint;                            // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWaitingForGroupMembers : 1;                       // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1193[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitingForMembersStartTime;                        // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsGroupWaiting : 1;                               // 0x007C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1194[0x3];                                     // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroupWaitTimeDuration;                             // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroupWaitTimeEnd;                                  // 0x0084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitingTimePerGroupMember;                         // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitingRadiusMultiplier;                           // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinNumGroupMembersOnPoint;                         // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdvanceWaitTimeDurationMin;                        // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdvanceWaitTimeDurationMax;                        // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolWaitTimeDurationMin;                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolWaitTimeDurationMax;                         // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FormationIndex;                                    // 0x00A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FormationOffset;                                   // 0x00A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupFormationRadius;                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupFormationSlotRadius;                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupFormationSlotDistance;                        // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FormationSlots;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowHumanLeaderTime;                             // 0x00D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FollowHumanLeaderPatrolTime;                       // 0x00D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FollowHumanLeaderLastKnownLocation;                // 0x00D8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableFollowHumanLeader : 1;                      // 0x00E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1195[0x3];                                     // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FollowHumanLeaderInterval;                         // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowHumanLeaderVelocityMultiplier;               // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowHumanLeaderAcceptanceRadius;                 // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowHumanLeaderRange;                            // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowHumanLeaderPatrolTimeThreshold;              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumGroupMembersInCombat;                           // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AllGroupMembersAreOnPoint();
	void BroadcastGroupData();
	void CountGroupMembers();
	void FollowHumanLeader();
	struct FHDAIGroupData GetGroupData();
	class AHDPlayerState* GetGroupLeader();
	TArray<class AHDAIController*> GetGroupMembers();
	void InformGroupOnContact(const struct FVector& InCombatTarget, const struct FVector& InNavigationAnchor);
	void InformGroupOnLostContact();
	void InformLeaderOnContact(const struct FVector& InCombatTarget, const struct FVector& InNavigationAnchor);
	bool IsGroupWaitTimeOver();
	void OnOwnerDeath(class APawn* VictimPawn, class AController* VictimController, float KillingDamage, struct FDamageEvent& DamageEvent, class APawn* InstigatingPawn, class AActor* DamageCauser);
	bool RequestGroupDataSync();
	void SetGroupParams();
	void SetupGroupData();
	void StartGroupWaitTime();
	void SyncGroupData(struct FHDAIGroupData& InGroupData);

	int32 GetNumGroupMembersInCombat() const;
	int32 GetNumValidGroupMembers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIGroupBehaviorHandler">();
	}
	static class UHDAIGroupBehaviorHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIGroupBehaviorHandler>();
	}
};
//(alignof(UHDAIGroupBehaviorHandler) == 0x000008, "Wrong alignment on UHDAIGroupBehaviorHandler");
//(sizeof(UHDAIGroupBehaviorHandler) == 0x000100, "Wrong size on UHDAIGroupBehaviorHandler");
//(offsetof(UHDAIGroupBehaviorHandler, NavigationHandler) == 0x000050, "Member 'UHDAIGroupBehaviorHandler::NavigationHandler' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, CaptureHandler) == 0x000058, "Member 'UHDAIGroupBehaviorHandler::CaptureHandler' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, PlayerState) == 0x000060, "Member 'UHDAIGroupBehaviorHandler::PlayerState' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, NumValidGroupMembers) == 0x00006C, "Member 'UHDAIGroupBehaviorHandler::NumValidGroupMembers' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, NumGroupMembersOnPoint) == 0x000070, "Member 'UHDAIGroupBehaviorHandler::NumGroupMembersOnPoint' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, WaitingForMembersStartTime) == 0x000078, "Member 'UHDAIGroupBehaviorHandler::WaitingForMembersStartTime' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, GroupWaitTimeDuration) == 0x000080, "Member 'UHDAIGroupBehaviorHandler::GroupWaitTimeDuration' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, GroupWaitTimeEnd) == 0x000084, "Member 'UHDAIGroupBehaviorHandler::GroupWaitTimeEnd' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, WaitingTimePerGroupMember) == 0x000088, "Member 'UHDAIGroupBehaviorHandler::WaitingTimePerGroupMember' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, WaitingRadiusMultiplier) == 0x00008C, "Member 'UHDAIGroupBehaviorHandler::WaitingRadiusMultiplier' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, MinNumGroupMembersOnPoint) == 0x000090, "Member 'UHDAIGroupBehaviorHandler::MinNumGroupMembersOnPoint' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, AdvanceWaitTimeDurationMin) == 0x000094, "Member 'UHDAIGroupBehaviorHandler::AdvanceWaitTimeDurationMin' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, AdvanceWaitTimeDurationMax) == 0x000098, "Member 'UHDAIGroupBehaviorHandler::AdvanceWaitTimeDurationMax' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, PatrolWaitTimeDurationMin) == 0x00009C, "Member 'UHDAIGroupBehaviorHandler::PatrolWaitTimeDurationMin' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, PatrolWaitTimeDurationMax) == 0x0000A0, "Member 'UHDAIGroupBehaviorHandler::PatrolWaitTimeDurationMax' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FormationIndex) == 0x0000A4, "Member 'UHDAIGroupBehaviorHandler::FormationIndex' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FormationOffset) == 0x0000A8, "Member 'UHDAIGroupBehaviorHandler::FormationOffset' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, GroupFormationRadius) == 0x0000B4, "Member 'UHDAIGroupBehaviorHandler::GroupFormationRadius' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, GroupFormationSlotRadius) == 0x0000B8, "Member 'UHDAIGroupBehaviorHandler::GroupFormationSlotRadius' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, GroupFormationSlotDistance) == 0x0000BC, "Member 'UHDAIGroupBehaviorHandler::GroupFormationSlotDistance' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FormationSlots) == 0x0000C0, "Member 'UHDAIGroupBehaviorHandler::FormationSlots' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderTime) == 0x0000D0, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderTime' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderPatrolTime) == 0x0000D4, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderPatrolTime' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderLastKnownLocation) == 0x0000D8, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderLastKnownLocation' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderInterval) == 0x0000E8, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderInterval' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderVelocityMultiplier) == 0x0000EC, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderVelocityMultiplier' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderAcceptanceRadius) == 0x0000F0, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderAcceptanceRadius' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderRange) == 0x0000F4, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderRange' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, FollowHumanLeaderPatrolTimeThreshold) == 0x0000F8, "Member 'UHDAIGroupBehaviorHandler::FollowHumanLeaderPatrolTimeThreshold' has a wrong offset!");
//(offsetof(UHDAIGroupBehaviorHandler, NumGroupMembersInCombat) == 0x0000FC, "Member 'UHDAIGroupBehaviorHandler::NumGroupMembersInCombat' has a wrong offset!");

// Class HDMain.HDAINavigationHandler
// 0x00D0 (0x0120 - 0x0050)
class UHDAINavigationHandler final  : public UHDAIHandlerBase
{
public:
	class UNavigationSystemV1*                    NavSystem;                                         // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoving;                                           // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1197[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredLocation;                                   // 0x005C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptanceRadius;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIgnoreZeroVectorGoto : 1;                         // 0x006C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1198[0x3];                                     // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHDAIMasterNavPoint>            MasterNavPath;                                     // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MasterNavPathLength;                               // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetNavPoint;                                    // 0x0084(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TargetNavPointIndex;                               // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                NavigationAnchorPoint;                             // 0x0094(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RemainingNavPathLength;                            // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPawnIsAtTheEndOfPath : 1;                         // 0x00A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1199[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavPathSegmentLengthMin;                           // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavPathSegmentLengthMax;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCompensatePartialPathForGroupFormationRadius : 1; // 0x00B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119A[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartialPathGroupRadiusMultiplier;                  // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationAnchorRandomRange;                       // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119B[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMoveToLocationFailed;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         MoveToFailedTime;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveToFailedTimeDelay;                             // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveToFailedRandomizationRadiusBase;               // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveToFailedRandomizationRadiusIncrement;          // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxMoveToFailedRandomizationRadius;                // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MoveToFailedAttemptNumber;                         // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveToFailedAttemptResetTimer;                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bMoveToFailedIsBeingHandled : 1;                   // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_119C[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDBaseCapturePoint*                    SavedCapturePoint;                                 // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckCheckTime;                                    // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckCheckInterval;                                // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckCheckDistance;                                // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                StuckCheckLastLocation;                            // 0x0104(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableRVOAvoidance : 1;                           // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_119D[0x3];                                     // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RVOAvoidanceConsiderationRadius;                   // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RVOAvoidanceWeight;                                // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119E[0x4];                                     // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool PointsAreEqualXY(struct FVector& Vector1, struct FVector& Vector2, float Tolerance);

	bool CheckPawnStuckStatus();
	void GotoLocation(struct FVector& InLocation);
	void GotoLocationRandomized(struct FVector& InLocation, float InRandomizationRadius);
	void HandleMoveToFailed();
	void MakeNavPathSegment();
	bool MakeNewMasterNavPath(const struct FVector& InStart, const struct FVector& InDestination);
	bool MakePathToDesiredLocation();
	void MoveToLocationFailed();
	void OnMoveToFailed();
	void SetDesiredLocation(struct FVector& InDesiredLocation);
	void SetupRVOAvoidance();

	bool FindNavLocationInsideControlPoint(class AHDBaseCapturePoint* CP, struct FVector* OutNavLoc) const;
	void FixVectorValuesNaN(struct FVector* InVector, bool bRandomize) const;
	bool IsMoving() const;
	bool IsNavDataValidForAllControlPoints() const;
	bool IsNavigationPossible() const;
	bool IsPawnAtDestination() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAINavigationHandler">();
	}
	static class UHDAINavigationHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAINavigationHandler>();
	}
};
//(alignof(UHDAINavigationHandler) == 0x000008, "Wrong alignment on UHDAINavigationHandler");
//(sizeof(UHDAINavigationHandler) == 0x000120, "Wrong size on UHDAINavigationHandler");
//(offsetof(UHDAINavigationHandler, NavSystem) == 0x000050, "Member 'UHDAINavigationHandler::NavSystem' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, bMoving) == 0x000058, "Member 'UHDAINavigationHandler::bMoving' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, DesiredLocation) == 0x00005C, "Member 'UHDAINavigationHandler::DesiredLocation' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, AcceptanceRadius) == 0x000068, "Member 'UHDAINavigationHandler::AcceptanceRadius' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MasterNavPath) == 0x000070, "Member 'UHDAINavigationHandler::MasterNavPath' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MasterNavPathLength) == 0x000080, "Member 'UHDAINavigationHandler::MasterNavPathLength' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, TargetNavPoint) == 0x000084, "Member 'UHDAINavigationHandler::TargetNavPoint' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, TargetNavPointIndex) == 0x000090, "Member 'UHDAINavigationHandler::TargetNavPointIndex' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, NavigationAnchorPoint) == 0x000094, "Member 'UHDAINavigationHandler::NavigationAnchorPoint' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, RemainingNavPathLength) == 0x0000A0, "Member 'UHDAINavigationHandler::RemainingNavPathLength' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, NavPathSegmentLengthMin) == 0x0000A8, "Member 'UHDAINavigationHandler::NavPathSegmentLengthMin' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, NavPathSegmentLengthMax) == 0x0000AC, "Member 'UHDAINavigationHandler::NavPathSegmentLengthMax' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, PartialPathGroupRadiusMultiplier) == 0x0000B4, "Member 'UHDAINavigationHandler::PartialPathGroupRadiusMultiplier' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, NavigationAnchorRandomRange) == 0x0000B8, "Member 'UHDAINavigationHandler::NavigationAnchorRandomRange' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, OnMoveToLocationFailed) == 0x0000C0, "Member 'UHDAINavigationHandler::OnMoveToLocationFailed' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MoveToFailedTime) == 0x0000D0, "Member 'UHDAINavigationHandler::MoveToFailedTime' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MoveToFailedTimeDelay) == 0x0000D4, "Member 'UHDAINavigationHandler::MoveToFailedTimeDelay' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MoveToFailedRandomizationRadiusBase) == 0x0000D8, "Member 'UHDAINavigationHandler::MoveToFailedRandomizationRadiusBase' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MoveToFailedRandomizationRadiusIncrement) == 0x0000DC, "Member 'UHDAINavigationHandler::MoveToFailedRandomizationRadiusIncrement' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MaxMoveToFailedRandomizationRadius) == 0x0000E0, "Member 'UHDAINavigationHandler::MaxMoveToFailedRandomizationRadius' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MoveToFailedAttemptNumber) == 0x0000E4, "Member 'UHDAINavigationHandler::MoveToFailedAttemptNumber' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, MoveToFailedAttemptResetTimer) == 0x0000E8, "Member 'UHDAINavigationHandler::MoveToFailedAttemptResetTimer' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, SavedCapturePoint) == 0x0000F0, "Member 'UHDAINavigationHandler::SavedCapturePoint' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, StuckCheckTime) == 0x0000F8, "Member 'UHDAINavigationHandler::StuckCheckTime' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, StuckCheckInterval) == 0x0000FC, "Member 'UHDAINavigationHandler::StuckCheckInterval' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, StuckCheckDistance) == 0x000100, "Member 'UHDAINavigationHandler::StuckCheckDistance' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, StuckCheckLastLocation) == 0x000104, "Member 'UHDAINavigationHandler::StuckCheckLastLocation' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, RVOAvoidanceConsiderationRadius) == 0x000114, "Member 'UHDAINavigationHandler::RVOAvoidanceConsiderationRadius' has a wrong offset!");
//(offsetof(UHDAINavigationHandler, RVOAvoidanceWeight) == 0x000118, "Member 'UHDAINavigationHandler::RVOAvoidanceWeight' has a wrong offset!");

// Class HDMain.HDAIPerceptionComponent
// 0x0040 (0x00F0 - 0x00B0)
class UHDAIPerceptionComponent final  : public UActorComponent
{
public:
	class AHDPlayerCharacter*                     OwnerPlayer;                                       // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableAdvancedLineTracing : 1;                    // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11A3[0x3];                                     // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObserverSightRadius;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObserverLoseSightRadius;                           // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToObserverRangeFar;                        // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToObserverRangeNear;                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bComplexSightLineTrace : 1;                        // 0x00CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11A4[0x3];                                     // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShoulderLocationFactor;                            // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeFactorWeight;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanceFactorWeight;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementFactorWeight;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanceFactorMaxValue;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanceFactorMinValue;                              // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OwnerMaxMovementSpeed;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OwnerDefaultHalfHeight;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float CalcSightStrength(float Distance) const;
	bool CanBeSeenFrom(struct FVector& ObserverLocation, struct FVector* OutSeenLocation, int32* NumberOfLoSChecksPerformed, float* OutSightStrength, class AActor* IgnoreActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIPerceptionComponent">();
	}
	static class UHDAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIPerceptionComponent>();
	}
};
//(alignof(UHDAIPerceptionComponent) == 0x000008, "Wrong alignment on UHDAIPerceptionComponent");
//(sizeof(UHDAIPerceptionComponent) == 0x0000F0, "Wrong size on UHDAIPerceptionComponent");
//(offsetof(UHDAIPerceptionComponent, OwnerPlayer) == 0x0000B0, "Member 'UHDAIPerceptionComponent::OwnerPlayer' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, ObserverSightRadius) == 0x0000BC, "Member 'UHDAIPerceptionComponent::ObserverSightRadius' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, ObserverLoseSightRadius) == 0x0000C0, "Member 'UHDAIPerceptionComponent::ObserverLoseSightRadius' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, DistanceToObserverRangeFar) == 0x0000C4, "Member 'UHDAIPerceptionComponent::DistanceToObserverRangeFar' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, DistanceToObserverRangeNear) == 0x0000C8, "Member 'UHDAIPerceptionComponent::DistanceToObserverRangeNear' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, ShoulderLocationFactor) == 0x0000D0, "Member 'UHDAIPerceptionComponent::ShoulderLocationFactor' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, RangeFactorWeight) == 0x0000D4, "Member 'UHDAIPerceptionComponent::RangeFactorWeight' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, StanceFactorWeight) == 0x0000D8, "Member 'UHDAIPerceptionComponent::StanceFactorWeight' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, MovementFactorWeight) == 0x0000DC, "Member 'UHDAIPerceptionComponent::MovementFactorWeight' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, StanceFactorMaxValue) == 0x0000E0, "Member 'UHDAIPerceptionComponent::StanceFactorMaxValue' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, StanceFactorMinValue) == 0x0000E4, "Member 'UHDAIPerceptionComponent::StanceFactorMinValue' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, OwnerMaxMovementSpeed) == 0x0000E8, "Member 'UHDAIPerceptionComponent::OwnerMaxMovementSpeed' has a wrong offset!");
//(offsetof(UHDAIPerceptionComponent, OwnerDefaultHalfHeight) == 0x0000EC, "Member 'UHDAIPerceptionComponent::OwnerDefaultHalfHeight' has a wrong offset!");

// Class HDMain.HDAIVocalHandler
// 0x00C8 (0x0118 - 0x0050)
class UHDAIVocalHandler final  : public UHDAIHandlerBase
{
public:
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnableVocalization : 1;                           // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11A6[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAICharacterVocalProfile               CurrentProfile;                                    // 0x0060(0x0068)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	uint8                                         bEnableTimeLimitNotify : 1;                        // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFactionOnlyTimeLimit : 1;                         // 0x00C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11A7[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeLimitNotifyRange;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchMultiplier;                                // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchMultiplier;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnySoundTimeLimit;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactTimeLimit;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LostContactTimeLimit;                              // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadingTimeLimit;                                // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeenHitTimeLimit;                                  // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderSuppressionTimeLimit;                         // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathTimeLimit;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextAnySoundTime;                                  // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextContactTime;                                   // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextLostContactTime;                               // 0x0100(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextReloadingTime;                                 // 0x0104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextBeenHitTime;                                   // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextUnderSuppressionTime;                          // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextDeathTime;                                     // 0x0110(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A8[0x4];                                     // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifySurroundingCharacters(EHDAIVocalizationType InVocalType);
	void PlayVocalSound(EHDAIVocalizationType InVocalType);
	void RandomizePitchMultiplier();
	void SetPitchMultiplier(float InPitchMultiplier);
	void SetTimeLimit(EHDAIVocalizationType InVocalType);
	void Vocalize(EHDAIVocalizationType InVocalType);
	void VocalizeBeenHit();
	void VocalizeContact(bool bHasContact);
	void VocalizeReload();
	void VocalizeSuppression();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAIVocalHandler">();
	}
	static class UHDAIVocalHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAIVocalHandler>();
	}
};
//(alignof(UHDAIVocalHandler) == 0x000008, "Wrong alignment on UHDAIVocalHandler");
//(sizeof(UHDAIVocalHandler) == 0x000118, "Wrong size on UHDAIVocalHandler");
//(offsetof(UHDAIVocalHandler, CombatHandler) == 0x000050, "Member 'UHDAIVocalHandler::CombatHandler' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, CurrentProfile) == 0x000060, "Member 'UHDAIVocalHandler::CurrentProfile' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, TimeLimitNotifyRange) == 0x0000CC, "Member 'UHDAIVocalHandler::TimeLimitNotifyRange' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, PitchMultiplier) == 0x0000D0, "Member 'UHDAIVocalHandler::PitchMultiplier' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, MinPitchMultiplier) == 0x0000D4, "Member 'UHDAIVocalHandler::MinPitchMultiplier' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, MaxPitchMultiplier) == 0x0000D8, "Member 'UHDAIVocalHandler::MaxPitchMultiplier' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, AnySoundTimeLimit) == 0x0000DC, "Member 'UHDAIVocalHandler::AnySoundTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, ContactTimeLimit) == 0x0000E0, "Member 'UHDAIVocalHandler::ContactTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, LostContactTimeLimit) == 0x0000E4, "Member 'UHDAIVocalHandler::LostContactTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, ReloadingTimeLimit) == 0x0000E8, "Member 'UHDAIVocalHandler::ReloadingTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, BeenHitTimeLimit) == 0x0000EC, "Member 'UHDAIVocalHandler::BeenHitTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, UnderSuppressionTimeLimit) == 0x0000F0, "Member 'UHDAIVocalHandler::UnderSuppressionTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, DeathTimeLimit) == 0x0000F4, "Member 'UHDAIVocalHandler::DeathTimeLimit' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextAnySoundTime) == 0x0000F8, "Member 'UHDAIVocalHandler::NextAnySoundTime' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextContactTime) == 0x0000FC, "Member 'UHDAIVocalHandler::NextContactTime' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextLostContactTime) == 0x000100, "Member 'UHDAIVocalHandler::NextLostContactTime' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextReloadingTime) == 0x000104, "Member 'UHDAIVocalHandler::NextReloadingTime' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextBeenHitTime) == 0x000108, "Member 'UHDAIVocalHandler::NextBeenHitTime' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextUnderSuppressionTime) == 0x00010C, "Member 'UHDAIVocalHandler::NextUnderSuppressionTime' has a wrong offset!");
//(offsetof(UHDAIVocalHandler, NextDeathTime) == 0x000110, "Member 'UHDAIVocalHandler::NextDeathTime' has a wrong offset!");

// Class HDMain.HDAssetManager
// 0x0000 (0x0440 - 0x0440)
class UHDAssetManager final  : public UDFAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDAssetManager">();
	}
	static class UHDAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDAssetManager>();
	}
};
//(alignof(UHDAssetManager) == 0x000008, "Wrong alignment on UHDAssetManager");
//(sizeof(UHDAssetManager) == 0x000440, "Wrong size on UHDAssetManager");

// Class HDMain.HDBaseCapturePoint
// 0x0130 (0x0350 - 0x0220)
class AHDBaseCapturePoint : public AActor
{
public:
	uint8                                         Pad_11A9[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereCollision;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDFPOIComponent*                        POI;                                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavigationInvokerComponent*            NavigationInvoker;                                 // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bActive : 1;                                       // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLocked : 1;                                       // 0x0248(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bContested : 1;                                    // 0x0248(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCaptured : 1;                                     // 0x0248(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCapturedOnce : 1;                                 // 0x0248(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11AA[0x3];                                     // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CaptureProgress;                                   // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActiveRoute;                                       // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AB[0xC];                                     // 0x0254(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UChildActorComponent*>           SpawnPoints;                                       // 0x0260(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnCaptureProgressUpdated;                          // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHDTeam                                       StartingTeam;                                      // 0x0280(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AC[0x7];                                     // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CaptureDisplayName;                                // 0x0288(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	float                                         CaptureTimerRate;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CaptureSpeed;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CaptureRadius;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinPlayersToCapture;                               // 0x02AC(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bEnforceMinPlayersToCaptureWithSmallerPlayerCount : 1; // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, Config, DisableEditOnInstance, GlobalConfig, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bScaleCaptureSpeed : 1;                            // 0x02B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRecapturable : 1;                                 // 0x02B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWinOnCapture : 1;                                 // 0x02B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProvideSpawnPoint : 1;                            // 0x02B0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProvideSpawnPointWhenUnderAttack : 1;             // 0x02B0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11AD[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   PossibleRoutes;                                    // 0x02B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         Tier;                                              // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AE[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     SpawnPointTransforms;                              // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHDTeam                                       OwningTeam;                                        // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHDTeam                                       PrevNonNeutralOwningTeam;                          // 0x0321(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AF[0x6];                                     // 0x0322(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnOwningTeamUpdate;                                // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bCapturableByTeamRed : 1;                          // 0x0338(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCapturableByTeamBlue : 1;                         // 0x0338(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_11B0[0x7];                                     // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTeamCaptureStatusUpdate;                         // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class AActor* ChoosePlayerStart(class AHDPlayerController* Player);
	void Lock();
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnOwningTeamUpdated(EHDTeam LastOwningTeam);
	void OnRep_Active();
	void OnRep_CapturableByTeam();
	void OnRep_CaptureProgress();
	void OnRep_Contested();
	void OnRep_Locked();
	void OnRep_OwningTeam(EHDTeam LastOwningTeam);
	void ReceiveOnActive(bool bNewActive);
	void ReceiveOnCaptureProgress(bool bNewContested);
	void ReceiveOnLocked(bool bNewLocked);
	void ReceiveOnOwningTeamUpdated(EHDTeam LastOwningTeam);
	void ReceiveOnTeamCaptureStatusUpdated();
	void SetActive(bool bNewActive);
	void SetActiveRoute(int32 NewActiveRoute);
	void Unlock();

	bool CanCapture() const;
	bool CanRestartPlayer(class AController* Player) const;
	int32 GetMinPlayersRequiredForCaptureTeam(EHDTeam CaptureTeam) const;
	EHDControlPointObjectiveType GetObjectiveTypeForTeam(EHDTeam ObjTeam) const;
	void GetOverlappingCharactersByTeam(TArray<class ADFBaseCharacter*>* OverlappingCharsRed, TArray<class ADFBaseCharacter*>* OverlappingCharsBlue) const;
	bool IsCapturableByTeam(EHDTeam CaptureTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDBaseCapturePoint">();
	}
	static class AHDBaseCapturePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDBaseCapturePoint>();
	}
};
//(alignof(AHDBaseCapturePoint) == 0x000008, "Wrong alignment on AHDBaseCapturePoint");
//(sizeof(AHDBaseCapturePoint) == 0x000350, "Wrong size on AHDBaseCapturePoint");
//(offsetof(AHDBaseCapturePoint, Mesh) == 0x000228, "Member 'AHDBaseCapturePoint::Mesh' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, SphereCollision) == 0x000230, "Member 'AHDBaseCapturePoint::SphereCollision' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, POI) == 0x000238, "Member 'AHDBaseCapturePoint::POI' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, NavigationInvoker) == 0x000240, "Member 'AHDBaseCapturePoint::NavigationInvoker' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, CaptureProgress) == 0x00024C, "Member 'AHDBaseCapturePoint::CaptureProgress' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, ActiveRoute) == 0x000250, "Member 'AHDBaseCapturePoint::ActiveRoute' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, SpawnPoints) == 0x000260, "Member 'AHDBaseCapturePoint::SpawnPoints' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, OnCaptureProgressUpdated) == 0x000270, "Member 'AHDBaseCapturePoint::OnCaptureProgressUpdated' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, StartingTeam) == 0x000280, "Member 'AHDBaseCapturePoint::StartingTeam' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, CaptureDisplayName) == 0x000288, "Member 'AHDBaseCapturePoint::CaptureDisplayName' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, CaptureTimerRate) == 0x0002A0, "Member 'AHDBaseCapturePoint::CaptureTimerRate' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, CaptureSpeed) == 0x0002A4, "Member 'AHDBaseCapturePoint::CaptureSpeed' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, CaptureRadius) == 0x0002A8, "Member 'AHDBaseCapturePoint::CaptureRadius' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, MinPlayersToCapture) == 0x0002AC, "Member 'AHDBaseCapturePoint::MinPlayersToCapture' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, PossibleRoutes) == 0x0002B8, "Member 'AHDBaseCapturePoint::PossibleRoutes' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, Tier) == 0x000308, "Member 'AHDBaseCapturePoint::Tier' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, SpawnPointTransforms) == 0x000310, "Member 'AHDBaseCapturePoint::SpawnPointTransforms' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, OwningTeam) == 0x000320, "Member 'AHDBaseCapturePoint::OwningTeam' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, PrevNonNeutralOwningTeam) == 0x000321, "Member 'AHDBaseCapturePoint::PrevNonNeutralOwningTeam' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, OnOwningTeamUpdate) == 0x000328, "Member 'AHDBaseCapturePoint::OnOwningTeamUpdate' has a wrong offset!");
//(offsetof(AHDBaseCapturePoint, OnTeamCaptureStatusUpdate) == 0x000340, "Member 'AHDBaseCapturePoint::OnTeamCaptureStatusUpdate' has a wrong offset!");

// Class HDMain.HDBaseGameMode
// 0x0090 (0x04A8 - 0x0418)
class AHDBaseGameMode : public ADFBaseGameMode
{
public:
	TSubclassOf<class UHDScoreboardBase>          ScoreboardMenuClass;                               // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHDGameRoundEndEventDetails            RoundEndEventDetails;                              // 0x0420(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bDisablePlayerSpawnKitRestrictions : 1;            // 0x0430(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTickets : 1;                                   // 0x0430(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11B5[0x7];                                     // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDTeamDefinition*                      DefaultBluforTeamDefinition;                       // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDTeamDefinition*                      DefaultOpforTeamDefinition;                        // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDTeamDefinition*                      BluforTeamDefinition;                              // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDTeamDefinition*                      OpforTeamDefinition;                               // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRandomPlayerTeamBalance : 1;                      // 0x0458(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Config, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11B6[0x37];                                    // 0x0459(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHDPlatoonInfo*>                 PlatoonInfos;                                      // 0x0490(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AHDPlatoonState>            PlatoonStateClass;                                 // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddBluforBots(int32 Num);
	void AddOpforBots(int32 Num);
	bool PlayerCanRestartAtPlayerStart(class AController* Player, class AActor* StartSpot, class UDFLoadout* StartLoadout);
	void RemoveBluforBots(int32 Num);
	void RemoveOpforBots(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDBaseGameMode">();
	}
	static class AHDBaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDBaseGameMode>();
	}
};
//(alignof(AHDBaseGameMode) == 0x000008, "Wrong alignment on AHDBaseGameMode");
//(sizeof(AHDBaseGameMode) == 0x0004A8, "Wrong size on AHDBaseGameMode");
//(offsetof(AHDBaseGameMode, ScoreboardMenuClass) == 0x000418, "Member 'AHDBaseGameMode::ScoreboardMenuClass' has a wrong offset!");
//(offsetof(AHDBaseGameMode, RoundEndEventDetails) == 0x000420, "Member 'AHDBaseGameMode::RoundEndEventDetails' has a wrong offset!");
//(offsetof(AHDBaseGameMode, DefaultBluforTeamDefinition) == 0x000438, "Member 'AHDBaseGameMode::DefaultBluforTeamDefinition' has a wrong offset!");
//(offsetof(AHDBaseGameMode, DefaultOpforTeamDefinition) == 0x000440, "Member 'AHDBaseGameMode::DefaultOpforTeamDefinition' has a wrong offset!");
//(offsetof(AHDBaseGameMode, BluforTeamDefinition) == 0x000448, "Member 'AHDBaseGameMode::BluforTeamDefinition' has a wrong offset!");
//(offsetof(AHDBaseGameMode, OpforTeamDefinition) == 0x000450, "Member 'AHDBaseGameMode::OpforTeamDefinition' has a wrong offset!");
//(offsetof(AHDBaseGameMode, PlatoonInfos) == 0x000490, "Member 'AHDBaseGameMode::PlatoonInfos' has a wrong offset!");
//(offsetof(AHDBaseGameMode, PlatoonStateClass) == 0x0004A0, "Member 'AHDBaseGameMode::PlatoonStateClass' has a wrong offset!");

// Class HDMain.HDBasePickup_Kit
// 0x0020 (0x0278 - 0x0258)
class AHDBasePickup_Kit : public ADFBasePickup
{
public:
	class UDFInventoryComponent*                  Inventory;                                         // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPrimitiveComponent*>            KitVisuals;                                        // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDKit*                                 KitLoadout;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDBasePickup_Kit">();
	}
	static class AHDBasePickup_Kit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDBasePickup_Kit>();
	}
};
//(alignof(AHDBasePickup_Kit) == 0x000008, "Wrong alignment on AHDBasePickup_Kit");
//(sizeof(AHDBasePickup_Kit) == 0x000278, "Wrong size on AHDBasePickup_Kit");
//(offsetof(AHDBasePickup_Kit, Inventory) == 0x000258, "Member 'AHDBasePickup_Kit::Inventory' has a wrong offset!");
//(offsetof(AHDBasePickup_Kit, KitVisuals) == 0x000260, "Member 'AHDBasePickup_Kit::KitVisuals' has a wrong offset!");
//(offsetof(AHDBasePickup_Kit, KitLoadout) == 0x000270, "Member 'AHDBasePickup_Kit::KitLoadout' has a wrong offset!");

// Class HDMain.HDBaseWeapon
// 0x0018 (0x0870 - 0x0858)
class AHDBaseWeapon : public ADFBaseGun_Projectile
{
public:
	class UTexture2D*                             DisplayIcon;                                       // 0x0858(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             DisplayEquipmentSymbol;                            // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bUseFreeAim : 1;                                   // 0x0868(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bSelectable : 1;                                   // 0x0868(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bHideFireModeIndicator : 1;                        // 0x0868(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11B8[0x3];                                     // 0x0869(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmmoReplenishmentDelay;                            // 0x086C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsSelectableEquipment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDBaseWeapon">();
	}
	static class AHDBaseWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDBaseWeapon>();
	}
};
//(alignof(AHDBaseWeapon) == 0x000008, "Wrong alignment on AHDBaseWeapon");
//(sizeof(AHDBaseWeapon) == 0x000870, "Wrong size on AHDBaseWeapon");
//(offsetof(AHDBaseWeapon, DisplayIcon) == 0x000858, "Member 'AHDBaseWeapon::DisplayIcon' has a wrong offset!");
//(offsetof(AHDBaseWeapon, DisplayEquipmentSymbol) == 0x000860, "Member 'AHDBaseWeapon::DisplayEquipmentSymbol' has a wrong offset!");
//(offsetof(AHDBaseWeapon, AmmoReplenishmentDelay) == 0x00086C, "Member 'AHDBaseWeapon::AmmoReplenishmentDelay' has a wrong offset!");

// Class HDMain.HDButtonBase
// 0x0038 (0x0268 - 0x0230)
class UHDButtonBase : public UUserWidget
{
public:
	class FText                                   ButtonText;                                        // 0x0230(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class UButton*                                Button;                                            // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B9[0x18];                                    // 0x0250(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleButtonClicked();
	void SetButtonText(class FText& InText);
	void UpdateButtonText(class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDButtonBase">();
	}
	static class UHDButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDButtonBase>();
	}
};
//(alignof(UHDButtonBase) == 0x000008, "Wrong alignment on UHDButtonBase");
//(sizeof(UHDButtonBase) == 0x000268, "Wrong size on UHDButtonBase");
//(offsetof(UHDButtonBase, ButtonText) == 0x000230, "Member 'UHDButtonBase::ButtonText' has a wrong offset!");
//(offsetof(UHDButtonBase, Button) == 0x000248, "Member 'UHDButtonBase::Button' has a wrong offset!");

// Class HDMain.HDPlayerController
// 0x00A8 (0x06A0 - 0x05F8)
class AHDPlayerController : public ADFBasePlayerController
{
public:
	class AHDPlayerCharacter*                     HDCharacter;                                       // 0x05F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDPlayerComponent*                     PlayerComponent;                                   // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FPTTKeyState>        PushToTalkKeyStates;                               // 0x0608(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11BA[0x4];                                     // 0x0658(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TextCommsFormatName;                               // 0x065C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TeamLocalVoipCommChannelGroupName;                 // 0x0664(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SquadVoipCommChannelGroupName;                     // 0x066C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CommandVoipCommChannelGroupName;                   // 0x0674(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11BB[0x4];                                     // 0x067C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDFPlayerCommsComponent*                CachedPlayerCommsComp;                             // 0x0680(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UVictoryMenu>               VictoryMenuClass;                                  // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVictoryMenu*                           VictoryMenu;                                       // 0x0690(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11BC[0x8];                                     // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Auth_SpawnVehicle();
	bool CanTalkOverChannel(class FName TalkChannelName);
	void ClientCheatSetAllowIdleSway(bool bIdleSwayDisallowed);
	void ClientLoadTeamData(TArray<class FString>& FactionAssetPaths);
	void ClientRoundEnd(struct FHDGameRoundEndEventDetails& RoundDetails, bool bIsWinner);
	class UDFPlayerCommsComponent* GetPlayerCommsComponent();
	class UDFCommChannel* GetTalkChannel();
	bool IsTalkingOverChannel(class UDFCommChannel* TalkChannel);
	bool IsTalkingOverChannelGroup(class FName TalkGroupName);
	bool IsTalkingOverChannelName(class FName TalkChannelName);
	void LoadVictoryMenu(struct FHDGameRoundEndEventDetails& RoundDetails, bool bWinner);
	void OnPauseMenu();
	void OnPlayerSpawnTimerElapsed();
	void OnShowScoreboardPressed();
	void OnShowScoreboardReleased();
	void ReceiveVoipTalkerMsgReceived(class UDFCommChannel* MsgTalkerChannel, class APlayerState* MsgTalkerPS, bool bMsgIsTalking);
	void ServerCheatSetAllowIdleSway(bool bIdleSwayDisallowed);
	void ServerPickTeam(EHDTeam DesiredTeam);
	void ServerRestartPlayerAtStartSpot(class AActor* DesiredStartSpot, class UDFLoadout* DesiredStartLoadout);
	void ServerSpawnVehicle();
	void ServerSwitchTeam();
	void StartTalkingOverChannel(class FName TalkStartChannelName);
	void StartTalkingOverChannelGroup(class FName TalkStartGroupName);
	void StopTalkingOnActiveChannels();
	void StopTalkingOverChannelGroupIfActive(class FName TalkStopGroupName);
	void StopTalkingOverChannelIfActive(class FName TalkStopChannelName);
	void Talk();
	void TeamTalk();
	void UnloadVictoryMenu();

	bool IsIdleSwayAllowed() const;
	bool IsInVehicle() const;
	bool IsTalking(bool bIncludeWantsToTalk) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerController">();
	}
	static class AHDPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDPlayerController>();
	}
};
//(alignof(AHDPlayerController) == 0x000008, "Wrong alignment on AHDPlayerController");
//(sizeof(AHDPlayerController) == 0x0006A0, "Wrong size on AHDPlayerController");
//(offsetof(AHDPlayerController, HDCharacter) == 0x0005F8, "Member 'AHDPlayerController::HDCharacter' has a wrong offset!");
//(offsetof(AHDPlayerController, PlayerComponent) == 0x000600, "Member 'AHDPlayerController::PlayerComponent' has a wrong offset!");
//(offsetof(AHDPlayerController, PushToTalkKeyStates) == 0x000608, "Member 'AHDPlayerController::PushToTalkKeyStates' has a wrong offset!");
//(offsetof(AHDPlayerController, TextCommsFormatName) == 0x00065C, "Member 'AHDPlayerController::TextCommsFormatName' has a wrong offset!");
//(offsetof(AHDPlayerController, TeamLocalVoipCommChannelGroupName) == 0x000664, "Member 'AHDPlayerController::TeamLocalVoipCommChannelGroupName' has a wrong offset!");
//(offsetof(AHDPlayerController, SquadVoipCommChannelGroupName) == 0x00066C, "Member 'AHDPlayerController::SquadVoipCommChannelGroupName' has a wrong offset!");
//(offsetof(AHDPlayerController, CommandVoipCommChannelGroupName) == 0x000674, "Member 'AHDPlayerController::CommandVoipCommChannelGroupName' has a wrong offset!");
//(offsetof(AHDPlayerController, CachedPlayerCommsComp) == 0x000680, "Member 'AHDPlayerController::CachedPlayerCommsComp' has a wrong offset!");
//(offsetof(AHDPlayerController, VictoryMenuClass) == 0x000688, "Member 'AHDPlayerController::VictoryMenuClass' has a wrong offset!");
//(offsetof(AHDPlayerController, VictoryMenu) == 0x000690, "Member 'AHDPlayerController::VictoryMenu' has a wrong offset!");

// Class HDMain.HDCheatManager
// 0x0008 (0x0080 - 0x0078)
class UHDCheatManager final  : public UDFCheatManager
{
public:
	uint8                                         Pad_11C4[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFreeAimDeadzoneCameraSpeedFactor(float NewSpeedFactor);
	void SetFreeAimReturnToCenterInterpSpeed(float NewInterpSpeed);
	void SetMaxFreeAimPitch(float NewPitch);
	void SetMaxFreeAimPitchADS(float NewPitch);
	void SetMaxFreeAimYaw(float NewYaw);
	void SetMaxFreeAimYawADS(float NewYaw);
	void SpawnVehicle();
	void ToggleFreeAim();
	void ToggleFreeAimADS();
	void ToggleIdleSway();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDCheatManager">();
	}
	static class UHDCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDCheatManager>();
	}
};
//(alignof(UHDCheatManager) == 0x000008, "Wrong alignment on UHDCheatManager");
//(sizeof(UHDCheatManager) == 0x000080, "Wrong size on UHDCheatManager");

// Class HDMain.HDConfirmationDialog
// 0x0018 (0x0250 - 0x0238)
class UHDConfirmationDialog : public UDFGameDialog
{
public:
	uint8                                         Pad_11C5[0x10];                                    // 0x0238(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicEntryBox*                       ButtonsEntryBox;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateDialogText(class FText& TitleText, class FText& DescriptionText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDConfirmationDialog">();
	}
	static class UHDConfirmationDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDConfirmationDialog>();
	}
};
//(alignof(UHDConfirmationDialog) == 0x000008, "Wrong alignment on UHDConfirmationDialog");
//(sizeof(UHDConfirmationDialog) == 0x000250, "Wrong size on UHDConfirmationDialog");
//(offsetof(UHDConfirmationDialog, ButtonsEntryBox) == 0x000248, "Member 'UHDConfirmationDialog::ButtonsEntryBox' has a wrong offset!");

// Class HDMain.HDFactionInfo
// 0x0050 (0x00E0 - 0x0090)
class UHDFactionInfo : public UDFFactionInfo
{
public:
	TSet<TSoftObjectPtr<class UHDKit>>            Kits;                                              // 0x0090(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDFactionInfo">();
	}
	static class UHDFactionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDFactionInfo>();
	}
};
//(alignof(UHDFactionInfo) == 0x000008, "Wrong alignment on UHDFactionInfo");
//(sizeof(UHDFactionInfo) == 0x0000E0, "Wrong size on UHDFactionInfo");
//(offsetof(UHDFactionInfo, Kits) == 0x000090, "Member 'UHDFactionInfo::Kits' has a wrong offset!");

// Class HDMain.HDGame_AdvanceAndSecure
// 0x0038 (0x04E0 - 0x04A8)
class AHDGame_AdvanceAndSecure : public AHDBaseGameMode
{
public:
	int32                                         StartingBlueTier;                                  // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingRedTier;                                   // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveRoute;                                       // 0x04B0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentBlueCaptureTier;                            // 0x04B4(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentRedCaptureTier;                             // 0x04B8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBlueIncreasesTier : 1;                            // 0x04BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11C6[0x23];                                    // 0x04BD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentBlueCaptureTier() const;
	int32 GetCurrentRedCaptureTier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGame_AdvanceAndSecure">();
	}
	static class AHDGame_AdvanceAndSecure* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDGame_AdvanceAndSecure>();
	}
};
//(alignof(AHDGame_AdvanceAndSecure) == 0x000008, "Wrong alignment on AHDGame_AdvanceAndSecure");
//(sizeof(AHDGame_AdvanceAndSecure) == 0x0004E0, "Wrong size on AHDGame_AdvanceAndSecure");
//(offsetof(AHDGame_AdvanceAndSecure, StartingBlueTier) == 0x0004A8, "Member 'AHDGame_AdvanceAndSecure::StartingBlueTier' has a wrong offset!");
//(offsetof(AHDGame_AdvanceAndSecure, StartingRedTier) == 0x0004AC, "Member 'AHDGame_AdvanceAndSecure::StartingRedTier' has a wrong offset!");
//(offsetof(AHDGame_AdvanceAndSecure, ActiveRoute) == 0x0004B0, "Member 'AHDGame_AdvanceAndSecure::ActiveRoute' has a wrong offset!");
//(offsetof(AHDGame_AdvanceAndSecure, CurrentBlueCaptureTier) == 0x0004B4, "Member 'AHDGame_AdvanceAndSecure::CurrentBlueCaptureTier' has a wrong offset!");
//(offsetof(AHDGame_AdvanceAndSecure, CurrentRedCaptureTier) == 0x0004B8, "Member 'AHDGame_AdvanceAndSecure::CurrentRedCaptureTier' has a wrong offset!");

// Class HDMain.HDGame_TeamDeathMatch
// 0x0000 (0x04A8 - 0x04A8)
class AHDGame_TeamDeathMatch final  : public AHDBaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGame_TeamDeathMatch">();
	}
	static class AHDGame_TeamDeathMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDGame_TeamDeathMatch>();
	}
};
//(alignof(AHDGame_TeamDeathMatch) == 0x000008, "Wrong alignment on AHDGame_TeamDeathMatch");
//(sizeof(AHDGame_TeamDeathMatch) == 0x0004A8, "Wrong size on AHDGame_TeamDeathMatch");

// Class HDMain.HDGameEngine
// 0x0000 (0x0E30 - 0x0E30)
class UHDGameEngine final  : public UDFGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameEngine">();
	}
	static class UHDGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGameEngine>();
	}
};
//(alignof(UHDGameEngine) == 0x000008, "Wrong alignment on UHDGameEngine");
//(sizeof(UHDGameEngine) == 0x000E30, "Wrong size on UHDGameEngine");

// Class HDMain.HDGameInstance
// 0x0180 (0x0458 - 0x02D8)
class UHDGameInstance : public UTBGameInstance
{
public:
	class UHDUGCLoadProgressScreen*               UGCLoadProgressScreen;                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDScoreboardBase*                      ScoreboardMenu;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHDUGCLoadProgressScreen>   UGCLoadProgressScreenClassPtr;                     // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   UGCLoadProgressScreenClass;                        // 0x02F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C7[0x140];                                   // 0x0318(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool HasDLCBP(int64 DLCAppID);
	static bool HasModsLoaded();
	static bool OwnsAppBP(int64 AppID);

	void LoadScoreboardMenu();
	void ShowConfirmationDialog(class FText& Title, class FText& Message);
	void ShowErrorDialog(class FText& Title, class FText& Message);
	void UnloadScoreboardMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameInstance">();
	}
	static class UHDGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGameInstance>();
	}
};
//(alignof(UHDGameInstance) == 0x000008, "Wrong alignment on UHDGameInstance");
//(sizeof(UHDGameInstance) == 0x000458, "Wrong size on UHDGameInstance");
//(offsetof(UHDGameInstance, UGCLoadProgressScreen) == 0x0002D8, "Member 'UHDGameInstance::UGCLoadProgressScreen' has a wrong offset!");
//(offsetof(UHDGameInstance, ScoreboardMenu) == 0x0002E0, "Member 'UHDGameInstance::ScoreboardMenu' has a wrong offset!");
//(offsetof(UHDGameInstance, UGCLoadProgressScreenClassPtr) == 0x0002E8, "Member 'UHDGameInstance::UGCLoadProgressScreenClassPtr' has a wrong offset!");
//(offsetof(UHDGameInstance, UGCLoadProgressScreenClass) == 0x0002F0, "Member 'UHDGameInstance::UGCLoadProgressScreenClass' has a wrong offset!");

// Class HDMain.HDGameModeDefinition
// 0x0028 (0x0110 - 0x00E8)
class UHDGameModeDefinition final  : public UDFGameModeDefinition
{
public:
	TSoftClassPtr<class UClass>                   GameModeClass;                                     // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameModeDefinition">();
	}
	static class UHDGameModeDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGameModeDefinition>();
	}
};
//(alignof(UHDGameModeDefinition) == 0x000008, "Wrong alignment on UHDGameModeDefinition");
//(sizeof(UHDGameModeDefinition) == 0x000110, "Wrong size on UHDGameModeDefinition");
//(offsetof(UHDGameModeDefinition, GameModeClass) == 0x0000E8, "Member 'UHDGameModeDefinition::GameModeClass' has a wrong offset!");

// Class HDMain.HDGameModsProjectPolicies
// 0x0000 (0x0030 - 0x0030)
class UHDGameModsProjectPolicies final  : public UHDCoreDefaultUGCProjectPolicies
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameModsProjectPolicies">();
	}
	static class UHDGameModsProjectPolicies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGameModsProjectPolicies>();
	}
};
//(alignof(UHDGameModsProjectPolicies) == 0x000008, "Wrong alignment on UHDGameModsProjectPolicies");
//(sizeof(UHDGameModsProjectPolicies) == 0x000030, "Wrong size on UHDGameModsProjectPolicies");

// Class HDMain.HDGameProjectBuildSettings
// 0x0000 (0x0028 - 0x0028)
class UHDGameProjectBuildSettings final  : public UBlueprintFunctionLibrary
{
public:
	static bool IsDemoBuild();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameProjectBuildSettings">();
	}
	static class UHDGameProjectBuildSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGameProjectBuildSettings>();
	}
};
//(alignof(UHDGameProjectBuildSettings) == 0x000008, "Wrong alignment on UHDGameProjectBuildSettings");
//(sizeof(UHDGameProjectBuildSettings) == 0x000028, "Wrong size on UHDGameProjectBuildSettings");

// Class HDMain.HDGameRulesetBase
// 0x0008 (0x0060 - 0x0058)
class UHDGameRulesetBase : public UDFGameRulesetBase
{
public:
	uint8                                         bUseTickets : 1;                                   // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11CA[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GiveTicketsToTeam(EHDTeam TicketTeam, int32 TicketsToAdd);
	void RevokeTicketsFromTeam(EHDTeam TicketTeam, int32 TicketsToRemove);

	class AHDBaseGameMode* GetHDGameMode() const;
	class AHDGameState* GetHDGameState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameRulesetBase">();
	}
	static class UHDGameRulesetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGameRulesetBase>();
	}
};
//(alignof(UHDGameRulesetBase) == 0x000008, "Wrong alignment on UHDGameRulesetBase");
//(sizeof(UHDGameRulesetBase) == 0x000060, "Wrong size on UHDGameRulesetBase");

// Class HDMain.HDGameSession
// 0x0008 (0x0278 - 0x0270)
class AHDGameSession final  : public ADFGameSession
{
public:
	bool                                          bSupportersOnlyWhitelist;                          // 0x0270(0x0001)(ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11CD[0x7];                                     // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameSession">();
	}
	static class AHDGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDGameSession>();
	}
};
//(alignof(AHDGameSession) == 0x000008, "Wrong alignment on AHDGameSession");
//(sizeof(AHDGameSession) == 0x000278, "Wrong size on AHDGameSession");
//(offsetof(AHDGameSession, bSupportersOnlyWhitelist) == 0x000270, "Member 'AHDGameSession::bSupportersOnlyWhitelist' has a wrong offset!");

// Class HDMain.HDGameState
// 0x0020 (0x0330 - 0x0310)
class AHDGameState : public ADFBaseGameState
{
public:
	float                                         ReplicatedMinRespawnDelay;                         // 0x0310(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bReplicatedDisableSpawnKitRestrictions : 1;        // 0x0314(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_11CE[0x3];                                     // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BluforTickets;                                     // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OpforTickets;                                      // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AHDTeamState*                           BluforTeamState;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AHDTeamState*                           OpforTeamState;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearTickets();
	void GiveTicketsToTeam(EHDTeam TicketTeam, int32 TicketsToAdd);
	void RevokeTicketsFromTeam(EHDTeam TicketTeam, int32 TicketsToRemove);

	int32 GetNumPlayersOnTeam(EHDTeam TeamToCheck) const;
	bool IsGameUsingPlayerSpawnKitRestrictions(class AController* Controller) const;
	bool IsGameUsingTickets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGameState">();
	}
	static class AHDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDGameState>();
	}
};
//(alignof(AHDGameState) == 0x000008, "Wrong alignment on AHDGameState");
//(sizeof(AHDGameState) == 0x000330, "Wrong size on AHDGameState");
//(offsetof(AHDGameState, ReplicatedMinRespawnDelay) == 0x000310, "Member 'AHDGameState::ReplicatedMinRespawnDelay' has a wrong offset!");
//(offsetof(AHDGameState, BluforTickets) == 0x000318, "Member 'AHDGameState::BluforTickets' has a wrong offset!");
//(offsetof(AHDGameState, OpforTickets) == 0x00031C, "Member 'AHDGameState::OpforTickets' has a wrong offset!");
//(offsetof(AHDGameState, BluforTeamState) == 0x000320, "Member 'AHDGameState::BluforTeamState' has a wrong offset!");
//(offsetof(AHDGameState, OpforTeamState) == 0x000328, "Member 'AHDGameState::OpforTeamState' has a wrong offset!");

// Class HDMain.HDGOAPAct_AttackEnemy
// 0x0000 (0x0098 - 0x0098)
class UHDGOAPAct_AttackEnemy final  : public UHDGOAPActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPAct_AttackEnemy">();
	}
	static class UHDGOAPAct_AttackEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPAct_AttackEnemy>();
	}
};
//(alignof(UHDGOAPAct_AttackEnemy) == 0x000008, "Wrong alignment on UHDGOAPAct_AttackEnemy");
//(sizeof(UHDGOAPAct_AttackEnemy) == 0x000098, "Wrong size on UHDGOAPAct_AttackEnemy");

// Class HDMain.HDGOAPAct_CaptureControlPoint
// 0x0000 (0x0098 - 0x0098)
class UHDGOAPAct_CaptureControlPoint final  : public UHDGOAPActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPAct_CaptureControlPoint">();
	}
	static class UHDGOAPAct_CaptureControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPAct_CaptureControlPoint>();
	}
};
//(alignof(UHDGOAPAct_CaptureControlPoint) == 0x000008, "Wrong alignment on UHDGOAPAct_CaptureControlPoint");
//(sizeof(UHDGOAPAct_CaptureControlPoint) == 0x000098, "Wrong size on UHDGOAPAct_CaptureControlPoint");

// Class HDMain.HDGOAPAct_DefendControlPoint
// 0x0000 (0x0098 - 0x0098)
class UHDGOAPAct_DefendControlPoint final  : public UHDGOAPActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPAct_DefendControlPoint">();
	}
	static class UHDGOAPAct_DefendControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPAct_DefendControlPoint>();
	}
};
//(alignof(UHDGOAPAct_DefendControlPoint) == 0x000008, "Wrong alignment on UHDGOAPAct_DefendControlPoint");
//(sizeof(UHDGOAPAct_DefendControlPoint) == 0x000098, "Wrong size on UHDGOAPAct_DefendControlPoint");

// Class HDMain.HDGOAPAct_MoveToDesiredLocation
// 0x0000 (0x0098 - 0x0098)
class UHDGOAPAct_MoveToDesiredLocation final  : public UHDGOAPActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPAct_MoveToDesiredLocation">();
	}
	static class UHDGOAPAct_MoveToDesiredLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPAct_MoveToDesiredLocation>();
	}
};
//(alignof(UHDGOAPAct_MoveToDesiredLocation) == 0x000008, "Wrong alignment on UHDGOAPAct_MoveToDesiredLocation");
//(sizeof(UHDGOAPAct_MoveToDesiredLocation) == 0x000098, "Wrong size on UHDGOAPAct_MoveToDesiredLocation");

// Class HDMain.HDGOAPComponent
// 0x0070 (0x01D8 - 0x0168)
class UHDGOAPComponent final  : public UGOAPComponent
{
public:
	class AHDAIController*                        HDAIOwner;                                         // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlayerCharacter*                     HDAICharOwner;                                     // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UHDAIHandlerBase*>               AIHandlers;                                        // 0x0178(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAINavigationHandler*                 NavigationHandler;                                 // 0x0188(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICaptureHandler*                    CaptureHandler;                                    // 0x0190(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAICombatHandler*                     CombatHandler;                                     // 0x0198(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIBehaviorHandler*                   BehaviorHandler;                                   // 0x01A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIGroupBehaviorHandler*              GroupBehaviorHandler;                              // 0x01A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIAimingHandler*                     AimingHandler;                                     // 0x01B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDAIVocalHandler*                      VocalHandler;                                      // 0x01B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D3[0x10];                                    // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecisionFrequency;                                 // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D4[0x4];                                     // 0x01D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetPlanningTimer();
	void TargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);

	class UHDAIHandlerBase* GetAIHandler(TSubclassOf<class UHDAIHandlerBase> HandlerClass) const;
	bool IsAIActive() const;
	bool IsAIActiveInWorld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPComponent">();
	}
	static class UHDGOAPComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPComponent>();
	}
};
//(alignof(UHDGOAPComponent) == 0x000008, "Wrong alignment on UHDGOAPComponent");
//(sizeof(UHDGOAPComponent) == 0x0001D8, "Wrong size on UHDGOAPComponent");
//(offsetof(UHDGOAPComponent, HDAIOwner) == 0x000168, "Member 'UHDGOAPComponent::HDAIOwner' has a wrong offset!");
//(offsetof(UHDGOAPComponent, HDAICharOwner) == 0x000170, "Member 'UHDGOAPComponent::HDAICharOwner' has a wrong offset!");
//(offsetof(UHDGOAPComponent, AIHandlers) == 0x000178, "Member 'UHDGOAPComponent::AIHandlers' has a wrong offset!");
//(offsetof(UHDGOAPComponent, NavigationHandler) == 0x000188, "Member 'UHDGOAPComponent::NavigationHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, CaptureHandler) == 0x000190, "Member 'UHDGOAPComponent::CaptureHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, CombatHandler) == 0x000198, "Member 'UHDGOAPComponent::CombatHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, BehaviorHandler) == 0x0001A0, "Member 'UHDGOAPComponent::BehaviorHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, GroupBehaviorHandler) == 0x0001A8, "Member 'UHDGOAPComponent::GroupBehaviorHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, AimingHandler) == 0x0001B0, "Member 'UHDGOAPComponent::AimingHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, VocalHandler) == 0x0001B8, "Member 'UHDGOAPComponent::VocalHandler' has a wrong offset!");
//(offsetof(UHDGOAPComponent, DecisionFrequency) == 0x0001D0, "Member 'UHDGOAPComponent::DecisionFrequency' has a wrong offset!");

// Class HDMain.HDGOAPGoal_CaptureControlPoint
// 0x0010 (0x0078 - 0x0068)
class UHDGOAPGoal_CaptureControlPoint final  : public UHDGOAPGoalBase
{
public:
	class AHDBaseCapturePoint*                    CPToCaptureCurrent;                                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDBaseCapturePoint*                    CPToCapturePending;                                // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDGOAPGoal_CaptureControlPoint">();
	}
	static class UHDGOAPGoal_CaptureControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDGOAPGoal_CaptureControlPoint>();
	}
};
//(alignof(UHDGOAPGoal_CaptureControlPoint) == 0x000008, "Wrong alignment on UHDGOAPGoal_CaptureControlPoint");
//(sizeof(UHDGOAPGoal_CaptureControlPoint) == 0x000078, "Wrong size on UHDGOAPGoal_CaptureControlPoint");
//(offsetof(UHDGOAPGoal_CaptureControlPoint, CPToCaptureCurrent) == 0x000068, "Member 'UHDGOAPGoal_CaptureControlPoint::CPToCaptureCurrent' has a wrong offset!");
//(offsetof(UHDGOAPGoal_CaptureControlPoint, CPToCapturePending) == 0x000070, "Member 'UHDGOAPGoal_CaptureControlPoint::CPToCapturePending' has a wrong offset!");

// Class HDMain.HDHUD
// 0x0000 (0x0310 - 0x0310)
class AHDHUD : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDHUD">();
	}
	static class AHDHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDHUD>();
	}
};
//(alignof(AHDHUD) == 0x000008, "Wrong alignment on AHDHUD");
//(sizeof(AHDHUD) == 0x000310, "Wrong size on AHDHUD");

// Class HDMain.HDJoinGameMenu
// 0x0048 (0x0280 - 0x0238)
class UHDJoinGameMenu : public UDFBaseMenu
{
public:
	class UHDServerListView*                      ServerList;                                        // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                MapIds;                                            // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D6[0x30];                                    // 0x0250(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JoinGame(class UHDServerListItemData* ServerItem, const class FString& JoinPassword);
	void OnRefresh(bool bSortAscending, EHDServerListSortBy SortBy);
	void ReceiveOnRefreshComplete(bool bSortAscending, EHDServerListSortBy SortBy);
	void ReceiveOnRefreshStart();

	bool IsUsingDebugServerListings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDJoinGameMenu">();
	}
	static class UHDJoinGameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDJoinGameMenu>();
	}
};
//(alignof(UHDJoinGameMenu) == 0x000008, "Wrong alignment on UHDJoinGameMenu");
//(sizeof(UHDJoinGameMenu) == 0x000280, "Wrong size on UHDJoinGameMenu");
//(offsetof(UHDJoinGameMenu, ServerList) == 0x000238, "Member 'UHDJoinGameMenu::ServerList' has a wrong offset!");
//(offsetof(UHDJoinGameMenu, MapIds) == 0x000240, "Member 'UHDJoinGameMenu::MapIds' has a wrong offset!");

// Class HDMain.HDKit
// 0x0078 (0x00B8 - 0x0040)
class UHDKit final  : public UDFLoadout
{
public:
	TArray<struct FHDItemEntry>                   ItemEntries;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryItemSlotNum;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D7[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHDBasePickup_Kit>          KitDropPrefabClass;                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHDKitPrerequisiteBase*>         KitRequirements;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDataTableRowHandle>            CharacterVariations;                               // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSquadLeaderKit : 1;                               // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAllowsRallyPointDeployment : 1;                   // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11D8[0x17];                                    // 0x0081(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   KitDisplayName;                                    // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             KitDisplaySymbol;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool GetItemEntryDisplayEquipmentSymbol(struct FHDItemEntry& ItemEntry, class UTexture2D** OutDisplayEquipmentSymbol);
	static bool GetItemEntryDisplayIcon(struct FHDItemEntry& ItemEntry, class UTexture2D** OutDisplayIcon);

	bool GetItemEntryBySlotNum(int32 SlotNum, struct FHDItemEntry* OutEntry) const;
	int32 GetNumPlayersUsingKit(class UObject* WorldContextObject) const;
	int32 GetPlayersUsingKit(class UObject* WorldContextObject, TArray<class AHDPlayerState*>* OutPSArray) const;
	bool GetPrimaryItemEntry(struct FHDItemEntry* OutPrimaryEntry) const;
	bool GetPrimaryItemEntryDisplayIcon(class UTexture2D** OutDisplayIcon) const;
	bool HasKitRequirements() const;
	bool PlayerCanStartWithKit(class AController* Player, class FText* OutKitDenialReason) const;
	struct FDFCharacterVariationDataHandle RandomCharacterVariationDataFromKit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKit">();
	}
	static class UHDKit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKit>();
	}
};
//(alignof(UHDKit) == 0x000008, "Wrong alignment on UHDKit");
//(sizeof(UHDKit) == 0x0000B8, "Wrong size on UHDKit");
//(offsetof(UHDKit, ItemEntries) == 0x000040, "Member 'UHDKit::ItemEntries' has a wrong offset!");
//(offsetof(UHDKit, PrimaryItemSlotNum) == 0x000050, "Member 'UHDKit::PrimaryItemSlotNum' has a wrong offset!");
//(offsetof(UHDKit, KitDropPrefabClass) == 0x000058, "Member 'UHDKit::KitDropPrefabClass' has a wrong offset!");
//(offsetof(UHDKit, KitRequirements) == 0x000060, "Member 'UHDKit::KitRequirements' has a wrong offset!");
//(offsetof(UHDKit, CharacterVariations) == 0x000070, "Member 'UHDKit::CharacterVariations' has a wrong offset!");
//(offsetof(UHDKit, KitDisplayName) == 0x000098, "Member 'UHDKit::KitDisplayName' has a wrong offset!");
//(offsetof(UHDKit, KitDisplaySymbol) == 0x0000B0, "Member 'UHDKit::KitDisplaySymbol' has a wrong offset!");

// Class HDMain.HDKitPrerequisiteBase
// 0x0018 (0x0040 - 0x0028)
class UHDKitPrerequisiteBase : public UObject
{
public:
	class FText                                   KitDenialReason;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisiteBase">();
	}
	static class UHDKitPrerequisiteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisiteBase>();
	}
};
//(alignof(UHDKitPrerequisiteBase) == 0x000008, "Wrong alignment on UHDKitPrerequisiteBase");
//(sizeof(UHDKitPrerequisiteBase) == 0x000040, "Wrong size on UHDKitPrerequisiteBase");
//(offsetof(UHDKitPrerequisiteBase, KitDenialReason) == 0x000028, "Member 'UHDKitPrerequisiteBase::KitDenialReason' has a wrong offset!");

// Class HDMain.HDKitPrerequisite_AdminOnly
// 0x0000 (0x0040 - 0x0040)
class UHDKitPrerequisite_AdminOnly final  : public UHDKitPrerequisiteBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_AdminOnly">();
	}
	static class UHDKitPrerequisite_AdminOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_AdminOnly>();
	}
};
//(alignof(UHDKitPrerequisite_AdminOnly) == 0x000008, "Wrong alignment on UHDKitPrerequisite_AdminOnly");
//(sizeof(UHDKitPrerequisite_AdminOnly) == 0x000040, "Wrong size on UHDKitPrerequisite_AdminOnly");

// Class HDMain.HDKitPrerequisite_AlwaysDisable
// 0x0000 (0x0040 - 0x0040)
class UHDKitPrerequisite_AlwaysDisable final  : public UHDKitPrerequisiteBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_AlwaysDisable">();
	}
	static class UHDKitPrerequisite_AlwaysDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_AlwaysDisable>();
	}
};
//(alignof(UHDKitPrerequisite_AlwaysDisable) == 0x000008, "Wrong alignment on UHDKitPrerequisite_AlwaysDisable");
//(sizeof(UHDKitPrerequisite_AlwaysDisable) == 0x000040, "Wrong size on UHDKitPrerequisite_AlwaysDisable");

// Class HDMain.HDKitPrerequisite_MinSquadMembers
// 0x0008 (0x0048 - 0x0040)
class UHDKitPrerequisite_MinSquadMembers final  : public UHDKitPrerequisiteBase
{
public:
	int32                                         MinSquadMembers;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E2[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_MinSquadMembers">();
	}
	static class UHDKitPrerequisite_MinSquadMembers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_MinSquadMembers>();
	}
};
//(alignof(UHDKitPrerequisite_MinSquadMembers) == 0x000008, "Wrong alignment on UHDKitPrerequisite_MinSquadMembers");
//(sizeof(UHDKitPrerequisite_MinSquadMembers) == 0x000048, "Wrong size on UHDKitPrerequisite_MinSquadMembers");
//(offsetof(UHDKitPrerequisite_MinSquadMembers, MinSquadMembers) == 0x000040, "Member 'UHDKitPrerequisite_MinSquadMembers::MinSquadMembers' has a wrong offset!");

// Class HDMain.HDKitPrerequisite_SquadLeaderOnly
// 0x0000 (0x0040 - 0x0040)
class UHDKitPrerequisite_SquadLeaderOnly final  : public UHDKitPrerequisiteBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_SquadLeaderOnly">();
	}
	static class UHDKitPrerequisite_SquadLeaderOnly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_SquadLeaderOnly>();
	}
};
//(alignof(UHDKitPrerequisite_SquadLeaderOnly) == 0x000008, "Wrong alignment on UHDKitPrerequisite_SquadLeaderOnly");
//(sizeof(UHDKitPrerequisite_SquadLeaderOnly) == 0x000040, "Wrong size on UHDKitPrerequisite_SquadLeaderOnly");

// Class HDMain.HDKitPrerequisite_SquadSizeLimit
// 0x0008 (0x0048 - 0x0040)
class UHDKitPrerequisite_SquadSizeLimit final  : public UHDKitPrerequisiteBase
{
public:
	int32                                         MaxSquadCount;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E3[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_SquadSizeLimit">();
	}
	static class UHDKitPrerequisite_SquadSizeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_SquadSizeLimit>();
	}
};
//(alignof(UHDKitPrerequisite_SquadSizeLimit) == 0x000008, "Wrong alignment on UHDKitPrerequisite_SquadSizeLimit");
//(sizeof(UHDKitPrerequisite_SquadSizeLimit) == 0x000048, "Wrong size on UHDKitPrerequisite_SquadSizeLimit");
//(offsetof(UHDKitPrerequisite_SquadSizeLimit, MaxSquadCount) == 0x000040, "Member 'UHDKitPrerequisite_SquadSizeLimit::MaxSquadCount' has a wrong offset!");

// Class HDMain.HDKitPrerequisite_SquadUsageLimit
// 0x0008 (0x0048 - 0x0040)
class UHDKitPrerequisite_SquadUsageLimit final  : public UHDKitPrerequisiteBase
{
public:
	int32                                         MaxSquadMembers;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E4[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_SquadUsageLimit">();
	}
	static class UHDKitPrerequisite_SquadUsageLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_SquadUsageLimit>();
	}
};
//(alignof(UHDKitPrerequisite_SquadUsageLimit) == 0x000008, "Wrong alignment on UHDKitPrerequisite_SquadUsageLimit");
//(sizeof(UHDKitPrerequisite_SquadUsageLimit) == 0x000048, "Wrong size on UHDKitPrerequisite_SquadUsageLimit");
//(offsetof(UHDKitPrerequisite_SquadUsageLimit, MaxSquadMembers) == 0x000040, "Member 'UHDKitPrerequisite_SquadUsageLimit::MaxSquadMembers' has a wrong offset!");

// Class HDMain.HDKitPrerequisite_TeamSpecific
// 0x0008 (0x0048 - 0x0040)
class UHDKitPrerequisite_TeamSpecific final  : public UHDKitPrerequisiteBase
{
public:
	EHDTeam                                       RequiredTeam;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E5[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_TeamSpecific">();
	}
	static class UHDKitPrerequisite_TeamSpecific* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_TeamSpecific>();
	}
};
//(alignof(UHDKitPrerequisite_TeamSpecific) == 0x000008, "Wrong alignment on UHDKitPrerequisite_TeamSpecific");
//(sizeof(UHDKitPrerequisite_TeamSpecific) == 0x000048, "Wrong size on UHDKitPrerequisite_TeamSpecific");
//(offsetof(UHDKitPrerequisite_TeamSpecific, RequiredTeam) == 0x000040, "Member 'UHDKitPrerequisite_TeamSpecific::RequiredTeam' has a wrong offset!");

// Class HDMain.HDKitPrerequisite_TeamUsageLimit
// 0x0008 (0x0048 - 0x0040)
class UHDKitPrerequisite_TeamUsageLimit final  : public UHDKitPrerequisiteBase
{
public:
	int32                                         MaxTeamMembers;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E6[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDKitPrerequisite_TeamUsageLimit">();
	}
	static class UHDKitPrerequisite_TeamUsageLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDKitPrerequisite_TeamUsageLimit>();
	}
};
//(alignof(UHDKitPrerequisite_TeamUsageLimit) == 0x000008, "Wrong alignment on UHDKitPrerequisite_TeamUsageLimit");
//(sizeof(UHDKitPrerequisite_TeamUsageLimit) == 0x000048, "Wrong size on UHDKitPrerequisite_TeamUsageLimit");
//(offsetof(UHDKitPrerequisite_TeamUsageLimit, MaxTeamMembers) == 0x000040, "Member 'UHDKitPrerequisite_TeamUsageLimit::MaxTeamMembers' has a wrong offset!");

// Class HDMain.HDLocalPlayer
// 0x0000 (0x0258 - 0x0258)
class UHDLocalPlayer final  : public UDFLocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDLocalPlayer">();
	}
	static class UHDLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDLocalPlayer>();
	}
};
//(alignof(UHDLocalPlayer) == 0x000008, "Wrong alignment on UHDLocalPlayer");
//(sizeof(UHDLocalPlayer) == 0x000258, "Wrong size on UHDLocalPlayer");

// Class HDMain.HDModData
// 0x0018 (0x0048 - 0x0030)
class UHDModData final  : public UHDCoreUGCData
{
public:
	TArray<struct FHDPrimaryAssetSearchPath>      PrimaryAssetPathsToScan;                           // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServersideOnlyMod;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E7[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ModDataVersion;                                    // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool DoesModPluginUseLegacyMapScanning(const class FString& PluginName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDModData">();
	}
	static class UHDModData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDModData>();
	}
};
//(alignof(UHDModData) == 0x000008, "Wrong alignment on UHDModData");
//(sizeof(UHDModData) == 0x000048, "Wrong size on UHDModData");
//(offsetof(UHDModData, PrimaryAssetPathsToScan) == 0x000030, "Member 'UHDModData::PrimaryAssetPathsToScan' has a wrong offset!");
//(offsetof(UHDModData, bServersideOnlyMod) == 0x000040, "Member 'UHDModData::bServersideOnlyMod' has a wrong offset!");
//(offsetof(UHDModData, ModDataVersion) == 0x000044, "Member 'UHDModData::ModDataVersion' has a wrong offset!");

// Class HDMain.HDNavigationSystem
// 0x0000 (0x0538 - 0x0538)
class UHDNavigationSystem final  : public UDFNavigationSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDNavigationSystem">();
	}
	static class UHDNavigationSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDNavigationSystem>();
	}
};
//(alignof(UHDNavigationSystem) == 0x000008, "Wrong alignment on UHDNavigationSystem");
//(sizeof(UHDNavigationSystem) == 0x000538, "Wrong size on UHDNavigationSystem");

// Class HDMain.HDNavigationSystemConfig
// 0x0000 (0x0060 - 0x0060)
class UHDNavigationSystemConfig final  : public UDFNavigationSystemConfig
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDNavigationSystemConfig">();
	}
	static class UHDNavigationSystemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDNavigationSystemConfig>();
	}
};
//(alignof(UHDNavigationSystemConfig) == 0x000008, "Wrong alignment on UHDNavigationSystemConfig");
//(sizeof(UHDNavigationSystemConfig) == 0x000060, "Wrong size on UHDNavigationSystemConfig");

// Class HDMain.HDOnlineSessionClient
// 0x0000 (0x01A8 - 0x01A8)
class UHDOnlineSessionClient final  : public UDFOnlineSessionClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDOnlineSessionClient">();
	}
	static class UHDOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDOnlineSessionClient>();
	}
};
//(alignof(UHDOnlineSessionClient) == 0x000008, "Wrong alignment on UHDOnlineSessionClient");
//(sizeof(UHDOnlineSessionClient) == 0x0001A8, "Wrong size on UHDOnlineSessionClient");

// Class HDMain.HDOptionsMenu
// 0x0000 (0x0238 - 0x0238)
class UHDOptionsMenu : public UDFBaseMenu
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDOptionsMenu">();
	}
	static class UHDOptionsMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDOptionsMenu>();
	}
};
//(alignof(UHDOptionsMenu) == 0x000008, "Wrong alignment on UHDOptionsMenu");
//(sizeof(UHDOptionsMenu) == 0x000238, "Wrong size on UHDOptionsMenu");

// Class HDMain.HDPhysicsCollisionHandler
// 0x0000 (0x0040 - 0x0040)
class UHDPhysicsCollisionHandler final  : public UDFPhysicsCollisionHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPhysicsCollisionHandler">();
	}
	static class UHDPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPhysicsCollisionHandler>();
	}
};
//(alignof(UHDPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UHDPhysicsCollisionHandler");
//(sizeof(UHDPhysicsCollisionHandler) == 0x000040, "Wrong size on UHDPhysicsCollisionHandler");

// Class HDMain.HDPlatoonCreationRuleBase
// 0x0000 (0x0028 - 0x0028)
class UHDPlatoonCreationRuleBase : public UObject
{
public:
	bool SatisfiesRule(class UHDTeamDefinition* TeamDef) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlatoonCreationRuleBase">();
	}
	static class UHDPlatoonCreationRuleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlatoonCreationRuleBase>();
	}
};
//(alignof(UHDPlatoonCreationRuleBase) == 0x000008, "Wrong alignment on UHDPlatoonCreationRuleBase");
//(sizeof(UHDPlatoonCreationRuleBase) == 0x000028, "Wrong size on UHDPlatoonCreationRuleBase");

// Class HDMain.HDPlatoonInfo
// 0x0038 (0x0068 - 0x0030)
class UHDPlatoonInfo : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      PlatoonType;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHDPlatoonCreationRuleBase*>     CreationRules;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxSquadLimit;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11EA[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldCreateForTeam(class UHDTeamDefinition* TeamDef) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlatoonInfo">();
	}
	static class UHDPlatoonInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlatoonInfo>();
	}
};
//(alignof(UHDPlatoonInfo) == 0x000008, "Wrong alignment on UHDPlatoonInfo");
//(sizeof(UHDPlatoonInfo) == 0x000068, "Wrong size on UHDPlatoonInfo");
//(offsetof(UHDPlatoonInfo, PlatoonType) == 0x000030, "Member 'UHDPlatoonInfo::PlatoonType' has a wrong offset!");
//(offsetof(UHDPlatoonInfo, CreationRules) == 0x000038, "Member 'UHDPlatoonInfo::CreationRules' has a wrong offset!");
//(offsetof(UHDPlatoonInfo, DisplayName) == 0x000048, "Member 'UHDPlatoonInfo::DisplayName' has a wrong offset!");
//(offsetof(UHDPlatoonInfo, MaxSquadLimit) == 0x000060, "Member 'UHDPlatoonInfo::MaxSquadLimit' has a wrong offset!");

// Class HDMain.HDPlatoonStateCreationPayload
// 0x0010 (0x0038 - 0x0028)
class UHDPlatoonStateCreationPayload final  : public UObject
{
public:
	struct FHDPlatoonCreationParams               CreationParams;                                    // 0x0028(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlatoonStateCreationPayload">();
	}
	static class UHDPlatoonStateCreationPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlatoonStateCreationPayload>();
	}
};
//(alignof(UHDPlatoonStateCreationPayload) == 0x000008, "Wrong alignment on UHDPlatoonStateCreationPayload");
//(sizeof(UHDPlatoonStateCreationPayload) == 0x000038, "Wrong size on UHDPlatoonStateCreationPayload");
//(offsetof(UHDPlatoonStateCreationPayload, CreationParams) == 0x000028, "Member 'UHDPlatoonStateCreationPayload::CreationParams' has a wrong offset!");

// Class HDMain.HDPlatoonState
// 0x01D0 (0x03F0 - 0x0220)
class AHDPlatoonState : public ADFReplInfo
{
public:
	uint8                                         Pad_11EC[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSquadAdded;                                      // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSquadPreRemove;                                  // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AHDSquadState>              SquadStateClass;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDFGenericObjectContainer              Squads;                                            // 0x0250(0x0180)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         bInitialized : 1;                                  // 0x03D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_11ED[0x3];                                     // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDPlatoonInfo*                         Info;                                              // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TeamId;                                            // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11EE[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDTeamState*                           OwnerTeam;                                         // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AHDSquadState* AddSquad(class FText& SquadDisplayName, class AHDPlayerState* SquadLeader, bool bStartLocked);
	bool FindSquadByName(class FText& SquadDisplayName, class AHDSquadState** OutFoundSquad);
	void ReceiveSquadAdded(class AHDSquadState* Squad);
	void ReceiveSquadPreRemove(class AHDSquadState* Squad);
	void RemoveFromOwner();
	void RemoveSquad(class AHDSquadState* SquadToRemove);
	void RemoveSquadAt(int32 RemoveIdx);

	void DumpSquadState() const;
	int32 GetMaxSquadLimit() const;
	int32 GetNumSquads(bool bValidSquadsOnly) const;
	class AHDSquadState* GetSquadAt(int32 Param_Index, bool bIgnorePendingRemoval) const;
	bool HasReachedMaxSquadLimit() const;
	bool IsSquadPendingRemovalFromPlatoon(class AHDSquadState* Squad) const;
	bool SquadExists(class AHDSquadState* Squad, bool bIgnorePendingRemoval) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlatoonState">();
	}
	static class AHDPlatoonState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDPlatoonState>();
	}
};
//(alignof(AHDPlatoonState) == 0x000008, "Wrong alignment on AHDPlatoonState");
//(sizeof(AHDPlatoonState) == 0x0003F0, "Wrong size on AHDPlatoonState");
//(offsetof(AHDPlatoonState, OnSquadAdded) == 0x000228, "Member 'AHDPlatoonState::OnSquadAdded' has a wrong offset!");
//(offsetof(AHDPlatoonState, OnSquadPreRemove) == 0x000238, "Member 'AHDPlatoonState::OnSquadPreRemove' has a wrong offset!");
//(offsetof(AHDPlatoonState, SquadStateClass) == 0x000248, "Member 'AHDPlatoonState::SquadStateClass' has a wrong offset!");
//(offsetof(AHDPlatoonState, Squads) == 0x000250, "Member 'AHDPlatoonState::Squads' has a wrong offset!");
//(offsetof(AHDPlatoonState, ID) == 0x0003D4, "Member 'AHDPlatoonState::ID' has a wrong offset!");
//(offsetof(AHDPlatoonState, Info) == 0x0003D8, "Member 'AHDPlatoonState::Info' has a wrong offset!");
//(offsetof(AHDPlatoonState, TeamId) == 0x0003E0, "Member 'AHDPlatoonState::TeamId' has a wrong offset!");
//(offsetof(AHDPlatoonState, OwnerTeam) == 0x0003E8, "Member 'AHDPlatoonState::OwnerTeam' has a wrong offset!");

// Class HDMain.HDPlayerCameraManager
// 0x0000 (0x2740 - 0x2740)
class AHDPlayerCameraManager : public ADFPlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerCameraManager">();
	}
	static class AHDPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDPlayerCameraManager>();
	}
};
//(alignof(AHDPlayerCameraManager) == 0x000010, "Wrong alignment on AHDPlayerCameraManager");
//(sizeof(AHDPlayerCameraManager) == 0x002740, "Wrong size on AHDPlayerCameraManager");

// Class HDMain.HDPlayerCharacter
// 0x00D0 (0x0A40 - 0x0970)
class AHDPlayerCharacter : public ADFBasePlayerCharacter
{
public:
	bool                                          bUseAttachedVehicleRelevancy;                      // 0x0970(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F5[0x3];                                     // 0x0971(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingBobSpeed;                                   // 0x0974(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDoHeadBob : 1;                                    // 0x0978(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowFreeAim : 1;                                 // 0x0978(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bAllowFreeAimWhileAiming : 1;                      // 0x0978(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDoFreeAim : 1;                                    // 0x0978(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_11F6[0x7];                                     // 0x0979(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDFCharacterVariationDataHandle        VariationHandle;                                   // 0x0980(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    SpringArm;                                         // 0x0998(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    FreeAimSpringArm;                                  // 0x09A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHDKit*                                 CurrentLoadout;                                    // 0x09A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AHDBasePickup_Kit>          KitClassFallback;                                  // 0x09B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KitDropTraceDistance;                              // 0x09B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bInventoryMenuShown : 1;                           // 0x09BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11F7[0x3];                                     // 0x09BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAimStyleChanged;                                 // 0x09C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EHDWeaponAimStyle                             AimStyle;                                          // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11F8[0x7];                                     // 0x09D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDTeamState*                           HDTeamState;                                       // 0x09D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AIVocalAC;                                         // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShake>               WalkingHeadBob;                                    // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShake>               SprintingHeadBob;                                  // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bCanAddYawInput : 1;                               // 0x09F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanAddPitchInput : 1;                             // 0x09F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bCanAddRollInput : 1;                              // 0x09F8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_11F9[0x3];                                     // 0x09F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeAimDeadzoneCameraSpeedFactor;                  // 0x09FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeAimReturnToCenterInterpSpeed;                  // 0x0A00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFreeAimYaw;                                     // 0x0A04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFreeAimPitch;                                   // 0x0A08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFreeAimYawADS;                                  // 0x0A0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFreeAimPitchADS;                                // 0x0A10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentFreeAimYaw;                                 // 0x0A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentFreeAimPitch;                               // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeAimMouseDeltaX;                                // 0x0A1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeAimMouseDeltaY;                                // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeAimExternalDeltaX;                             // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeAimExternalDeltaY;                             // 0x0A28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHDAIVocalizationType                         LastAIVocalization;                                // 0x0A2C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FA[0x3];                                     // 0x0A2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDAIPerceptionComponent*               HDAIPerceptionComponent;                           // 0x0A30(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FB[0x8];                                     // 0x0A38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropKit();
	bool EquipPrimaryItem();
	void FreeAim(float DeltaSeconds);
	void HeadBob();
	void NotifyPlayerStateChanged(class APlayerState* NewPlayerState, class APlayerState* OldPlayerState);
	void OnPickupKit(class AHDBasePickup_Kit* Kit);
	void OnRep_CurrentLoadout();
	void PlayVocalSoundAI(class USoundBase* SoundToUse, EHDAIVocalizationType VocalType, float PitchMultiplier);
	void ReceiveAimStyleChanged(EHDWeaponAimStyle NewAimStyle, EHDWeaponAimStyle PrevAimStyle, bool bFromPlayerInput);
	void ReceiveCurrentLoadout();
	void ReceiveFreeAim(float DeltaSeconds);
	void ReceiveVariationDataChanged(struct FDFCharacterVariationData& NewVariation, struct FDFCharacterVariationData& PreviousVariation);
	void ReceiveVoipTalkerMsgReceived(class UDFCommChannel* MsgTalkerChannel, class APlayerState* MsgTalkerPS, bool bMsgIsTalking);
	void SetAimStyle(EHDWeaponAimStyle InAimStyle, bool bFromPlayerInput);
	void SetAllowFreeAim(bool bEnabled);
	void SetAllowFreeAimADS(bool bEnabled);
	void SetFreeAimDeadzoneCameraSpeedFactor(float NewSpeedFactor);
	void SetFreeAimReturnToCenterInterpSpeed(float NewInterpSpeed);
	void SetMaxFreeAimPitch(float NewPitch);
	void SetMaxFreeAimPitchADS(float NewPitch);
	void SetMaxFreeAimYaw(float NewYaw);
	void SetMaxFreeAimYawADS(float NewYaw);
	void SetVariationHandle(const struct FDFCharacterVariationDataHandle& InVariationHandle);
	void VariationDataChangedInternal(struct FDFCharacterVariationDataHandle& PreviousHandle);

	const TSubclassOf<class AHDBasePickup_Kit> GetKitClassToUse() const;
	float GetMaxFreeAimPitchToUse() const;
	float GetMaxFreeAimYawToUse() const;
	class UHDPlayerComponent* GetPlayerComponent() const;
	bool IsInVehicle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerCharacter">();
	}
	static class AHDPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDPlayerCharacter>();
	}
};
//(alignof(AHDPlayerCharacter) == 0x000010, "Wrong alignment on AHDPlayerCharacter");
//(sizeof(AHDPlayerCharacter) == 0x000A40, "Wrong size on AHDPlayerCharacter");
//(offsetof(AHDPlayerCharacter, bUseAttachedVehicleRelevancy) == 0x000970, "Member 'AHDPlayerCharacter::bUseAttachedVehicleRelevancy' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, WalkingBobSpeed) == 0x000974, "Member 'AHDPlayerCharacter::WalkingBobSpeed' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, VariationHandle) == 0x000980, "Member 'AHDPlayerCharacter::VariationHandle' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, SpringArm) == 0x000998, "Member 'AHDPlayerCharacter::SpringArm' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimSpringArm) == 0x0009A0, "Member 'AHDPlayerCharacter::FreeAimSpringArm' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, CurrentLoadout) == 0x0009A8, "Member 'AHDPlayerCharacter::CurrentLoadout' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, KitClassFallback) == 0x0009B0, "Member 'AHDPlayerCharacter::KitClassFallback' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, KitDropTraceDistance) == 0x0009B8, "Member 'AHDPlayerCharacter::KitDropTraceDistance' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, OnAimStyleChanged) == 0x0009C0, "Member 'AHDPlayerCharacter::OnAimStyleChanged' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, AimStyle) == 0x0009D0, "Member 'AHDPlayerCharacter::AimStyle' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, HDTeamState) == 0x0009D8, "Member 'AHDPlayerCharacter::HDTeamState' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, AIVocalAC) == 0x0009E0, "Member 'AHDPlayerCharacter::AIVocalAC' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, WalkingHeadBob) == 0x0009E8, "Member 'AHDPlayerCharacter::WalkingHeadBob' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, SprintingHeadBob) == 0x0009F0, "Member 'AHDPlayerCharacter::SprintingHeadBob' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimDeadzoneCameraSpeedFactor) == 0x0009FC, "Member 'AHDPlayerCharacter::FreeAimDeadzoneCameraSpeedFactor' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimReturnToCenterInterpSpeed) == 0x000A00, "Member 'AHDPlayerCharacter::FreeAimReturnToCenterInterpSpeed' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, MaxFreeAimYaw) == 0x000A04, "Member 'AHDPlayerCharacter::MaxFreeAimYaw' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, MaxFreeAimPitch) == 0x000A08, "Member 'AHDPlayerCharacter::MaxFreeAimPitch' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, MaxFreeAimYawADS) == 0x000A0C, "Member 'AHDPlayerCharacter::MaxFreeAimYawADS' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, MaxFreeAimPitchADS) == 0x000A10, "Member 'AHDPlayerCharacter::MaxFreeAimPitchADS' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, CurrentFreeAimYaw) == 0x000A14, "Member 'AHDPlayerCharacter::CurrentFreeAimYaw' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, CurrentFreeAimPitch) == 0x000A18, "Member 'AHDPlayerCharacter::CurrentFreeAimPitch' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimMouseDeltaX) == 0x000A1C, "Member 'AHDPlayerCharacter::FreeAimMouseDeltaX' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimMouseDeltaY) == 0x000A20, "Member 'AHDPlayerCharacter::FreeAimMouseDeltaY' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimExternalDeltaX) == 0x000A24, "Member 'AHDPlayerCharacter::FreeAimExternalDeltaX' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, FreeAimExternalDeltaY) == 0x000A28, "Member 'AHDPlayerCharacter::FreeAimExternalDeltaY' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, LastAIVocalization) == 0x000A2C, "Member 'AHDPlayerCharacter::LastAIVocalization' has a wrong offset!");
//(offsetof(AHDPlayerCharacter, HDAIPerceptionComponent) == 0x000A30, "Member 'AHDPlayerCharacter::HDAIPerceptionComponent' has a wrong offset!");

// Class HDMain.HDPlayerCharacterAnimInstanceBase
// 0x0020 (0x02E0 - 0x02C0)
class UHDPlayerCharacterAnimInstanceBase : public UDFCharacterAnimInstance
{
public:
	class AHDPlayerCharacter*                     HDPlyCharOwner;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlayerController*                    HDPCOwner;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDBaseWeapon*                          HDEquippedWeapon;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bInVehicle : 1;                                    // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11FE[0xF];                                     // 0x02D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerCharacterAnimInstanceBase">();
	}
	static class UHDPlayerCharacterAnimInstanceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlayerCharacterAnimInstanceBase>();
	}
};
//(alignof(UHDPlayerCharacterAnimInstanceBase) == 0x000010, "Wrong alignment on UHDPlayerCharacterAnimInstanceBase");
//(sizeof(UHDPlayerCharacterAnimInstanceBase) == 0x0002E0, "Wrong size on UHDPlayerCharacterAnimInstanceBase");
//(offsetof(UHDPlayerCharacterAnimInstanceBase, HDPlyCharOwner) == 0x0002B8, "Member 'UHDPlayerCharacterAnimInstanceBase::HDPlyCharOwner' has a wrong offset!");
//(offsetof(UHDPlayerCharacterAnimInstanceBase, HDPCOwner) == 0x0002C0, "Member 'UHDPlayerCharacterAnimInstanceBase::HDPCOwner' has a wrong offset!");
//(offsetof(UHDPlayerCharacterAnimInstanceBase, HDEquippedWeapon) == 0x0002C8, "Member 'UHDPlayerCharacterAnimInstanceBase::HDEquippedWeapon' has a wrong offset!");

// Class HDMain.HDPlayerCharacterAnimInst_FPP
// 0x0000 (0x02E0 - 0x02E0)
class UHDPlayerCharacterAnimInst_FPP : public UHDPlayerCharacterAnimInstanceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerCharacterAnimInst_FPP">();
	}
	static class UHDPlayerCharacterAnimInst_FPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlayerCharacterAnimInst_FPP>();
	}
};
//(alignof(UHDPlayerCharacterAnimInst_FPP) == 0x000010, "Wrong alignment on UHDPlayerCharacterAnimInst_FPP");
//(sizeof(UHDPlayerCharacterAnimInst_FPP) == 0x0002E0, "Wrong size on UHDPlayerCharacterAnimInst_FPP");

// Class HDMain.HDPlayerCharacterAnimInst_TPP
// 0x0000 (0x02E0 - 0x02E0)
class UHDPlayerCharacterAnimInst_TPP : public UHDPlayerCharacterAnimInstanceBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerCharacterAnimInst_TPP">();
	}
	static class UHDPlayerCharacterAnimInst_TPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlayerCharacterAnimInst_TPP>();
	}
};
//(alignof(UHDPlayerCharacterAnimInst_TPP) == 0x000010, "Wrong alignment on UHDPlayerCharacterAnimInst_TPP");
//(sizeof(UHDPlayerCharacterAnimInst_TPP) == 0x0002E0, "Wrong size on UHDPlayerCharacterAnimInst_TPP");

// Class HDMain.HDPlayerComponent
// 0x0008 (0x00D0 - 0x00C8)
class UHDPlayerComponent final  : public UDFPlayerComponent
{
public:
	class UDFLoadout*                             StartLoadout;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PickTeam(EHDTeam DesiredTeam);
	void RestartPlayerAtStartSpot(class AActor* DesiredStartSpot, class UDFLoadout* DesiredStartLoadout);
	void SwitchTeam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerComponent">();
	}
	static class UHDPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPlayerComponent>();
	}
};
//(alignof(UHDPlayerComponent) == 0x000008, "Wrong alignment on UHDPlayerComponent");
//(sizeof(UHDPlayerComponent) == 0x0000D0, "Wrong size on UHDPlayerComponent");
//(offsetof(UHDPlayerComponent, StartLoadout) == 0x0000C8, "Member 'UHDPlayerComponent::StartLoadout' has a wrong offset!");

// Class HDMain.HDPlayerStart
// 0x0000 (0x0250 - 0x0250)
class AHDPlayerStart final  : public APlayerStart
{
public:
	class UCapsuleComponent* K2_GetCapsuleComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerStart">();
	}
	static class AHDPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDPlayerStart>();
	}
};
//(alignof(AHDPlayerStart) == 0x000008, "Wrong alignment on AHDPlayerStart");
//(sizeof(AHDPlayerStart) == 0x000250, "Wrong size on AHDPlayerStart");

// Class HDMain.HDPlayerState
// 0x0030 (0x03A8 - 0x0378)
class AHDPlayerState final  : public ADFBasePlayerState
{
public:
	class UHDKit*                                 SpawnLoadout;                                      // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDKit*                                 CurrentLoadout;                                    // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHDSquadAssignmentInfo                 SquadInfo;                                         // 0x0388(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnPlayerSquadInfoUpdated;                          // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AssignCurrentLoadout(class UHDKit* NewCurrentLoadout);
	void AssignSpawnLoadout(class UHDKit* NewSpawnLoadout);
	void OnRep_CurrentLoadout(class UHDKit* PrevLoadout);
	void OnRep_SpawnLoadout(class UHDKit* PrevSpawnLoadout);
	void OnRep_SquadInfo();
	void UnregisterFromSquad();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPlayerState">();
	}
	static class AHDPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDPlayerState>();
	}
};
//(alignof(AHDPlayerState) == 0x000008, "Wrong alignment on AHDPlayerState");
//(sizeof(AHDPlayerState) == 0x0003A8, "Wrong size on AHDPlayerState");
//(offsetof(AHDPlayerState, SpawnLoadout) == 0x000378, "Member 'AHDPlayerState::SpawnLoadout' has a wrong offset!");
//(offsetof(AHDPlayerState, CurrentLoadout) == 0x000380, "Member 'AHDPlayerState::CurrentLoadout' has a wrong offset!");
//(offsetof(AHDPlayerState, SquadInfo) == 0x000388, "Member 'AHDPlayerState::SquadInfo' has a wrong offset!");
//(offsetof(AHDPlayerState, OnPlayerSquadInfoUpdated) == 0x000398, "Member 'AHDPlayerState::OnPlayerSquadInfoUpdated' has a wrong offset!");

// Class HDMain.HDProj_Bullet
// 0x0000 (0x0380 - 0x0380)
class AHDProj_Bullet : public AHDBaseProjectile
{
public:
	class USphereComponent*                       ProjectileCollision;                               // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDProj_Bullet">();
	}
	static class AHDProj_Bullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDProj_Bullet>();
	}
};
//(alignof(AHDProj_Bullet) == 0x000010, "Wrong alignment on AHDProj_Bullet");
//(sizeof(AHDProj_Bullet) == 0x000380, "Wrong size on AHDProj_Bullet");
//(offsetof(AHDProj_Bullet, ProjectileCollision) == 0x000378, "Member 'AHDProj_Bullet::ProjectileCollision' has a wrong offset!");

// Class HDMain.HDProj_Grenade
// 0x0010 (0x0390 - 0x0380)
class AHDProj_Grenade : public AHDBaseProjectile
{
public:
	uint8                                         Pad_11FF[0x4];                                     // 0x0378(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FuzeDelay;                                         // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PayloadPostTriggerLifeSpan;                        // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PayloadServerActivationTime;                       // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1200[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PayloadServerActivationTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDProj_Grenade">();
	}
	static class AHDProj_Grenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDProj_Grenade>();
	}
};
//(alignof(AHDProj_Grenade) == 0x000010, "Wrong alignment on AHDProj_Grenade");
//(sizeof(AHDProj_Grenade) == 0x000390, "Wrong size on AHDProj_Grenade");
//(offsetof(AHDProj_Grenade, FuzeDelay) == 0x00037C, "Member 'AHDProj_Grenade::FuzeDelay' has a wrong offset!");
//(offsetof(AHDProj_Grenade, PayloadPostTriggerLifeSpan) == 0x000380, "Member 'AHDProj_Grenade::PayloadPostTriggerLifeSpan' has a wrong offset!");
//(offsetof(AHDProj_Grenade, PayloadServerActivationTime) == 0x000384, "Member 'AHDProj_Grenade::PayloadServerActivationTime' has a wrong offset!");

// Class HDMain.HDRecastNavMesh
// 0x0000 (0x04B8 - 0x04B8)
class AHDRecastNavMesh final  : public ADFRecastNavMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDRecastNavMesh">();
	}
	static class AHDRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDRecastNavMesh>();
	}
};
//(alignof(AHDRecastNavMesh) == 0x000008, "Wrong alignment on AHDRecastNavMesh");
//(sizeof(AHDRecastNavMesh) == 0x0004B8, "Wrong size on AHDRecastNavMesh");

// Class HDMain.HDRuleset_AAS
// 0x0000 (0x0060 - 0x0060)
class UHDRuleset_AAS : public UHDGameRulesetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDRuleset_AAS">();
	}
	static class UHDRuleset_AAS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDRuleset_AAS>();
	}
};
//(alignof(UHDRuleset_AAS) == 0x000008, "Wrong alignment on UHDRuleset_AAS");
//(sizeof(UHDRuleset_AAS) == 0x000060, "Wrong size on UHDRuleset_AAS");

// Class HDMain.HDRuleset_ControlPoint
// 0x0040 (0x00A0 - 0x0060)
class UHDRuleset_ControlPoint : public UHDGameRulesetBase
{
public:
	struct FControlPointRulesetSettings           BluforTeamCPSettings;                              // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FControlPointRulesetSettings           OpforTeamCPSettings;                               // 0x0080(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void ControlPointCaptureProgressUpdated(class AHDBaseCapturePoint* ControlPoint, bool bContested, int32 Progress);
	void ControlPointTeamUpdated(class AHDBaseCapturePoint* ControlPoint, EHDTeam PrevTeam, EHDTeam NewTeam, bool bCaptured);

	const struct FControlPointRulesetSettings GetControlPointSettingsForTeam(EHDTeam ControlPointTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDRuleset_ControlPoint">();
	}
	static class UHDRuleset_ControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDRuleset_ControlPoint>();
	}
};
//(alignof(UHDRuleset_ControlPoint) == 0x000008, "Wrong alignment on UHDRuleset_ControlPoint");
//(sizeof(UHDRuleset_ControlPoint) == 0x0000A0, "Wrong size on UHDRuleset_ControlPoint");
//(offsetof(UHDRuleset_ControlPoint, BluforTeamCPSettings) == 0x000060, "Member 'UHDRuleset_ControlPoint::BluforTeamCPSettings' has a wrong offset!");
//(offsetof(UHDRuleset_ControlPoint, OpforTeamCPSettings) == 0x000080, "Member 'UHDRuleset_ControlPoint::OpforTeamCPSettings' has a wrong offset!");

// Class HDMain.HDRuleset_KillDeath
// 0x0050 (0x00B0 - 0x0060)
class UHDRuleset_KillDeath : public UHDGameRulesetBase
{
public:
	struct FKillDeathRulesetSettings              BluforTeamKDSettings;                              // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FKillDeathRulesetSettings              OpforTeamKDSettings;                               // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void PlayerTeamKilled(class AController* Killer, class AController* Victim);

	const struct FKillDeathRulesetSettings GetKillDeathSettingsForTeam(EHDTeam KillDeathTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDRuleset_KillDeath">();
	}
	static class UHDRuleset_KillDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDRuleset_KillDeath>();
	}
};
//(alignof(UHDRuleset_KillDeath) == 0x000008, "Wrong alignment on UHDRuleset_KillDeath");
//(sizeof(UHDRuleset_KillDeath) == 0x0000B0, "Wrong size on UHDRuleset_KillDeath");
//(offsetof(UHDRuleset_KillDeath, BluforTeamKDSettings) == 0x000060, "Member 'UHDRuleset_KillDeath::BluforTeamKDSettings' has a wrong offset!");
//(offsetof(UHDRuleset_KillDeath, OpforTeamKDSettings) == 0x000088, "Member 'UHDRuleset_KillDeath::OpforTeamKDSettings' has a wrong offset!");

// Class HDMain.HDRuleset_NoPlayerSpawnKitRestrictions
// 0x0000 (0x0060 - 0x0060)
class UHDRuleset_NoPlayerSpawnKitRestrictions final  : public UHDGameRulesetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDRuleset_NoPlayerSpawnKitRestrictions">();
	}
	static class UHDRuleset_NoPlayerSpawnKitRestrictions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDRuleset_NoPlayerSpawnKitRestrictions>();
	}
};
//(alignof(UHDRuleset_NoPlayerSpawnKitRestrictions) == 0x000008, "Wrong alignment on UHDRuleset_NoPlayerSpawnKitRestrictions");
//(sizeof(UHDRuleset_NoPlayerSpawnKitRestrictions) == 0x000060, "Wrong size on UHDRuleset_NoPlayerSpawnKitRestrictions");

// Class HDMain.HDRuleset_TicketBleed
// 0x0030 (0x0090 - 0x0060)
class UHDRuleset_TicketBleed : public UHDGameRulesetBase
{
public:
	uint8                                         Pad_1205[0x8];                                     // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AHDBaseCapturePoint*>            RegisteredCPs;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTicketBleedRulesetSettings            BluforTeamTBSettings;                              // 0x0078(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTicketBleedRulesetSettings            OpforTeamTBSettings;                               // 0x0084(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyTicketBleed(EHDTeam BleedTeam, int32 TicketBleedMultiplier, bool bUseMercyTicketBleed);
	void ControlPointTeamUpdated(class AHDBaseCapturePoint* ControlPoint, EHDTeam PrevTeam, EHDTeam NewTeam, bool bCaptured);
	void UpdateTicketBleedState();

	const struct FTicketBleedRulesetSettings GetTicketBleedSettingsForTeam(EHDTeam TicketBleedTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDRuleset_TicketBleed">();
	}
	static class UHDRuleset_TicketBleed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDRuleset_TicketBleed>();
	}
};
//(alignof(UHDRuleset_TicketBleed) == 0x000008, "Wrong alignment on UHDRuleset_TicketBleed");
//(sizeof(UHDRuleset_TicketBleed) == 0x000090, "Wrong size on UHDRuleset_TicketBleed");
//(offsetof(UHDRuleset_TicketBleed, RegisteredCPs) == 0x000068, "Member 'UHDRuleset_TicketBleed::RegisteredCPs' has a wrong offset!");
//(offsetof(UHDRuleset_TicketBleed, BluforTeamTBSettings) == 0x000078, "Member 'UHDRuleset_TicketBleed::BluforTeamTBSettings' has a wrong offset!");
//(offsetof(UHDRuleset_TicketBleed, OpforTeamTBSettings) == 0x000084, "Member 'UHDRuleset_TicketBleed::OpforTeamTBSettings' has a wrong offset!");

// Class HDMain.HDScoreboardBase
// 0x0018 (0x0250 - 0x0238)
class UHDScoreboardBase : public UDFBaseMenu
{
public:
	TSubclassOf<class UHDScoreboardListingRowBase> ScoreboardListRowClass;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           OpforPlayerList;                                   // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           BluforPlayerList;                                  // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveScoreboardListRowAdded(class UHDScoreboardListingRowBase* NewListEntry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDScoreboardBase">();
	}
	static class UHDScoreboardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDScoreboardBase>();
	}
};
//(alignof(UHDScoreboardBase) == 0x000008, "Wrong alignment on UHDScoreboardBase");
//(sizeof(UHDScoreboardBase) == 0x000250, "Wrong size on UHDScoreboardBase");
//(offsetof(UHDScoreboardBase, ScoreboardListRowClass) == 0x000238, "Member 'UHDScoreboardBase::ScoreboardListRowClass' has a wrong offset!");
//(offsetof(UHDScoreboardBase, OpforPlayerList) == 0x000240, "Member 'UHDScoreboardBase::OpforPlayerList' has a wrong offset!");
//(offsetof(UHDScoreboardBase, BluforPlayerList) == 0x000248, "Member 'UHDScoreboardBase::BluforPlayerList' has a wrong offset!");

// Class HDMain.HDEmptyServerFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDEmptyServerFilterRule final  : public UHDServerListFilterRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDEmptyServerFilterRule">();
	}
	static class UHDEmptyServerFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDEmptyServerFilterRule>();
	}
};
//(alignof(UHDEmptyServerFilterRule) == 0x000008, "Wrong alignment on UHDEmptyServerFilterRule");
//(sizeof(UHDEmptyServerFilterRule) == 0x000028, "Wrong size on UHDEmptyServerFilterRule");

// Class HDMain.HDPasswordProtectedServerFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDPasswordProtectedServerFilterRule final  : public UHDServerListFilterRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDPasswordProtectedServerFilterRule">();
	}
	static class UHDPasswordProtectedServerFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDPasswordProtectedServerFilterRule>();
	}
};
//(alignof(UHDPasswordProtectedServerFilterRule) == 0x000008, "Wrong alignment on UHDPasswordProtectedServerFilterRule");
//(sizeof(UHDPasswordProtectedServerFilterRule) == 0x000028, "Wrong size on UHDPasswordProtectedServerFilterRule");

// Class HDMain.HDSupportersOnlyServerFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDSupportersOnlyServerFilterRule final  : public UHDServerListFilterRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDSupportersOnlyServerFilterRule">();
	}
	static class UHDSupportersOnlyServerFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDSupportersOnlyServerFilterRule>();
	}
};
//(alignof(UHDSupportersOnlyServerFilterRule) == 0x000008, "Wrong alignment on UHDSupportersOnlyServerFilterRule");
//(sizeof(UHDSupportersOnlyServerFilterRule) == 0x000028, "Wrong size on UHDSupportersOnlyServerFilterRule");

// Class HDMain.HDContainsAddressServerFilterRule
// 0x0000 (0x0028 - 0x0028)
class UHDContainsAddressServerFilterRule final  : public UHDServerListFilterRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDContainsAddressServerFilterRule">();
	}
	static class UHDContainsAddressServerFilterRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDContainsAddressServerFilterRule>();
	}
};
//(alignof(UHDContainsAddressServerFilterRule) == 0x000008, "Wrong alignment on UHDContainsAddressServerFilterRule");
//(sizeof(UHDContainsAddressServerFilterRule) == 0x000028, "Wrong size on UHDContainsAddressServerFilterRule");

// Class HDMain.HDServerListing
// 0x0040 (0x0270 - 0x0230)
class UHDServerListing : public UUserWidget
{
public:
	uint8                                         bTextToUpper : 1;                                  // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_120A[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDServerListItemData*                  ServerData;                                        // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             ServerNameText;                                    // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             ModNameText;                                       // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             GameModeText;                                      // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             MapNameText;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             PlayersText;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             PingText;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnServerItemDataSet(bool bIsDesignTime);
	void SetupListing(class UHDServerListItemData* InServerItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDServerListing">();
	}
	static class UHDServerListing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDServerListing>();
	}
};
//(alignof(UHDServerListing) == 0x000008, "Wrong alignment on UHDServerListing");
//(sizeof(UHDServerListing) == 0x000270, "Wrong size on UHDServerListing");
//(offsetof(UHDServerListing, ServerData) == 0x000238, "Member 'UHDServerListing::ServerData' has a wrong offset!");
//(offsetof(UHDServerListing, ServerNameText) == 0x000240, "Member 'UHDServerListing::ServerNameText' has a wrong offset!");
//(offsetof(UHDServerListing, ModNameText) == 0x000248, "Member 'UHDServerListing::ModNameText' has a wrong offset!");
//(offsetof(UHDServerListing, GameModeText) == 0x000250, "Member 'UHDServerListing::GameModeText' has a wrong offset!");
//(offsetof(UHDServerListing, MapNameText) == 0x000258, "Member 'UHDServerListing::MapNameText' has a wrong offset!");
//(offsetof(UHDServerListing, PlayersText) == 0x000260, "Member 'UHDServerListing::PlayersText' has a wrong offset!");
//(offsetof(UHDServerListing, PingText) == 0x000268, "Member 'UHDServerListing::PingText' has a wrong offset!");

// Class HDMain.HDSquadHiddenState
// 0x0010 (0x0230 - 0x0220)
class AHDSquadHiddenState : public AInfo
{
public:
	uint8                                         Pad_120B[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDSquadState*                          SquadStateOwner;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDSquadHiddenState">();
	}
	static class AHDSquadHiddenState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDSquadHiddenState>();
	}
};
//(alignof(AHDSquadHiddenState) == 0x000008, "Wrong alignment on AHDSquadHiddenState");
//(sizeof(AHDSquadHiddenState) == 0x000230, "Wrong size on AHDSquadHiddenState");
//(offsetof(AHDSquadHiddenState, SquadStateOwner) == 0x000228, "Member 'AHDSquadHiddenState::SquadStateOwner' has a wrong offset!");

// Class HDMain.HDSquadState
// 0x0240 (0x0460 - 0x0220)
class AHDSquadState : public ADFReplInfo
{
public:
	uint8                                         Pad_120C[0x8];                                     // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInitialized : 1;                                  // 0x0228(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_120D[0x7];                                     // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AHDSquadHiddenState>        SquadHiddenStateClass;                             // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ID;                                                // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TeamId;                                            // 0x023C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120E[0x3];                                     // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDPlatoonState*                        OwnerPlatoon;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   DisplayName;                                       // 0x0248(0x0018)(Edit, BlueprintVisible, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NativeAccessSpecifierPrivate)
	class AHDSquadHiddenState*                    SquadHiddenState;                                  // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlayerState*                         SquadLeader;                                       // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bLocked : 1;                                       // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnTemplate, Transient, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         BitPad_49 : 2;                                     // 0x0270(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bRequiresSquadLeader : 1;                          // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bDisbandSquadOnEmpty : 1;                          // 0x0270(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_120F[0x7];                                     // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSquadLeaderAssigned;                             // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSquadMemberRegistered;                           // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSquadMemberPreUnregister;                        // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSquadMemberInfoUpdated;                          // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSquadRenamed;                                    // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSquadLockToggled;                                // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDFGenericObjectContainer              SquadMembers;                                      // 0x02D8(0x0180)(Net, Transient, NativeAccessSpecifierPrivate)
	int32                                         MaxSquadMemberLimit;                               // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1210[0x4];                                     // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AssignSquadLeader(class AHDPlayerState* NewLeaderPS);
	void LockSquad();
	void OnRep_bLocked();
	void OnRep_DisplayName(class FText& PrevDisplayName);
	void OnRep_SquadHiddenState();
	void OnRep_SquadLeader(class AHDPlayerState* PrevSquadLeader);
	void ReceiveInit(struct FHDSquadCreationParams& CreationParams);
	void ReceiveSquadLeaderAssigned(class AHDPlayerState* NewLeaderPS, class AHDPlayerState* PrevLeaderPS);
	void ReceiveSquadLocked();
	void ReceiveSquadMemberPreUnregister(class AHDPlayerState* MemberPS);
	void ReceiveSquadMemberRegistered(class AHDPlayerState* MemberPS);
	void ReceiveSquadRenamed(class FText& NewName, class FText& PrevName);
	void ReceiveSquadUnlocked();
	bool RegisterPlayerSquadMember(class AHDPlayerController* NewMemberPC);
	bool RegisterSquadMember(class AHDPlayerState* NewMemberPS);
	void RemoveFromOwner();
	void RenameSquad(class FText& NewDisplayName);
	void SquadMemberPSEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason);
	void SquadMemberPSSquadUpdated(class AHDPlayerState* MemberPS, struct FHDSquadAssignmentInfo& MemberSQInfo);
	void SquadMemberPSTeamUpdated(class APlayerState* MemberPS, uint8 LastTeamNum, uint8 NewTeamNum);
	void UnlockSquad();
	bool UnregisterPlayerSquadMember(class AHDPlayerController* MemberPCToRemove);
	bool UnregisterSquadMember(class AHDPlayerState* MemberPSToRemove);
	bool UnregisterSquadMemberAt(int32 RemoveIdx);

	bool CanRegisterPlayerSquadMember(class AHDPlayerController* NewMemberPC) const;
	bool CanRegisterSquadMember(class AHDPlayerState* NewMemberPS) const;
	void DumpSquadMemberState() const;
	int32 GetNumSquadMembers(bool bValidMembersOnly) const;
	int32 GetNumSquadMembersBots(bool bValidMembersOnly) const;
	class AHDPlayerState* GetSquadMemberAt(int32 Param_Index, bool bIgnorePendingRemoval) const;
	bool HasReachedMaxSquadMemberLimit() const;
	bool IsPendingRemovalFromSquad(class AHDPlayerState* PS) const;
	bool IsPlayerPendingRemovalFromSquad(class AHDPlayerController* PC) const;
	bool IsPlayerRegisteredSquadMember(class AHDPlayerController* PC, bool bIgnorePendingRemoval) const;
	bool IsRegisteredSquadMember(class AHDPlayerState* PS, bool bIgnorePendingRemoval) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDSquadState">();
	}
	static class AHDSquadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDSquadState>();
	}
};
//(alignof(AHDSquadState) == 0x000008, "Wrong alignment on AHDSquadState");
//(sizeof(AHDSquadState) == 0x000460, "Wrong size on AHDSquadState");
//(offsetof(AHDSquadState, SquadHiddenStateClass) == 0x000230, "Member 'AHDSquadState::SquadHiddenStateClass' has a wrong offset!");
//(offsetof(AHDSquadState, ID) == 0x000238, "Member 'AHDSquadState::ID' has a wrong offset!");
//(offsetof(AHDSquadState, TeamId) == 0x00023C, "Member 'AHDSquadState::TeamId' has a wrong offset!");
//(offsetof(AHDSquadState, OwnerPlatoon) == 0x000240, "Member 'AHDSquadState::OwnerPlatoon' has a wrong offset!");
//(offsetof(AHDSquadState, DisplayName) == 0x000248, "Member 'AHDSquadState::DisplayName' has a wrong offset!");
//(offsetof(AHDSquadState, SquadHiddenState) == 0x000260, "Member 'AHDSquadState::SquadHiddenState' has a wrong offset!");
//(offsetof(AHDSquadState, SquadLeader) == 0x000268, "Member 'AHDSquadState::SquadLeader' has a wrong offset!");
//(offsetof(AHDSquadState, OnSquadLeaderAssigned) == 0x000278, "Member 'AHDSquadState::OnSquadLeaderAssigned' has a wrong offset!");
//(offsetof(AHDSquadState, OnSquadMemberRegistered) == 0x000288, "Member 'AHDSquadState::OnSquadMemberRegistered' has a wrong offset!");
//(offsetof(AHDSquadState, OnSquadMemberPreUnregister) == 0x000298, "Member 'AHDSquadState::OnSquadMemberPreUnregister' has a wrong offset!");
//(offsetof(AHDSquadState, OnSquadMemberInfoUpdated) == 0x0002A8, "Member 'AHDSquadState::OnSquadMemberInfoUpdated' has a wrong offset!");
//(offsetof(AHDSquadState, OnSquadRenamed) == 0x0002B8, "Member 'AHDSquadState::OnSquadRenamed' has a wrong offset!");
//(offsetof(AHDSquadState, OnSquadLockToggled) == 0x0002C8, "Member 'AHDSquadState::OnSquadLockToggled' has a wrong offset!");
//(offsetof(AHDSquadState, SquadMembers) == 0x0002D8, "Member 'AHDSquadState::SquadMembers' has a wrong offset!");
//(offsetof(AHDSquadState, MaxSquadMemberLimit) == 0x000458, "Member 'AHDSquadState::MaxSquadMemberLimit' has a wrong offset!");

// Class HDMain.HDTeamDefinition
// 0x0010 (0x0068 - 0x0058)
class UHDTeamDefinition final  : public UDFTeamDefinition
{
public:
	int32                                         StartingTickets;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1222[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDFCommChannelDefinition*               CommChannelDefinition;                             // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDTeamDefinition">();
	}
	static class UHDTeamDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDTeamDefinition>();
	}
};
//(alignof(UHDTeamDefinition) == 0x000008, "Wrong alignment on UHDTeamDefinition");
//(sizeof(UHDTeamDefinition) == 0x000068, "Wrong size on UHDTeamDefinition");
//(offsetof(UHDTeamDefinition, StartingTickets) == 0x000058, "Member 'UHDTeamDefinition::StartingTickets' has a wrong offset!");
//(offsetof(UHDTeamDefinition, CommChannelDefinition) == 0x000060, "Member 'UHDTeamDefinition::CommChannelDefinition' has a wrong offset!");

// Class HDMain.HDTeamState
// 0x01F8 (0x0448 - 0x0250)
class AHDTeamState final  : public ADFTeamState
{
public:
	FMulticastInlineDelegateProperty_             OnPlatoonAdded;                                    // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlatoonPreRemove;                                // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDFGenericObjectContainer              Platoons;                                          // 0x0270(0x0180)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxPlatoonLimit;                                   // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1223[0x4];                                     // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UHDKit*>                           Kits;                                              // 0x03F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NativeAccessSpecifierPublic)

public:
	class AHDPlatoonState* AddPlatoon(class UHDPlatoonInfo* PlatoonInfo);
	bool FindPlatoonByDefinition(class UHDPlatoonInfo* PlatoonDef, class AHDPlatoonState** OutFoundPlatoon);
	bool FindPlatoonByName(class FText& PlatoonDisplayName, class AHDPlatoonState** OutFoundPlatoon);
	void ReceivePlatoonAdded(class AHDPlatoonState* Platoon);
	void ReceivePlatoonPreRemove(class AHDPlatoonState* Platoon);
	void RemovePlatoon(class AHDPlatoonState* PlatoonToRemove);
	void RemovePlatoonAt(int32 RemoveIdx);

	void DumpPlatoonState() const;
	int32 GetNumPlatoons(bool bValidPlatoonsOnly) const;
	class AHDPlatoonState* GetPlatoonAt(int32 Param_Index, bool bIgnorePendingRemoval) const;
	EHDTeam GetTeam() const;
	bool HasReachedMaxPlatoonLimit() const;
	bool IsPlatoonPendingRemovalFromTeam(class AHDPlatoonState* Platoon) const;
	bool PlatoonExists(class AHDPlatoonState* Platoon, bool bIgnorePendingRemoval) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDTeamState">();
	}
	static class AHDTeamState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDTeamState>();
	}
};
//(alignof(AHDTeamState) == 0x000008, "Wrong alignment on AHDTeamState");
//(sizeof(AHDTeamState) == 0x000448, "Wrong size on AHDTeamState");
//(offsetof(AHDTeamState, OnPlatoonAdded) == 0x000250, "Member 'AHDTeamState::OnPlatoonAdded' has a wrong offset!");
//(offsetof(AHDTeamState, OnPlatoonPreRemove) == 0x000260, "Member 'AHDTeamState::OnPlatoonPreRemove' has a wrong offset!");
//(offsetof(AHDTeamState, Platoons) == 0x000270, "Member 'AHDTeamState::Platoons' has a wrong offset!");
//(offsetof(AHDTeamState, MaxPlatoonLimit) == 0x0003F0, "Member 'AHDTeamState::MaxPlatoonLimit' has a wrong offset!");
//(offsetof(AHDTeamState, Kits) == 0x0003F8, "Member 'AHDTeamState::Kits' has a wrong offset!");

// Class HDMain.HDTextChatInputWidgetBase
// 0x0010 (0x0240 - 0x0230)
class UHDTextChatInputWidgetBase : public UUserWidget
{
public:
	class FName                                   TextCommsFormatName;                               // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDFCommChannel*                         CurrentTalkChannel;                                // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChatMessageSubmitted(class UHDTextChatMsgInfo* SubmittedChatMsg);
	void StartTalking(class UDFCommChannel* NewTalkChannel);
	void StartTalkingOnChannel(class UDFCommChannel* TalkChannel);
	void StopTalking(class UDFCommChannel* CurrentChannel);
	void StopTalkingOnCurrentChannel();
	void SubmitChatMessage(class FText ChatMsgText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDTextChatInputWidgetBase">();
	}
	static class UHDTextChatInputWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDTextChatInputWidgetBase>();
	}
};
//(alignof(UHDTextChatInputWidgetBase) == 0x000008, "Wrong alignment on UHDTextChatInputWidgetBase");
//(sizeof(UHDTextChatInputWidgetBase) == 0x000240, "Wrong size on UHDTextChatInputWidgetBase");
//(offsetof(UHDTextChatInputWidgetBase, TextCommsFormatName) == 0x000230, "Member 'UHDTextChatInputWidgetBase::TextCommsFormatName' has a wrong offset!");
//(offsetof(UHDTextChatInputWidgetBase, CurrentTalkChannel) == 0x000238, "Member 'UHDTextChatInputWidgetBase::CurrentTalkChannel' has a wrong offset!");

// Class HDMain.HDTextChatMsgInfo
// 0x0020 (0x0048 - 0x0028)
class UHDTextChatMsgInfo final  : public UObject
{
public:
	class UDFCommChannel*                         CommChannel;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerState*                           SenderPS;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ChatMsgContent;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDTextChatMsgInfo">();
	}
	static class UHDTextChatMsgInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDTextChatMsgInfo>();
	}
};
//(alignof(UHDTextChatMsgInfo) == 0x000008, "Wrong alignment on UHDTextChatMsgInfo");
//(sizeof(UHDTextChatMsgInfo) == 0x000048, "Wrong size on UHDTextChatMsgInfo");
//(offsetof(UHDTextChatMsgInfo, CommChannel) == 0x000028, "Member 'UHDTextChatMsgInfo::CommChannel' has a wrong offset!");
//(offsetof(UHDTextChatMsgInfo, SenderPS) == 0x000030, "Member 'UHDTextChatMsgInfo::SenderPS' has a wrong offset!");
//(offsetof(UHDTextChatMsgInfo, ChatMsgContent) == 0x000038, "Member 'UHDTextChatMsgInfo::ChatMsgContent' has a wrong offset!");

// Class HDMain.HDTextChatWidgetBase
// 0x0078 (0x02A8 - 0x0230)
class UHDTextChatWidgetBase : public UUserWidget
{
public:
	uint8                                         Pad_122A[0x38];                                    // 0x0230(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SayAllInputActionName;                             // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SayTeamInputActionName;                            // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SaySquadInputActionName;                           // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SayAllChannelName;                                 // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxChatMsgsToCache;                                // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   LastTalkChannelName;                               // 0x028C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_122B[0x4];                                     // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHDTextChatMsgInfo*>             CurrentChatMsgs;                                   // 0x0298(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisplayChatMessage(class UHDTextChatMsgInfo* NewChatMsg);
	bool GetCachedChatMsgAt(int32 MsgIndex, class UHDTextChatMsgInfo** OutFoundMsg);
	void SayAllActionPressed();
	void SaySquadActionPressed();
	void SayTeamActionPressed();
	void SetMaxChatMsgsToCache(int32 NumChatMsgsToCache);
	void StartTalking(class UDFCommChannel* TalkChannel);
	void StopTalking();

	int32 GetNumCachedChatMsgs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDTextChatWidgetBase">();
	}
	static class UHDTextChatWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDTextChatWidgetBase>();
	}
};
//(alignof(UHDTextChatWidgetBase) == 0x000008, "Wrong alignment on UHDTextChatWidgetBase");
//(sizeof(UHDTextChatWidgetBase) == 0x0002A8, "Wrong size on UHDTextChatWidgetBase");
//(offsetof(UHDTextChatWidgetBase, SayAllInputActionName) == 0x000268, "Member 'UHDTextChatWidgetBase::SayAllInputActionName' has a wrong offset!");
//(offsetof(UHDTextChatWidgetBase, SayTeamInputActionName) == 0x000270, "Member 'UHDTextChatWidgetBase::SayTeamInputActionName' has a wrong offset!");
//(offsetof(UHDTextChatWidgetBase, SaySquadInputActionName) == 0x000278, "Member 'UHDTextChatWidgetBase::SaySquadInputActionName' has a wrong offset!");
//(offsetof(UHDTextChatWidgetBase, SayAllChannelName) == 0x000280, "Member 'UHDTextChatWidgetBase::SayAllChannelName' has a wrong offset!");
//(offsetof(UHDTextChatWidgetBase, MaxChatMsgsToCache) == 0x000288, "Member 'UHDTextChatWidgetBase::MaxChatMsgsToCache' has a wrong offset!");
//(offsetof(UHDTextChatWidgetBase, LastTalkChannelName) == 0x00028C, "Member 'UHDTextChatWidgetBase::LastTalkChannelName' has a wrong offset!");
//(offsetof(UHDTextChatWidgetBase, CurrentChatMsgs) == 0x000298, "Member 'UHDTextChatWidgetBase::CurrentChatMsgs' has a wrong offset!");

// Class HDMain.HDUGCLoadProgressScreen
// 0x0000 (0x0238 - 0x0238)
class UHDUGCLoadProgressScreen : public UDFBaseMenu
{
public:
	void SetupProgressScreen(int32 TotalUGCToLoad);
	void UpdateLoadProgress(int32 NumUGCRemainingToLoad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUGCLoadProgressScreen">();
	}
	static class UHDUGCLoadProgressScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUGCLoadProgressScreen>();
	}
};
//(alignof(UHDUGCLoadProgressScreen) == 0x000008, "Wrong alignment on UHDUGCLoadProgressScreen");
//(sizeof(UHDUGCLoadProgressScreen) == 0x000238, "Wrong size on UHDUGCLoadProgressScreen");

// Class HDMain.HDUIStatics
// 0x0000 (0x0028 - 0x0028)
class UHDUIStatics final  : public UBlueprintFunctionLibrary
{
public:
	static class FString GetServerIp(struct FHDServerInfo& InServerInfo);
	static class FString GetServerIpPort(struct FHDServerInfo& InServerInfo);
	static int32 GetServerPort(struct FHDServerInfo& InServerInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUIStatics">();
	}
	static class UHDUIStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUIStatics>();
	}
};
//(alignof(UHDUIStatics) == 0x000008, "Wrong alignment on UHDUIStatics");
//(sizeof(UHDUIStatics) == 0x000028, "Wrong size on UHDUIStatics");

// Class HDMain.HDUIUserWidget
// 0x0008 (0x0238 - 0x0230)
class UHDUIUserWidget : public UUserWidget
{
public:
	uint8                                         bListenForPlayerCharacterEvents : 1;               // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_122F[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPDeinitializeFromOwnerPlayerCharacter(class AHDPlayerCharacter* OwnerPlyChar);
	void BPDeinitializeFromOwnerWeapon(class AHDBaseWeapon* OwnerWeap);
	void BPInitializeForOwnerPlayerCharacter(class AHDPlayerCharacter* OwnerPlyChar);
	void BPInitializeForOwnerWeapon(class AHDBaseWeapon* OwnerWeap);
	void BPOwnerDeath(class APawn* VictimPawn, class AController* VictimController, float KillingDamage, struct FDamageEvent& DamageEvent, class APawn* InstigatingPawn, class AActor* DamageCauser);
	void BPOwnerPossessPawn(class APawn* NewPawn);
	void BPOwnerUnpossessPawn(class APawn* UnpossessedPawn);
	void BPOwnerWeaponChanged(class AHDBaseWeapon* NewWeap, class AHDBaseWeapon* PrevWeap);
	void OwnerDeath(class APawn* VictimPawn, class AController* VictimController, float KillingDamage, struct FDamageEvent& DamageEvent, class APawn* InstigatingPawn, class AActor* DamageCauser);
	void OwnerEquippedItemChanged(class ADFBaseCharacter* Character, class ADFBaseItem* NewEquippedItem, class ADFBaseItem* PrevEquippedItem);
	void OwnerPossessPawn(class APawn* NewPawn);
	void OwnerUnpossessPawn(class APawn* UnpossessedPawn);

	class AHDBaseWeapon* GetOwnerEquippedWeapon() const;
	class AHDPlayerController* GetOwningHDPlayer() const;
	class AHDPlayerCharacter* GetOwningHDPlayerCharacter() const;
	class UDFCharacterMovementComponent* GetOwningHDPlayerCharacterMovement() const;
	class AHDHUD* GetOwningHDPlayerHUD() const;
	class AHUD* GetOwningPlayerHUD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUIUserWidget">();
	}
	static class UHDUIUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUIUserWidget>();
	}
};
//(alignof(UHDUIUserWidget) == 0x000008, "Wrong alignment on UHDUIUserWidget");
//(sizeof(UHDUIUserWidget) == 0x000238, "Wrong size on UHDUIUserWidget");

// Class HDMain.HDUIUWCaptureStatus
// 0x0030 (0x0268 - 0x0238)
class UHDUIUWCaptureStatus : public UHDUIUserWidget
{
public:
	uint8                                         Pad_1232[0x30];                                    // 0x0238(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ControlPointSetCaptureProgress(bool bContested, float NewValueNorm, float OldValueNorm, bool bInitial);
	void ControlPointSetGarrisonedPlayerCount(int32 NumFriendlies, int32 NumEnemies, int32 MinNumRequiredForCapture, bool bInitial);
	void ControlPointSetOwnershipState(bool bCaptured, EHDTeam NewOwningTeam, EHDTeam OldOwningTeam, bool bInitial);
	void CPBeginEndOverlap(class AActor* OverlappedControlPointActor, class AActor* OtherActor);
	void CPCaptureProgressUpdate(class AHDBaseCapturePoint* ControlPoint, bool bInCaptureContested, int32 InCaptureProgress);
	void CPOwnershipUpdate(class AHDBaseCapturePoint* ControlPoint, EHDTeam PrevOwningTeam, EHDTeam NewOwningTeam, bool bCaptured);
	void OwnerBeginOverlap(class AActor* OverlappedOwnerChar, class AActor* OtherActor);
	void OwnerEndOverlap(class AActor* OverlappedOwnerChar, class AActor* OtherActor);
	void OwnerNoControlPoint();
	void OwnerTouchingControlPoint(class AHDBaseCapturePoint* OverlappingCP, bool bInitial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUIUWCaptureStatus">();
	}
	static class UHDUIUWCaptureStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUIUWCaptureStatus>();
	}
};
//(alignof(UHDUIUWCaptureStatus) == 0x000008, "Wrong alignment on UHDUIUWCaptureStatus");
//(sizeof(UHDUIUWCaptureStatus) == 0x000268, "Wrong size on UHDUIUWCaptureStatus");

// Class HDMain.HDUIUWHUD
// 0x0000 (0x0238 - 0x0238)
class UHDUIUWHUD : public UHDUIUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUIUWHUD">();
	}
	static class UHDUIUWHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUIUWHUD>();
	}
};
//(alignof(UHDUIUWHUD) == 0x000008, "Wrong alignment on UHDUIUWHUD");
//(sizeof(UHDUIUWHUD) == 0x000238, "Wrong size on UHDUIUWHUD");

// Class HDMain.HDUIUWPlayerStatus
// 0x0020 (0x0258 - 0x0238)
class UHDUIUWPlayerStatus : public UHDUIUserWidget
{
public:
	uint8                                         Pad_1239[0x20];                                    // 0x0238(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OwnerAimTransitionUpdate(bool bIsAiming);
	void OwnerEndAim();
	void OwnerEndSprint();
	void OwnerHealthUpdate(class ADFBaseCharacter* Character, float NewHealthTotal, float PrevHealthTotal);
	void OwnerSetHealth(float NewValueNorm, float OldValueNorm, bool bInitial);
	void OwnerSetJumpStamina(float NewValueNorm, float OldValueNorm, bool bInitial);
	void OwnerSetSprintStamina(float NewValueNorm, float OldValueNorm, bool bInitial);
	void OwnerSetStance(ECharacterStance NewStance, ECharacterStance OldStance, bool bInitial);
	void OwnerSetStanceState(EHDUICharacterStanceState NewState, EHDUICharacterStanceState OldState, bool bInitial);
	void OwnerSprintTransitionUpdate(bool bIsSprinting);
	void OwnerStartAim();
	void OwnerStartSprint();
	void OwnerUpdateStamina(float SprintValueNorm, float JumpValueNorm, bool bInitial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUIUWPlayerStatus">();
	}
	static class UHDUIUWPlayerStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUIUWPlayerStatus>();
	}
};
//(alignof(UHDUIUWPlayerStatus) == 0x000008, "Wrong alignment on UHDUIUWPlayerStatus");
//(sizeof(UHDUIUWPlayerStatus) == 0x000258, "Wrong size on UHDUIUWPlayerStatus");

// Class HDMain.HDUIUWWeaponStatus
// 0x0028 (0x0260 - 0x0238)
class UHDUIUWWeaponStatus : public UHDUIUserWidget
{
public:
	class AHDBaseWeapon*                          OwnerEquippedWeapon;                               // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123E[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHDUIWeaponAmmoState                   WeapAmmoState;                                     // 0x0248(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void BPOwnerWeaponAmmoUpdated(struct FHDUIWeaponAmmoState& AmmoState, bool bFromReload, bool bTotalFreeAmmoUpdated, bool bNumFreeAmmoClipsUpdated);
	void BPOwnerWeaponSetFireMode(EFireMode NewFireMode, EFireMode PreviousFireMode, bool bFromPlayerInput);
	void OwnerAimStyleChanged(class AHDPlayerCharacter* Character, EHDWeaponAimStyle NewAimStyle, EHDWeaponAimStyle PrevAimStyle, bool bFromPlayerInput);
	void OwnerSetAimStyle(EHDWeaponAimStyle NewAimStyle, EHDWeaponAimStyle PrevAimStyle, bool bFromPlayerInput);
	void OwnerWeaponFireModeChanged(class ADFBaseGun* Gun, EFireMode NewFireMode, EFireMode PrevFireMode, bool bFromPlayerInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDUIUWWeaponStatus">();
	}
	static class UHDUIUWWeaponStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDUIUWWeaponStatus>();
	}
};
//(alignof(UHDUIUWWeaponStatus) == 0x000008, "Wrong alignment on UHDUIUWWeaponStatus");
//(sizeof(UHDUIUWWeaponStatus) == 0x000260, "Wrong size on UHDUIUWWeaponStatus");
//(offsetof(UHDUIUWWeaponStatus, OwnerEquippedWeapon) == 0x000238, "Member 'UHDUIUWWeaponStatus::OwnerEquippedWeapon' has a wrong offset!");
//(offsetof(UHDUIUWWeaponStatus, WeapAmmoState) == 0x000248, "Member 'UHDUIUWWeaponStatus::WeapAmmoState' has a wrong offset!");

// Class HDMain.HDVehiclePlayerSeatComponent
// 0x0000 (0x0198 - 0x0198)
class UHDVehiclePlayerSeatComponent : public UArcVehiclePlayerSeatComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDVehiclePlayerSeatComponent">();
	}
	static class UHDVehiclePlayerSeatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDVehiclePlayerSeatComponent>();
	}
};
//(alignof(UHDVehiclePlayerSeatComponent) == 0x000008, "Wrong alignment on UHDVehiclePlayerSeatComponent");
//(sizeof(UHDVehiclePlayerSeatComponent) == 0x000198, "Wrong size on UHDVehiclePlayerSeatComponent");

// Class HDMain.HDVoiceChatMsgInfo
// 0x0018 (0x0040 - 0x0028)
class UHDVoiceChatMsgInfo final  : public UObject
{
public:
	class UDFCommChannel*                         CommChannel;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerState*                           TalkerPS;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bTalking : 1;                                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1242[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDVoiceChatMsgInfo">();
	}
	static class UHDVoiceChatMsgInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDVoiceChatMsgInfo>();
	}
};
//(alignof(UHDVoiceChatMsgInfo) == 0x000008, "Wrong alignment on UHDVoiceChatMsgInfo");
//(sizeof(UHDVoiceChatMsgInfo) == 0x000040, "Wrong size on UHDVoiceChatMsgInfo");
//(offsetof(UHDVoiceChatMsgInfo, CommChannel) == 0x000028, "Member 'UHDVoiceChatMsgInfo::CommChannel' has a wrong offset!");
//(offsetof(UHDVoiceChatMsgInfo, TalkerPS) == 0x000030, "Member 'UHDVoiceChatMsgInfo::TalkerPS' has a wrong offset!");

// Class HDMain.HDVoipIndicatorListingWidgetBase
// 0x0008 (0x0238 - 0x0230)
class UHDVoipIndicatorListingWidgetBase : public UUserWidget
{
public:
	class UHDVoiceChatMsgInfo*                    VoiceMsgInfo;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnVoiceMsgInfoSet(bool bIsDesignTime);
	void SetupVoiceListing(class UHDVoiceChatMsgInfo* InVoiceMsgInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDVoipIndicatorListingWidgetBase">();
	}
	static class UHDVoipIndicatorListingWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDVoipIndicatorListingWidgetBase>();
	}
};
//(alignof(UHDVoipIndicatorListingWidgetBase) == 0x000008, "Wrong alignment on UHDVoipIndicatorListingWidgetBase");
//(sizeof(UHDVoipIndicatorListingWidgetBase) == 0x000238, "Wrong size on UHDVoipIndicatorListingWidgetBase");
//(offsetof(UHDVoipIndicatorListingWidgetBase, VoiceMsgInfo) == 0x000230, "Member 'UHDVoipIndicatorListingWidgetBase::VoiceMsgInfo' has a wrong offset!");

// Class HDMain.HDVoipIndicatorWidgetBase
// 0x0050 (0x0280 - 0x0230)
class UHDVoipIndicatorWidgetBase : public UUserWidget
{
public:
	TMap<struct FUniqueNetIdVoipWrapper, class UHDVoiceChatMsgInfo*> ActiveTalkerMap;                                   // 0x0230(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnOwningPlayerStartTalking(class UHDVoiceChatMsgInfo* LocalTalkerMsgInfo);
	void OnOwningPlayerStopTalking(class UHDVoiceChatMsgInfo* LocalTalkerMsgInfo);
	void OnPlayerStartTalking(class UHDVoiceChatMsgInfo* TalkerMsgInfo);
	void OnPlayerStopTalking(class UHDVoiceChatMsgInfo* TalkerMsgInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDVoipIndicatorWidgetBase">();
	}
	static class UHDVoipIndicatorWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDVoipIndicatorWidgetBase>();
	}
};
//(alignof(UHDVoipIndicatorWidgetBase) == 0x000008, "Wrong alignment on UHDVoipIndicatorWidgetBase");
//(sizeof(UHDVoipIndicatorWidgetBase) == 0x000280, "Wrong size on UHDVoipIndicatorWidgetBase");
//(offsetof(UHDVoipIndicatorWidgetBase, ActiveTalkerMap) == 0x000230, "Member 'UHDVoipIndicatorWidgetBase::ActiveTalkerMap' has a wrong offset!");

// Class HDMain.HDWeaponAnimInstance
// 0x0000 (0x0280 - 0x0280)
class UHDWeaponAnimInstance : public UDFWeaponAnimInstance
{
public:
	class AHDBaseWeapon*                          HDWeaponOwner;                                     // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDWeaponAnimInstance">();
	}
	static class UHDWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDWeaponAnimInstance>();
	}
};
//(alignof(UHDWeaponAnimInstance) == 0x000010, "Wrong alignment on UHDWeaponAnimInstance");
//(sizeof(UHDWeaponAnimInstance) == 0x000280, "Wrong size on UHDWeaponAnimInstance");
//(offsetof(UHDWeaponAnimInstance, HDWeaponOwner) == 0x000278, "Member 'UHDWeaponAnimInstance::HDWeaponOwner' has a wrong offset!");

// Class HDMain.HDWeaponScopeComponent
// 0x0000 (0x01F0 - 0x01F0)
class UHDWeaponScopeComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDWeaponScopeComponent">();
	}
	static class UHDWeaponScopeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHDWeaponScopeComponent>();
	}
};
//(alignof(UHDWeaponScopeComponent) == 0x000010, "Wrong alignment on UHDWeaponScopeComponent");
//(sizeof(UHDWeaponScopeComponent) == 0x0001F0, "Wrong size on UHDWeaponScopeComponent");

// Class HDMain.HDWorldSettings
// 0x0010 (0x0528 - 0x0518)
class AHDWorldSettings final  : public ATBWorldSettings
{
public:
	class UHDTeamDefinition*                      BluforTeamDefinition;                              // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHDTeamDefinition*                      OpforTeamDefinition;                               // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HDWorldSettings">();
	}
	static class AHDWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHDWorldSettings>();
	}
};
//(alignof(AHDWorldSettings) == 0x000008, "Wrong alignment on AHDWorldSettings");
//(sizeof(AHDWorldSettings) == 0x000528, "Wrong size on AHDWorldSettings");
//(offsetof(AHDWorldSettings, BluforTeamDefinition) == 0x000518, "Member 'AHDWorldSettings::BluforTeamDefinition' has a wrong offset!");
//(offsetof(AHDWorldSettings, OpforTeamDefinition) == 0x000520, "Member 'AHDWorldSettings::OpforTeamDefinition' has a wrong offset!");

// Class HDMain.PlatoonListEntry
// 0x0028 (0x0050 - 0x0028)
class UPlatoonListEntry final  : public UObject
{
public:
	uint8                                         TeamId;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHDTeam                                       Team;                                              // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1243[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDTeamState*                           TeamState;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ID;                                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1244[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHDPlatoonInfo*                         Info;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlatoonState*                        PlatoonState;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatoonListEntry">();
	}
	static class UPlatoonListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatoonListEntry>();
	}
};
//(alignof(UPlatoonListEntry) == 0x000008, "Wrong alignment on UPlatoonListEntry");
//(sizeof(UPlatoonListEntry) == 0x000050, "Wrong size on UPlatoonListEntry");
//(offsetof(UPlatoonListEntry, TeamId) == 0x000028, "Member 'UPlatoonListEntry::TeamId' has a wrong offset!");
//(offsetof(UPlatoonListEntry, Team) == 0x000029, "Member 'UPlatoonListEntry::Team' has a wrong offset!");
//(offsetof(UPlatoonListEntry, TeamState) == 0x000030, "Member 'UPlatoonListEntry::TeamState' has a wrong offset!");
//(offsetof(UPlatoonListEntry, ID) == 0x000038, "Member 'UPlatoonListEntry::ID' has a wrong offset!");
//(offsetof(UPlatoonListEntry, Info) == 0x000040, "Member 'UPlatoonListEntry::Info' has a wrong offset!");
//(offsetof(UPlatoonListEntry, PlatoonState) == 0x000048, "Member 'UPlatoonListEntry::PlatoonState' has a wrong offset!");

// Class HDMain.SquadListEntry
// 0x0028 (0x0050 - 0x0028)
class USquadListEntry final  : public UObject
{
public:
	uint8                                         TeamId;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHDTeam                                       Team;                                              // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1245[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDTeamState*                           TeamState;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlatoonListEntry*                      ParentPlatoonData;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ID;                                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1246[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDSquadState*                          SquadState;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AHDPlatoonState* GetParentPlatoonState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadListEntry">();
	}
	static class USquadListEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadListEntry>();
	}
};
//(alignof(USquadListEntry) == 0x000008, "Wrong alignment on USquadListEntry");
//(sizeof(USquadListEntry) == 0x000050, "Wrong size on USquadListEntry");
//(offsetof(USquadListEntry, TeamId) == 0x000028, "Member 'USquadListEntry::TeamId' has a wrong offset!");
//(offsetof(USquadListEntry, Team) == 0x000029, "Member 'USquadListEntry::Team' has a wrong offset!");
//(offsetof(USquadListEntry, TeamState) == 0x000030, "Member 'USquadListEntry::TeamState' has a wrong offset!");
//(offsetof(USquadListEntry, ParentPlatoonData) == 0x000038, "Member 'USquadListEntry::ParentPlatoonData' has a wrong offset!");
//(offsetof(USquadListEntry, ID) == 0x000040, "Member 'USquadListEntry::ID' has a wrong offset!");
//(offsetof(USquadListEntry, SquadState) == 0x000048, "Member 'USquadListEntry::SquadState' has a wrong offset!");

// Class HDMain.SquadMemberInfo
// 0x0028 (0x0050 - 0x0028)
class USquadMemberInfo final  : public UObject
{
public:
	uint8                                         TeamId;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHDTeam                                       Team;                                              // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1247[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AHDTeamState*                           TeamState;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlatoonListEntry*                      ParentPlatoonData;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USquadListEntry*                        ParentSquadData;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AHDPlayerState*                         PlayerState;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AHDPlatoonState* GetParentPlatoonState() const;
	class AHDSquadState* GetParentSquadState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadMemberInfo">();
	}
	static class USquadMemberInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadMemberInfo>();
	}
};
//(alignof(USquadMemberInfo) == 0x000008, "Wrong alignment on USquadMemberInfo");
//(sizeof(USquadMemberInfo) == 0x000050, "Wrong size on USquadMemberInfo");
//(offsetof(USquadMemberInfo, TeamId) == 0x000028, "Member 'USquadMemberInfo::TeamId' has a wrong offset!");
//(offsetof(USquadMemberInfo, Team) == 0x000029, "Member 'USquadMemberInfo::Team' has a wrong offset!");
//(offsetof(USquadMemberInfo, TeamState) == 0x000030, "Member 'USquadMemberInfo::TeamState' has a wrong offset!");
//(offsetof(USquadMemberInfo, ParentPlatoonData) == 0x000038, "Member 'USquadMemberInfo::ParentPlatoonData' has a wrong offset!");
//(offsetof(USquadMemberInfo, ParentSquadData) == 0x000040, "Member 'USquadMemberInfo::ParentSquadData' has a wrong offset!");
//(offsetof(USquadMemberInfo, PlayerState) == 0x000048, "Member 'USquadMemberInfo::PlayerState' has a wrong offset!");

// Class HDMain.VictoryMenu
// 0x0018 (0x0250 - 0x0238)
class UVictoryMenu : public UDFBaseMenu
{
public:
	struct FHDGameRoundEndEventDetails            RoundDetails;                                      // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bWinner : 1;                                       // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1248[0x7];                                     // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(struct FHDGameRoundEndEventDetails& InRoundDetails, bool bInWinner);
	void OnVictoryInit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictoryMenu">();
	}
	static class UVictoryMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictoryMenu>();
	}
};
//(alignof(UVictoryMenu) == 0x000008, "Wrong alignment on UVictoryMenu");
//(sizeof(UVictoryMenu) == 0x000250, "Wrong size on UVictoryMenu");
//(offsetof(UVictoryMenu, RoundDetails) == 0x000238, "Member 'UVictoryMenu::RoundDetails' has a wrong offset!");

}

